{"./":{"url":"./","title":"knowledge","keywords":"","body":"周计划 5.27日 ~ 6.2日 看云搬家到gitbook([html]) [ing]@Inject 和 @Input的区别 创建模型的方式让JS代码更加优雅 rxJs系列学习(3) @Input的get,set以及ngOnChanges() HttpClient 学习池 Angular文档阅读：DI 实战 Angular文档阅读：浏览组件树 es6 typeScript 四种常见的 POST 提交数据方式 JavaScript 函数式编程http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/ redux理论及应用 SVG图案 SVG裁切和蒙版 lerna 进阶学习(包含项目实战) vim学习 react 技术栈 Web Components svg 慕课视频 css动画 js运动 call，apply，bind 方法详解 单元测试 underscore源码阅读 mQuery 算法 函数相关知识 如何使用n管理node.js版本 JavaScript 浮点数陷阱及解法 https://github.com/camsong/blog/issues/9 常见的开源协议：MIT等等 图片的原理和优化方案 什么是图片，计算机是如何表示和理解图片的 历史上的图片优化方案：雪碧图，文件格式，压缩 区分可控图片和不可控图片 该如何优化呢？ HTML目录 【基础】 HTML 基础语法（HTML简介，HTML文档声明） HTML 元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则） HTML 属性 HTML 常用标签（a，img） HTML 表格 HTML iframe 使用postMessage方法进行跨文档消息传递 HTML 表单(form元素介绍，input元素的常用type类型，input元素的常用属性) HTML meta标签&base标签 HTML 条件注释规范 【重难】 attribute和property的区别 深入理解HTML表格 table单元格中文字过长如何进行省略 CSS目录 【CSS2 基础】 CSS文件引入 CSS 选择器(常规选择器，伪类选择器，伪元素选择器，根元素选择器) 层叠和结构 长度单位em,rem CSS 样式关键字(initial,inherit,unset,revert,all) 伪类和伪元素 *CSS 盒模型 *CSS 视觉格式化 line-height && vertical-align border CSS 外边距 margin CSS margin负值 outline overflow css滚动条 display visibility css浮动 css清除浮动 颜色color 背景background 透明度opacity 光标cursor 【定位】 position 定位之距离偏移 position 定位之层级z-index 绝对定位 绝对定位的应用 相对定位和固定定位 【字体和文本】 font字体 iconfont字体应用实战 文本样式 css文本方向 空白符和换行 文本溢出和文本阴影 【布局】 wip:案例迁移到git上grid栅格布局 Media查询 flex布局 移动优先的响应式布局 水平垂直居中 两端对齐布局 单列定宽，单列自适应 两列自适应布局 三列布局 三栏式布局 等分布局 等高布局 全屏布局 sticky-footer布局 【CSS预处理语言】 less sass && scss 【动画】 过渡transition 变形transform(2d) 变形transform(3d) 线性渐变linear-gradient 径向渐变 动画animation animate.css库使用 【规范】 css 规范（reset , 命名） StyleLint 【其它】 css兼容总结 haslayout总结 css滤镜 剪裁clip clip-path 元素显示隐藏的思路 css变量variable 【重点难点】 BFC（格式化上下文）深入理解 font-size为0消除inline&&inline-block元素间隙 css中数学表达式calc height设置100%失效 && 分栏高度自适应布局 css-modules JavaScript目录 【ES5】 【基本概念】 JavaScript 基础(语法、关键字和保留字、变量) JavaScript 基础(表达式) JavaScript 基础(动态脚本) JavaScript 基础(严格模式) JavaScript 运算符(语法概述) JavaScript 运算符(算术运算符) JavaScript 运算符(关系运算符) JavaScript 运算符(逻辑运算符) JavaScript 运算符(位运算符) JavaScript 运算符(条件、逗号、赋值、()和void运算符) JavaScript 语句(表达式语句、块语句、空语句和声明语句) JavaScript 语句(条件语句、循环语句和跳转语句) JavaScript 语句(eval和with) JavaScript 规范(javascript编码标准) JavaScript 规范(关于javascript代码优化的8点建议) JavaScript 规范(JS代码检查工具ESLint) 【变量、作用域和内存问题】 JavaScript 基本类型和引用类型 JavaScript 执行环境、作用域、内存管理及垃圾回收机制 【数据类型】 基本包装类型 null和undefined (void 0) 与 undefined Boolean布尔类型 Number数字类型 Math对象 String字符串类型 String字符串类型的属性和方法 【数组】 Array基础 数组方法总结 数组检测方式 【Date】 日期和时间基础知识 Date日期对象 日历实现 moment.js库的应用 【RegExp】 正则表达式基础 RegExp类型 javaScript模版引擎原理解析 【类型转换】 toString() && valueOf() 数据类型转换 JavaScript 有效的类型判断 【面向对象】 Object类型基础知识 对象的属性 创建对象的几种方式 对象继承的几种方式 对象的深复制浅复制 Object.defineProperty介绍 【函数表达式】 JavaScript Function类型 函数的属性和方法 JavaScript 函数递归 JavaScript IIEF 模仿块级作用域 深入学习 JavaScript 闭包 函数式编程 高阶函数 函数柯里化 函数节流和函数防抖 惰性函数 【事件】 JavaScript 事件机制深入学习 JavaScript 事件类型汇总 复制黏贴 浏览器事件循环EventLoop node 事件循环 EventLoop 【BOM】 window对象 location对象 navigator对象 screen对象 history对象 【客户端检测】 能力检测 怪癖检测 浏览器检测 【DOM】 节点类型 获取节点 元素选择器 DOM样式操作 DOM遍历 DOM中的范围 【元素尺寸】 offset client scroll 回到顶部 元素视图的三个方法 【表单脚本】 表单的基础知识 文本框脚本 选择框脚本 富文本编辑 【脚本化CSS】 JavaScript 动态操作CSS 【HTML5新特性】 跨文档消息传递 drag对象进行拖拽 视频播放器audio 音频播放器video 历史状态管理 Web Worker 【错误处理与调试】 错误处理try-catch 前端错误调试的几种常用方法 【数据传递与格式】 JSON语法 XHR对象 CORS 图片Ping JSONP iframe跨域 Fetch axios 前端上传文件的理解 【存储】 Cookie && sessionStorage && localStorage 【模块化】 amd && cmd && CommonJs && ES6模块化 jquery插件是如何支持cmd,amd,commonJs 【高级技巧】 call，apply，bind 方法详解 高级定时器 防篡改对象 滚动优化https://www.cnblogs.com/xiaohuochai/p/9188619.html 简易版jQuery——mQuery https://www.cnblogs.com/xiaohuochai/p/7526278.html 【动画】 JavaScript 运动系列总结 帧动画requestAnimationFrame velocity.js tween.js 拖放实现 模拟滚动条 【性能&规范】 JavaScript 最佳实践 JavaScript 代码优化建议 ESLint 【重点难点】 this 作用域 【ES5 其它】 js浮点运算不精确的解决方案 如何实现中英文切换 JavaScript 判断数组和对象是否为空的方法 【ES6基础】 let 和 const 命令 变量的解构赋值 字符串的扩展 正则的扩展 数值的扩展 函数的扩展 数组的扩展 对象的扩展 Symbol Set 和 Map 数据结构 Promise promise源码实现 Iterator 和 for...of 循环 Generator 函数的语法 async Class 语法 Module 语法 【ES6难点】 Babel ES6 新增数组方法的实战用法 Node目录 【相关学习】 semver规范（语义化版本） npm入门教程 npm scripts 脚本基础指南 mac中如何升级node,npm npm publish 发布 【基础】 (1) 初识Node.js (2) 开发环境和调试工具 (3) commonJs 规范 (4) node 概念(global、process进程、调试) (5) node基础模块 path node基础模块 Buffer node基础模块 event node基础模块 fs node项目初始化 node搭建静态资源服务器 node单元测试 mocha node UI 测试 【http】 Restful架构的理解 node中的http请求 node 处理get请求 node 处理post请求 node 搭建开发环境 node 开发路由搭建 【数据库】 node 操作mysql 【登录功能】 node cookie node session node redis node nginx配置 【日志功能】 node 文件操作 node stream node 日志功能 【安全】 sql注入 xss攻击 【框架】 express框架 koa框架 【上线配置】 PM2工具 【实战】 node 爬虫实现 基于JWT标准的用户认证接口实现 https://www.cnblogs.com/xiaohuochai/p/8440335.html 网络协议目录 HTTP 【基础】 HTTP入门学习 网络基础 数据传输 网站架构演化 连接管理 缓存 【组成】 URL 报文起始行 报文首部 【结构】 Web服务器 代理 网关、隧道和中继 【安全】 Web攻击技术 客户端识别及Cookie 基本认证 摘要认证 安全HTTP 【编码】 实体和编码 字符集 内容协商 使用javascript实现base64编码器 【内容发布】 Web主机托管 重定向和负载均衡 日志记录 【重难】 从输入URL到页面加载的全过程https://www.cnblogs.com/xiaohuochai/p/9193083.html get方法和post方法的区别 DNS预解析prefetch https://www.cnblogs.com/xiaohuochai/p/9185622.html websocket websocket协议基础 websocket聊天室项目实战 Nginx 使用nginx部署网站 https://www.cnblogs.com/xiaohuochai/p/9093819.html 移动端 移动端开发必须了解的知识 移动端高清屏适配方案 300ms以及点透事件产生的原因及处理方案 rem布局详解 JSBridge原理，js和native是如何通信的 H5优化首页白屏时间过长 Hybrid-App 移动端中的陀螺仪 https://www.cnblogs.com/xiaohuochai/p/8511935.html 移动web开发之touch事件 https://www.cnblogs.com/xiaohuochai/p/8293225.html TypeScript 数据结构 数据结构之图 https://www.cnblogs.com/xiaohuochai/p/8185671.html 数据结构之树 https://www.cnblogs.com/xiaohuochai/p/8184989.html 数据结构之字典和散列表 https://www.cnblogs.com/xiaohuochai/p/8183020.html 数据结构之集合 https://www.cnblogs.com/xiaohuochai/p/8176248.html 数据结构之链表 https://www.cnblogs.com/xiaohuochai/p/8175716.html 数据结构之队列 https://www.cnblogs.com/xiaohuochai/p/8174854.html 数据结构之栈 https://www.cnblogs.com/xiaohuochai/p/8174742.html 设计模式 单例模式 观察者模式 算法 算法复杂度 https://www.cnblogs.com/xiaohuochai/p/8203717.html 算法模式 https://www.cnblogs.com/xiaohuochai/p/8203142.html 搜索算法 https://www.cnblogs.com/xiaohuochai/p/8203058.html 排序算法 https://www.cnblogs.com/xiaohuochai/p/8198275.html 代码管理工具 git学习总结 git分支管理策略 浏览器 深入理解浏览器工作原理 https://www.cnblogs.com/xiaohuochai/p/9174471.html chrome devTools 使用教程 渲染机制 缓存机制 资源预加载preload和资源预读取prefetch简明学习https://www.cnblogs.com/xiaohuochai/p/9183874.html 使用chrome开发者工具中的performance面板解决性能瓶颈 https://www.cnblogs.com/xiaohuochai/p/9182710.html 使用chrome开发者工具中的network面板测量网站网络性能 https://www.cnblogs.com/xiaohuochai/p/9182165.html 计算机基础 base64 unicode编码 shell编程入门 时间格式说明 虚拟主机 代理、网关、隧道 vim学习 【Linux】 常用bash命令 Linux用户组、文件权限 操作系统理解：unix、linux、windows linux常用命令级管理 Web Components 可重用网络组件 Custom Elements 独立的网络组件 Shadow DOM 前端框架 【react】 react实战项目开发(1) 搭建react开发环境初始化项目（Create-react-app） react实战项目开发(2) react基础语法之JSX [react实战项目开发() react组件条件渲染、列表渲染等基础语法] [react实战项目开发() react组件状态与组件生命周期] [react实战项目开发() react组件之间的传值] [react实战项目开发() react事件处理] [react实战项目开发() react实战todolist小项目] [react实战项目开发() react表单] [react实战项目开发() react类型检查] [react实战项目开发() react通过Refs访问DOM] 【vue】 vue 实战视频学习 vue 基础 vue 全家桶搭建开箱即用的脚手架 vue 实战xxx vue 是如何实现双向绑定的 vue 源码阅读学习 vue 相关深入学习 vuex 之类的 【AngularJS】 AngularJS基础 【Angular】 Angular项目初始化 ng常用命令 Angular模板语法 Angular生命周期 Angular组件交互 Angular样式 Angular指令 Angular管道 Angular事件处理 NgModule Angular依赖注入(DI)与服务service详解与服务service详解.md) 表单 模板驱动表单 wip:[表单]响应式表单 自定义表单验证器 [表单]自定义表单控件 重难点 @Input() or @Inject() 该如何选择 【路由】 UI-Router基础 【状态管理】 Mobx redux https://www.cnblogs.com/xiaohuochai/p/8652683.html 【框架的重点难点】 vue 和 react 的区别 实现一个简单的mvvm框架 服务端渲染方案SSR visualDOM diff算法 编写简单版的UI组件库 网站PWA升级https://www.cnblogs.com/xiaohuochai/p/9173959.html 单元测试 单元测试原则以及在开发中的作用 常见测试框架以及工具使用 TDD理论以及操作原则 TDD与BDD比较 TDD实践 前端构建 gulp webpack webpack基础 webpack实战 webpack Tree-shaking深入学习 抽象语法树AST 手写一个plugin rollup.js 实现一个打包工具 性能优化 前端性能优化的七大手段https://www.cnblogs.com/xiaohuochai/p/9178390.html 图片优化https://www.cnblogs.com/xiaohuochai/p/9183454.html 前端安全 跨域问题 跨站脚本攻击（XSS） CSRF攻击 oAuth2.0 前端监控 计算机图形 canvas svg svg 基本形状及样式设置 svg 文本 svg 路径 svg 辅助标签 svg 视野 svg 坐标系统及图形变换 svg 渐变 3D 常用工具 Homebrew yarn lerna 插件库 chart.js 实战配置、插件编写 lodash rxjs 源码阅读 underscore underscore源码非常值得阅读 https://github.com/lessfish/underscore-analysis/blob/master/underscore-1.8.3.js/underscore-1.8.3-analysis.js antd源码 checkbox的实现 发布 使用jenkins进行前端项目自动部署 实战 积累一个自己的类库 使用react或者vue实现一个简易版的组件库 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 18:01:35 "},"该如何进行学习.html":{"url":"该如何进行学习.html","title":"该如何进行学习","keywords":"","body":"前言 随着学习的知识越来越多，如果没有一套有效的方式，知识库会越来越混来，导致学的越多却一点都记不住，本文将边思考边总结一套适合自己的学习方式 好的习惯 针对重要的知识每月输出2篇原创文章 每隔3个月把自己的笔记复习一遍 笔记   选择做笔记应该是最好管理知识的方式了，正如以前小时候读书借助笔记一样，但是现在的知识不太一样了，有丰富的代码、图片、案例等东西。那么我们所需要的工具则会从之前的纸质笔记本进行提升到现在的网络工具。   可以多人协作，当然自己在多台电脑上可以进行操作笔记，方便随时进行翻阅记忆，无需自己折腾服务器之类的   于是乎选择了“showdoc”，更多的希望以该形式为主导的去积累自己的知识库，当积累到一定程度，便可以对例如“稀土掘金”，“segmentFault ” 等有人气有流量的网站去发表自己的原创博客。这应该也是所谓的“厚积薄发”吧，虽然很希望自己写的文章有人看，有人评价，但是更加希望写的文章是原创的且有质量的。 【showdoc】 主要用来组织自己的核心知识库 基础知识库组织，由于目录结构清晰因此方便在线搜索、随时查阅、提升知识稳固度。 工作驱动常用的文档编写，例如angular，react在实践过程可以积累到很多常用的方法，但是这些在官方文档是没有体现出来的，所以就需要自己记录下来。 公司项目的一些特有开发流程之类的笔记 【博客网站】  上面已经提到了，这些网站更加适合发表原创的，有中等或以上质量的文章，这是对自我的一个要求，宁缺毋滥，切莫害人害己 常用网站： segmentFault 稀土掘金 简书 博客园 架构   不论做大小事情，凡是先做好规划再行动也是稳妥的做成一件事情的先驱条件，例如马上要开始一个项目，我们就要对项目进行规划分类成一个一个小块，然后定好一个目标节点时间，定好每日应该当完成的工作量，以保证项目在如期的进度完成。 从此可以引申，大到人生规划，小至事件规划，都需要良好的架构进行支撑 个人规划 2019年唯一目标：  全面抓基础，仔仔细细学习前端的基础知识，力争做到不论项目多忙，每日一小文； 希望在2019年12月31日可以完成 html, css, js, node.js, 网络协议等等基础内容(以目录为标准)   2019年更加希望全家人身体健康，儿子快快乐乐长大。   ----2019年5月2日早5:20 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:25:30 "},"博客使用方法.html":{"url":"博客使用方法.html","title":"博客使用方法","keywords":"","body":"文章状态 有疑问：todo:problem 进行中：wip markdown 换行： 连续两个以上空格 使用html语言换行标签： 首行缩进两个字符：(每个表示一个空格，连续使用两个即可） &ensp; 半角的空格 &emsp; 全角的空格 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:24:03 "},"学习资源收藏.html":{"url":"学习资源收藏.html","title":"学习资源收藏","keywords":"","body":"前端面试 前端面试手册 掘金小册面试 常用查询网站 MDN caniuse 印记中文 lion实例 学习资源 个人博客) 学习资源 掘金小册 Angular 4.x 修仙之路 收藏文章 JavaScript深入系列 九种跨域方式实现原理（完整版） 前端下载总结 JavaScript 复杂判断的更优雅写法 逐行阅读redux源码（一) createStore 前端 H5 横屏 独特处理方案详解 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:22:28 "},"gitbook的使用以及快速部署.html":{"url":"gitbook的使用以及快速部署.html","title":"gitbook的使用以及快速部署","keywords":"","body":"前言 本文主要介绍如何使用 gitbook 并且发布到github pages中 安装 安装前需要自行安装node.js sudo npm install gitbook -g 使用 1、创建一个git仓库 2、拉取git仓库 git clone https://github.com/shiyou00/book.git cd book/ 3、初始化gitbook gitbook init 初始化 gitbook serve 启动服务 4、打开界面 http://localhost:4000 目录结构 $ tree book/ book/ ├── README.md └── SUMMARY.md 0 directories, 2 files 可以看到一个初始化的书籍已经出现了 发布到 github pages 1、推送代码到git仓库 git add . git commit -m \"add pages\" git push 2、安装工具 sudo npm install -g gh-pages 3、执行gitbook build 把书籍打包到_book目录下 4、执行命令gh-pages -d _book 至此就发布成立可以打开相应的链接：Your site is published at https://shiyou00.github.io/book/ 好了已经成功部署到github pages中托管了，以后可以直接线上访问了，非常方便。 gitbook的使用教程 gitbook的使用教程 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:27:20 "},"HTML基础语法（HTML简介，HTML文档声明）.html":{"url":"HTML基础语法（HTML简介，HTML文档声明）.html","title":"HTML 基础语法（HTML简介，HTML文档声明）","keywords":"","body":"HTML 概念介绍 【概念】 (Hyper Text Markup Language)超文本标记语言，是用来描述网页的一种语言 超文本(Hyper Text):不只包括文本，也可以包括图片、链接、音乐、视频等非文本元素 标记语言(Markup Language):标记语言是一套标记标签，HTML使用标记标签来描述网页 【标签】 单标签： 双标签： HTML标签对大小写不敏感，但要全小写 【属性】标签的属性 常用属性： class 类 id 元素ID style 元素的行内样式 title 元素的额外信息，可在工具提示中显示 【元素】HTML元素以开始标签起始，以结束标签终止，元素的内容是开始标签与结束标签之间的内容。 【文档】HTML文档被称为网页，由嵌套的HTML元素构成 【注释】注释是在HTML插入的描述性文本，用来解释该代码或提示其他信息。 ps: 注释只出现在代码中，不会在页面中显示；且注释不可嵌套 HTML文档声明 HTML文档通常以类型声明开始，该声明将帮助浏览器确定其尝试解析和显示的HTML文档类型。 特点 文档声明必须是HTML文档的第一行、且顶格显示，对大小写不敏感。因为任何放在DOCTYPE前面的东西，比如批注或XML声明，会令IE9或更早期的浏览器触发怪异模式(后面的渲染模式会介绍) 由于文档类型声明不是标签，因此不应具有关闭标签 【HTML5】 在HTML5之前，文档声明一般有三种类型：严格型strict、过渡型transitional、框架frameset 严格型DTD包含所有HTML元素和属性，但不包含展示性的和弃用的元素(如font)；而过渡型或宽松型(loose)则包含展示性和弃用的元素 【HTML4.01】（1999） 【XHTML1.0】（2000） 【DTD】  DTD称为文档类型定义，它可以定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。在HTML中，DTD使用XML定义了HTML标签规范   由于HTML5不基于SGML，所以不需要引用DTD。但是需要doctype来启用标准模式(后面的渲染模式会介绍)。HTML5的语法元素来自SGML、HTML、XHTML1.X，使它成为一种有自己规则的合成语言 【渲染模式】  在很久以前的网络上，页面通常有两种版本：为网景(Netscape)的Navigator准备的版本以及为微软(Microsoft)的Internet Explorer准备的版本。当W3C创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接起用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。   浏览器排版引擎有三种模式：怪异模式(Quirks mode)、接近标准模式(Almost standards mode)以及标准模式(Standards mode)。在怪异模式下，排版会模拟Navigator4与Internet Explorer 5的非标准行为。为了支持在网络标准被广泛采用前，就已经建好的网站，这么做是必要的。在标准模式下，行为即由HTML与CSS的规范描述的行为。在接近标准模式下，只有少数的怪异行为被实现   对HTML文档来说，浏览器使用文档开头的DOCTYPE来决定用怪异模式处理或标准模式处理。如果文档中没有DOCTYPE将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。在CSS中盒模型被分为两种，第一种是W3C的标准模型，第二种是怪异盒模型。不同之处在于怪异盒模型的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸 小结   通过本节的内容，我们初步了解了什么是HTML，并且同时了解了HTML的文档头的声明，以及标准模型和怪异模型是通过文档头的定义来触发 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:32:17 "},"HTML元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则）.html":{"url":"HTML元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则）.html","title":"HTML元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则）","keywords":"","body":"HTML整体结构解释 ﻿ // 文件应以“”首行顶格开始，推荐使用“” // 必须声明文档的编码charset，且与文件本身编码保持一致，指定字符编码的 meta 必须是 head 的第一个直接子元素。推荐使用UTF-8编码 // 页面title是不可缺少的一项，title 必须作为 head 的直接子元素，并紧随 charset 声明之后 Document ﻿ // 设置视口 // 引入 CSS 时必须指明 rel=\"stylesheet\" // link标签必须在head标签中引入 ﻿ // 1. js引入要放在body的最下方(防止页面阻塞) 2. 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。这是因为使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境 ﻿ HTML元素 块级元素 【h1, h2, h3, h4, h5, h6】含义：标题元素分为六个等级的标签注意：h1 在一个HTML中最好只出现一次(seo方面) 【p】含义：段落元素 【div】含义：块级空元素 【hr】含义：分割元素 【pre】含义：预定义格式文本在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符(比如空格和换行符)都会显示出来，通常表示已排版的内容，如代码块和字符画等 【blockquote】含义：HTML块级引用元素代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进。若引文来源于网络，则可以将原内容的出处URL地址设置到cite特性上，若要以文本的形式告知读者引文的出处时，可以通过元素 【address】含义：联系信息骨架类：html body表单类：form fieldset output legend optgroup option列表类：ul ol li dl dd dtHTML5新增结构标签：article aside header footer nav sectionHTML5新增多媒体：figure figcaptionHTML5新增功能型：summary details 内联元素 ﻿ 通用容器：span强调重要：em strong文字间隔：i(斜体) b(粗体)不精确文字：s(在HTML5中重新定义为有错的、过时的、不被建议使用的文本，常用于表示价格变动等)高亮显示：mark次要评论：small术语处理：dfn(定义术语) abbr(缩写词)引用：cite(表示作品标题的引用，可以是书影音画等) q(表示短引用，常用于引用别人说的话，用引号可以表达等价语义)换行：br wbr(指定单词可以换行的位置)上下标：sup sub文本删改：ins(文档中插入的内容) del(文档中删除的内容)特定时间：time(表示日期)注音标识：ruby(ruby标签定义注音标识，多用于CJK文字，CJK是指中日韩统一表意文字(Chinese、Japanese、Korean)) rt(标记文字) tp(标记括号) 复制代码 汉 ( hàn ) 语 ( yǔ ) 文字方向：bdi(忽略周围文字方向的文字) bdo(覆盖两种方向的设置，允许显式设置方向，并覆盖所有其他当前方向) When rendered by a browser, these words will appear as 'sdroweseht' 代码：code(计算机代码) kbd(键盘码) samp(计算机例子代码) tt(打字机代码) var(变量) ﻿ 结构元素 section：表示文档中的一个区域(或节)，是区块级通用元素article：表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构。aside：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。nav：HTML导航栏()描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表header：表示页面头部或区块头部footer：表示最近一个章节内容或者根节点(sectioning root)元素的页脚main(IE不支持)：main元素()呈现了文档或应用的主体部分。 ﻿ ﻿ 交互元素(浏览器的支持度太低) details ： 主要用于描述文档或文档某个部分的细节dialog ：用来定义对话框或窗口，且该对话框位于窗口的水平居中位置 ﻿ HTML 元素嵌套规则 1、块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素例： —— 对 —— 对 —— 错 ﻿ 2、块级元素不能放在里面包括p本身 —— 错 —— 错 ﻿ 3、有几个特殊的块级元素只能包含内联元素，不能再包含块级元素，这几个特殊的标签是 h1、h2、h3、h4、h5、h6、p、dt ﻿ 4、a 标签可以嵌套块级元素 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:18:28 "},"HTML属性.html":{"url":"HTML属性.html","title":"HTML 属性","keywords":"","body":"HTML 属性 属性 【class】规定元素的一个或多个类注意: 类不能以数字开头 class = \"classA classB\" // 多个类的写法 ﻿ 【id】规定元素的唯一标识注意：若浏览器中出现多个id名的情况，CSS样式对所以该id名的元素都生效，但javascript脚本仅对第一个出现该id名的元素生效 【dir】文字的方向值：ltr/rtl/auto 【lang】HTML的lang属性可用于标记网页或部分网页的语言。也就是说lang这个属性不仅仅可以用在html标签上 en:英文 zh:中文 zh-CN：简体中文 ﻿ ﻿ You'd say that in Chinese as 文献情报中心. ﻿ 有什么作用？简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。比如可以根据根据lang属性来设定不同语言的css样式，或者字体 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别等... 【style】设置行间样式 ﻿ 【tabindex】规定元素的tab键次序（1开始） cc bb aa ﻿ 【title】规定关于元素的额外信息，鼠标移到元素上时显示一段提示文本 百度 ﻿ HTML5新增的属性 【contenteditable】作用：指定是否可以在浏览器里编辑内容值：true/false注意：设置document.designMode ='on'时，页面的任意位置都可以编辑；使用contenteditable ='true'则只对具体元素和其包含的元素起作用移动端：移动端ios5以及android3之后才支持该属性 【data-*】作用：用于存储页面或应用程序的私有定制数据注意：属性名不应包含任何大写字母，且在前缀\"data-\"之后必须有至少一个字符；属性值可以是任意字符串使用：可以在所有浏览器中使用getAttribute方法来获取data-属性的值，也可以使用javascript中dataset属性访问data-属性的值，不过IE10-浏览器不支持dataset 【draggable】IE8- 不支持作用：用户是否可以拖动元素值：true/false/auto注意：链接和图像默认是可拖动的 【hidden】(IE7-不支持)作用：显示或隐藏该元素(与display:none的作用一样)值：hidden=\"\" || hidden= \"hidden\" 【spellcheck】(IE9-不支持)作用：规定是否对元素进行拼写和语法检查,对拼写错误的单词会在其下方出现红线范围：可编辑区域（表单或contenteditable元素）值：true/false注意：移动端支持不好 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:39:09 "},"HTML常用标签（a，img）.html":{"url":"HTML常用标签（a，img）.html","title":"HTML 常用标签（a，img）","keywords":"","body":"a元素 元素 (或HTML锚元素, Anchor Element)通常用来表示一个锚点/链接。但严格来说，元素不是一个链接，而是超文本锚点，可以链接到一个新文件、用id属性指向任何元素。如果没有元素没有href属性的话，可以作为原本链接位置的占位符，常用于home链接 [注意]任何文档流内容都可以被嵌套，只要不是交互内容类别(如按钮、链接等) 【href】href属性表示地址，共包括以下3种： 链接地址:百度 下载地址:下载测试 锚点: href:#id名 目录 内容 ﻿ href:页面地址#id名 足球比赛规则 ﻿ 手机号码： 在移动端，使用15012345678可以唤出手机拨号盘 href属性一定不要留空，若暂时不需要写地址，则写#或javascript:;。若href留空，会刷新页面 【href与src的区别】href(hypertext reference)指超文本引用，表示当前页面引用了别处的内容src(source)表示来源地址，表示把别处的内容引入到当前页面，相当于资源占位所以、、等应该使用src，而和应该使用href ﻿ 【target】target属性表示链接打开方式1、_self 当前窗口（默认）2、_blank 新窗口3、_parent 父框架集4、_top 整个窗口5、_framename 指定框架 【download】download属性用来设置下载文件的名称(firefox/chrome/opera支持) ﻿ test ﻿ 【注意事项】1、标签的文本颜色只能自身进行设置，从父级继承不到2、标签的下划线颜色跟随文本颜色进行变化3、标签不可嵌套标签 img 表示image图像，从技术上讲，标签并不会在网页中插入图像，而是从网页上链接图像。 标签创建的是被引用图像的占位空间。 【必须属性】1、src:地址2、alt:图像替代文本，供探索引擎抓取使用 【可选属性】1、height:图像高度2、width:图像宽度3、ismap:为图像定义为服务器端图像映射4、longdesc:与alt属性类似，提供多于1024字符的长文本描述5、usemap:为图像定义客户端图像映射 usemap = \"#\\元素的name或id属性\"6、srcset:指定图片的地址和对应的图片质量。属性格式：图片地址 宽度描述w 多个资源之间用逗号分隔。对于srcset里面出现了一个w单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用，当然，浏览器会自动选择一个最小的可用图片。但是，会发现随着浏览器窗口宽度变大，图片也在不断变大 [注意]浏览器会自动匹配最佳显示的图片，如果大图既然缓存了就用大图了，再缩小也不会变成小图了 7、sizes:用来设置图片的尺寸零界点，主要跟响应式布局打交道。属性格式：媒体查询 宽度描述(支持px)，多条规则用逗号分隔 [注意]如果加上sizes属性，会发现，随着浏览器宽度变大，图片一直保持其初始尺寸。所以，应该sizes和srcset两个属性配合使用 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:50:45 "},"HTML表格.html":{"url":"HTML表格.html","title":"HTML 表格","keywords":"","body":"标准表格 Monthly savings Header 1 Header 2 row 1, cell 1 row 1, cell 2 row 1, cell 2 row 2, cell 1 row 2, cell 2 标签解释 定义表格 定义表格的表头 定义表格的行 定义表格单元 定义表格标题 定义表格列的组 定义用于表格列的属性 定义表格的页眉 定义表格的主体 定义表格的页脚 属性解释 rowspan = \"n\" 纵向合并单元格colspan = \"n\" 横向合并单元格 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:52:20 "},"HTMLiframe使用postMessage方法进行跨文档消息传递.html":{"url":"HTMLiframe使用postMessage方法进行跨文档消息传递.html","title":"HTML iframe 使用postMessage方法进行跨文档消息传递","keywords":"","body":"什么是iframe HTML内联框架元素 表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。 【src】嵌套页面的URL地址。使用遵守同源策略的 'about:blank' 来嵌套空白页。 同源策略 同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 ﻿ 协议相同: http https ftp 指的是协议 域名相同: www.baidu.com www.taobao.com 指的是域名 端口相同: 默认是80端口 8800 8899这个指的是端口 https://www.baidu.com:80（80是默认的可以省略） 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） ﻿ 跨文档消息传递 跨文档消息传送(cross-document messaging)，有时候简称为 XDM，指的是在来自不同域的页面间 传递消息。例如，www.wrox.com 域中的页面与位于一个内嵌框架中的 p2p.wrox.com 域中的页面通信。 在 XDM 机制出现之前，要稳妥地实现这种通信需要花很多工夫。XDM 把这种机制规范化，让我们能 既稳妥又简单地实现跨文档通信。 XDM 的核心是 postMessage()方法。在 HTML5 规范中，除了 XDM 部分之外的其他部分也会提 到这个方法名，但都是为了同一个目的:向另一个地方传递数据。对于 XDM 而言，“另一个地方”指的 是包含在当前页面中的元素，或者由当前页面弹出的窗口。 postMessage postMessage()方法接收两个参数:一条消息和一个表示消息接收方来自哪个域的字符串。第二 个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方 var iframeWindow = document.getElementById(\"myframe\").contentWindow; iframeWindow.postMessage(\"A secret\", \"http://www.wrox.com\");// 第一个参数如果需要传入对象请JSON.stringify() 最后一行代码尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于\"http:// www.wrox.com\"域。如果来源匹配，消息会传递到内嵌框架中;否则，postMessage()什么也不做。﻿ 如果传给 postMessage()的第二个参 数是\"*\"，则表示可以把消息发送给来自任何域的文档，但我们不推荐这样做。﻿ 接收到 XDM 消息时，会触发 window 对象的 message 事件。这个事件是以异步形式触发的，因此 从发送消息到接收消息(触发接收窗口的 message 事件)可能要经过一段时间的延迟。触发 message 事件后，传递给 onmessage 处理程序的事件对象包含以下三方面的重要信息 data:作为 postMessage()第一个参数传入的字符串数据。 origin:发送消息的文档所在的域，例如\"http://www.wrox.com\"。 source:发送消息的文档的 window 对象的代理。这个代理对象主要用于在发送上一条消息的 窗口中调用 postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是 window。 window.onmessage = function(event){ //确保发送消息的域是已知的域 if (event.origin == \"http://www.wrox.com\"){ //处理接收到的数据 processMessage(event.data); //可选:向来源窗口发送回执 event.source.postMessage(\"Received!\", \"http://p2p.wrox.com\"); } }; [注意]event.source 大多数情况下只是 window 对象的代理，并非实际的 window 对 象。换句话说，不能通过这个代理对象访问 window 对象的其他任何信息。记住，只通过这个代理调用 postMessage()就好，这个方法永远存在，永远可以调用。 ﻿ 兼容 支持 XDM 的浏览器有 IE8+、Firefox 3.5+、Safari 4+、Opera、Chrome、iOS 版 Safari 及 Android 版 WebKit。XDM 已经作为一个规范独立出来，现在它的名字叫 Web Messaging，官方页面是 http://dev.w3.org/html5/postmsg/。 小结 通过本文我学习了什么是iframe，以及iframe如何和父窗口进行数据通信 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:53:50 "},"HTML表单form元素介绍，input元素的常用type类型，input元素的常用属性.html":{"url":"HTML表单form元素介绍，input元素的常用type类型，input元素的常用属性.html","title":"HTML 表单(form元素介绍，input元素的常用type类型，input元素的常用属性)","keywords":"","body":"前言 表单是网页与用户的交互工具，由一个元素作为容器构成，封装其他任何数量的表单控件，还有其他任何元素里可用的标签 表单能够包含、、、、、等表单控件元素 [注意]表单里嵌套表单是不允许的 ﻿ form元素 form元素有accept-charset、action、autocomplete、enctype、method、name、novalidate、target共8个属性，其中action和name属性为必需项 var oForm = document.forms.test; console.log(oForm.method);//get 【字符集】accept-charset 属性是一个空格分隔的字符集列表，规定了服务器处理表单数据所接受的字符集。accept-charset 属性允许指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。该属性的值是用引号包含字符集名称列表。 【提交地址】action属性规定提交表单时，向何处发送表单数据；如果忽略这个属性，表单会重定向到表单所在的URL。这个值可以被 或者 元素中的 formaction属性重载(覆盖) 【数据编码】enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。大多数情况下该属性不需要设置。这个值可以被 或者 元素中的 formenctype属性重载(覆盖)。当 method属性值为 post时， enctype是提交form给服务器的内容的 MIME 类型 。可能的取值有: application/x-www-form-urlencoded 　　在发送前编码所有字符（默认） multipart/form-data 　　　　　　　　 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 text/plain 　　　　　　　　　　　　 空格转换为 \"+\" 加号，但不对特殊字符编码 【数据发送】表单可以用两种方式(method)发送数据：GET和POST，默认为GET方法。这个值可以被 或者 元素中的 formmethod属性重载(覆盖) 【POST方法】　　如果采用POST方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与action属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器　　在服务器端，一旦POST样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数 【GET方法】如果采用GET方法，浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的action URL之后。这两者之间用问号进行分隔。 【自动完成】autocomplete是HTML5新增的一个属性，规定表单是否应该启用自动完成功能。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项 [注意]IE浏览器不支持该属性，只有元素拥有name属性，该属性才有效 //该属性默认为on，当设置为off时，规定禁用自动完成功能 ﻿ input元素的常用type类型 ﻿ 传统输入控件：button：定义可点击按钮checkbox：复选框file：文件上传hidden：隐藏的输入字段（常常用于附带的一些内容传递给后台，但是又不想让用户看见的）image：定义图像形式的提交按钮password：密码输入radio：单选按钮reset：重置按钮submit：表单提交text：单行的文字输入 checkbox 单选 H5新增控件： color 　　　　　　 定义调色板 tel 　　　　 　　 定义包含电话号码的输入域 email 　　　 　　定义包含email地址的输入域 url 　　　　 　　 定义包含URL地址的输入域 search 　　　　　 定义搜索域 number 　　 　　 定义包含数值的输入域 range 　　 　　 定义包含一定范围内数字值的输入域 date 　　　　　 定义选取日、月、年的输入域 month 　　 　　 定义选取月、年的输入域 week 　　　　　 定义选取周、年的输入域 time 　　 　　 定义选取月、年的输入域 datetime 　　　 定义选取时间、日 月、年的输入域(UTC时间) datatime-local 　 定义选取时间、日 月、年的输入域(本地时间) H5新增的控件在使用前可以去can i ues中查看下兼容问题 ﻿ ﻿ input元素的常用属性 传统属性：accept、alt、checked、disabled、maxlength、name、readonly、size、src、type、value﻿ H5新增属性：autocomplete、autofocus、form、formaction、formenctype、formmethod、formnovalidate、formtarget、height、list、max、min、multiple、novalidate、pattern、placeholder、required、step、width 【name】name属性用于规定input元素的名称，用于对提交到服务器后的表单数据进行标识，或者在客户端通过javascript引用表单数据 [注意]只有设置了name属性的表单元素才能在提交表单时传递它们的值 【type】type属性用来规定input元素的类型 【accept】accept属性用来规定能够通过文件上传进行提交的文件类型。理论上可以用来限制上传文件类型，然而它只是建设性的，并很可能被忽略，它接受逗号分隔的MIME类型 [注意]该属性只能与type=\"file\"配合使用 ﻿ 【alt】alt属性为图像输入规定替代文本，功能类似于image元素的alt属性，为用户由于某些原因无法查看图像时提供备选信息 [注意]alt属性只能与type=\"image\"的input元素配合使用 【checked】checked属性规定在页面加载时应该被预先选定的input元素，也可以在页面加载后，通过javascript进行设置 [注意]checked属性只能与type=\"radio\"或type=\"checkbox\"的input元素配合使用 【disabled】disabled属性规定应该禁用input元素。被禁用的字段是不能修改的，也不可以使用tab按键切换到该字段，但可以选中或拷贝其文本 [注意1]disabled属性无法与type=\"hidden\"的input元素一起使用[注意2]对于IE7-浏览器必须设置为disabled=\"disabled\"，而不可以直接设置disabled，否则使用javascript控制时将失效 【readonly】readonly属性规定输入字段为只读。只读字段是不能修改的，但用户仍然可以使用tab按键切换到该字段，还可以选中或拷贝其文本readonly属性可与type=\"text\"或\"password\"的input元素配合使用 [注意]IE7-浏览器不支持使用javascript控制readonly属性 【maxlength】maxlength属性规定输入字段的最大长度，以字符个数计 [注意]该属性只能与type=\"text\"或type=\"password\"的input元素配合使用 ﻿ 【size】size属性对于type=\"text\"或\"password\"的input元素是可见的字符数；而对于其他类型，是以像素为单位的输入字段宽度 [注意]由于size属性是一个可视化的设计属性，推荐使用CSS来代替它 ﻿ ﻿ 【src】src属性作为提交按钮显示的图像的URL [注意]src属性只能且必须与type=\"image\"的input元素配合使用 ﻿ 【value】value属性为input元素设定值。对于不同的输入类型，value属性的用法也不同： type=\"button\"、\"reset\"、\"submit\"用于定义按钮上的显示的文本 type=\"text\"、\"password\"、\"hidden\"用于定义输入字段的初始值 type=\"checkbox\"、\"radio\"、\"image\"用于定义与输入相关联的值 [注意1]type=\"checkbox\"或\"radio\"必须设置value属性 [注意2]value属性无法与type=\"file\"的input元素一起使用 ﻿ ﻿ H5新增属性 【autocomplete】autocomplete属性可以在个别元素或整个表单上开启或关闭浏览器的自动完成功能。当用户在字段开始键入时，浏览器基于之前键入过的值，显示出在字段中填写的选项 autocomplete属性适用form元素以及以下类型的input元素：text、search、url、telephone、email、password、date pickers、range、color [注意]IE浏览器不支持该属性，只有元素拥有name属性，该属性才有效 【autofocus】autofocus属性规定在页面加载时，域自动地获得焦点autofous属性适用于button、input、keygen、select和textarea元素 ﻿ 【novalidate】novalidate属性规定在提交表单时不验证form或input域novalidate属性适用于form元素以及以下类型的input元素：text、search、url、telephone、email、password、date pickers、range、color [注意]IE9-浏览器不支持 【height】【width】用于规定image类型的input标签的图像高度和宽度(不常用) 【list】大多数输入类型包含一个属性list，它和一个新元素datalist结合使用，这个元素定义当在表单控件输入数据时可用的一个选项列表。datalist元素自身不会在页面显示，而是为其他元素的list属性提供数据 list属性适用于form元素以及以下类型的input元素：text、search、url、telephone、email、password、date pickers、range、color [注意]IE9-浏览器及safari浏览器不支持 【min】【max】规定输入域所允许的最小值，最大值 【step】step属性为输入域规定合法的数字间隔 min、max、step属性适用于以下类型的input元素:date pickers、number、range ﻿ 【multiple】multiple属性规定按住ctrl按键，输入字段可以选择多个值该属性适用于type=\"email\"和\"file\"的input元素 [注意]该属性IE9-浏览器不支持 ﻿ 打开文件多选 关闭文件多选 btn1.onclick = function(){ test.setAttribute('multiple',''); }; btn2.onclick = function(){ test.removeAttribute('multiple'); }; 【pattern】pattern属性规定用于验证input域的模式。模型pattern是正则表达式pattern属性适用于以下类型的input元素：text、search、url、tel、email、password [注意]IE9-浏览器及safari浏览器不支持 ﻿ 【placeholder】placeholder属性提供占位符文字，描述输入域所期待的值。占位符会在输入域为空时显示出现，在输入域获得焦点时消失 placeholder属性适用于以下类型的input元素:text、search、url、tel、email、password [注意]IE9-浏览器不支持 要修改placeholder的颜色需要使用::placeholder ::placeholder{color:green;} 【required】required属性规定必须在提交之前填写输入域(不能为空) required属性适用于以下类型的input元素：text、search、url、telephone、email、password、date pickers、number、checkbox、radio、file [注意]IE9-浏览器及safari浏览器不支持 ﻿ 【form】form属性规定输入域所属的一个或多个表单，form属性必须和所属表单的id form属性适用于所有input标签的类型，若需要引用一个以上的表单时，用空格分隔 [注意]IE浏览器不支持该属性，只有元素拥有name属性，该属性才有效 ﻿ 表单重写属性 表单重写属性允许重写form元素的某些属性设定。其中，formnovalidate适用于button或input元素，而其他属性适用于submit或reset的button或input元素 【formaction】重写表单的action属性 ﻿ First name: Last name: ﻿ 【formenctype】重写表单的enctype属性 ﻿ First name: ﻿ 【formmethod】重写表单的method属性 First name: Last name: ﻿ 【formnovalidate】重写表单的novalidate属性 ﻿ E-mail: ﻿ ﻿ 【formtarget】重写表单的target属性 ﻿ First name: Last name: 小结 通过本文我们学习了form元素及其常用属性，input常用的type类型和相关属性。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:02:52 "},"HTMLmeta标签,base标签.html":{"url":"HTMLmeta标签,base标签.html","title":"HTML meta标签,base标签","keywords":"","body":"HTML meta元素 标签(meta-information)用于提供页面有关的元数据，除了提供文档字符集、使用语言、作者等基本信息外，还涉及对关键词和网页等级的设定。通过设置不同的属性，元数据可以分为以下几种: // charset声明声明当前文档所使用的字符编码，但该声明可以被任何一个元素的lang特性的值覆盖。文档的编码一定要与文件本身的编码保持一致，否则会出现乱码，推荐使用UTF-8编码 // 关键词 // 描述 // 作者 // 版权 // 视口设置 // IE浏览器渲染 如果安装了GCF(Google Chrome Frame谷歌内嵌浏览器框架GCF)，则使用GCF来渲染页面，如果没有安装，则使用最高版本的IE内核进行渲染 // 如果是双核浏览器，则使用webkit内核渲染 // 让网页多少秒刷新 // 跳转到其他网页 // 可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式 // 用于设定禁止浏览器从本地机的缓存中调阅页面内容，用户无法脱机浏览 // 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用 【base标签】 // 用于指定文档里所有相对URL地址的基础URL，为页面上所有链接规定默认地址和默认打开方式。文档中的基础URL可以使用document.baseURI进行查询 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:03:23 "},"HTML条件注释规范.html":{"url":"HTML条件注释规范.html","title":"HTML 条件注释规范","keywords":"","body":"HTML 条件注释(hack常用) IE条件注释是微软从IE5开始就提供的一种非标准逻辑语句，作用是可以灵活的为不同IE版本浏览器导入不同html元素。很显然这种方法的最大好处就在于属于微软官方给出的兼容解决办法而且还能通过W3C的效验 【识别IE】 只在IE中会显示 【识别IE具体版本】 6 [if IE 6] 7 [if IE 7] 8 [if IE 8] 9 [if IE 9] // 只在IE7中显示 【IE范围】 gt 大于(greater than) gte 　大于等于(greater than or equal) lt 小于(less than) lte 小于等于(less than or equal) // 小于等于IE7识别 识别非IE 实际上识别的是IE10+浏览器和其他非IE浏览器 实际应用中我们常常用来判断IE版本来引入相应的JS进行hack，或者通过不同IE版本引入不同的jquery版本 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:32:18 "},"【重难】深入理解HTML表格.html":{"url":"【重难】深入理解HTML表格.html","title":"[重难] 深入理解HTML表格","keywords":"","body":"前言 在CSS出现之前，table元素常常用来布局。这种做法在HTML4之后不再推荐使用。而现在有些矫枉过正，使用table展示数据都可能会被说不规范。本文将详细介绍HTML表格table table 【默认样式】 //IE7-浏览器不支持border-spacing table{ 　　border-collapse: separate; 　　border-spacing: 2px; 　　border: 1px solid gray; } 【属性】1、border(在html5中，border只能为\"1\"或\" \")(html5已废弃) border=\"0\"//没有边框 border=\"8\"//8像素宽的边框 2、cellpadding(px/%)(html5已废弃)规定单元边界与单元内容之间的间距 3、cellspacing(px/%)(html5已废弃)规定单元格之间的间距 4、summary(html5已废弃)表格内容的摘要 5、width(html5已废弃)表格宽度 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 6、frame(IE7-浏览器不能正常显示)(html5已废弃) void 不显示外侧边框。 above 显示上部的外侧边框。 below 显示下部的外侧边框。 hsides 显示上部和下部的外侧边框。 vsides 显示左边和右边的外侧边框。 lhs 显示左边的外侧边框。 rhs 显示右边的外侧边框。 box 在所有四个边上显示外侧边框。 border 在所有四个边上显示外侧边框。 7、rules(IE7-浏览器不能正常显示)(html5已废弃) none 没有线条。 groups 位于行组和列组之间的线条。 rows 位于行之间的线条。 cols 位于列之间的线条。 all 位于行和列之间的线条。 【样式】1、border-spacing 可替代HTML属性cellspaing(IE7-不支持)[注意]只有当border-collapse值为separate时，该样式才有效 border-spacing: x y //x:水平间距 y:垂直间距。若只有一个值，则水平间距和垂直间距相等。注意，不可为负值。 2、empty-cells(IE7-不支持) empty-cells: hide 不在空单元格周围绘制边框和背景，类似于hidden效果 empty-cells: show(默认) 在空单元格周围绘制边框和背景 3、CSS实际上有两种截然不同的边框模型。按布局术语来说，如果单元格相互之间是分隔的，是分隔边框模型在起作用；另一种是合并边框模型，单元格边框会相互合并。 border-collapse:separate; [注意]在分隔边框模型中，不能为行、行组、列和列组设置边框。 border-collapse:collapse; 　　在合并边框模型中，表格无法设置内边距padding，且单元格边框之间也没有间距。单元格之间的边框会在单元格间的假想表格线上居中，且表格宽度只包含表格边框的一半 【边框合并的规则】　　a、某个合并边框的border-style为hidden，它会优先于所有其他合并边框。这个位置上的所有边框都隐藏　　b、某个合并边框的border-style为none，它的优先级最低　　c、宽边框优先于窄边框　　d、若宽度相同，double\\solid\\dashed\\dotted\\ridge\\outset\\groove\\inset，优先级逐渐降低　　e、若样式也相同，cell\\row\\row group\\column\\column group\\table，优先级逐渐降级 4、table-layout table-layout:auto//自动宽度布局 【自动布局的步骤】 　　a、对于一列中的单元格，计算最小和最大单元格宽度 　　b、对于各一列，计算最小和最大列宽 　　c、若单元格跨列，最小列宽之和要等于跨列单元格最小单元格宽度 table-layout:fixed//固定宽度布局 [注意]对于表单元格的长文本来说，使用word-wrap或word-break来强制换行，使用text-overflow实现文本溢出控制都需要设置table-layout:fixed 【固定布局的步骤】 　　a、width属性值不是auto的所有列元素会根据width值设置该列的宽度 　　b、如果一个列的宽度为auto，则根据该单元格设置此列宽度，如果跨多列，则宽度平均分配 　　c、如果列宽度仍为auto，则自动确定其大小，使其宽度尽可能相等 　　[注意]使用固定宽度布局，浏览器可以更快地计算出表格的布局 5、vertical-align vertical-align: top;//顶端对齐 vertical-align: bottom;//底端对齐 vertical-align: middle;//中间对齐 vertical-align: baseline(默认);//基线对齐 [注意]vertical-align:sub\\super\\text-top\\text-bottom应用到表格单元格时会被忽略 行 【】 行 table row 表头 table head 表格数据 table data 【默认样式】 th{ padding: 1px; text-align: center; font-weight: bold; } td{ padding: 1px; } 【属性】1、colspan　　规定单元格可纵跨的列数 2、rowspan　　规定单元格可横跨的行数 　　[注意]关于行的表格元素生成矩形框，这些框有内容、内边距和边框，但是没有外边距margin。表头呈现为居中的粗体文本 Month Savings Savings for holiday! January $100 $50 February $80 列 【】 -> column 列　　为表格中一个或多个列定义属性值 -> column group 列组　　对表格中的列进行组合，以便对其进行格式化 【属性】　　span　　规定col元素应该横跨的列数 【样式】 　　1、visibility:collapse　　该列或列组的所有单元格不显示(设置为其他值则无效) 　　2、border　　只有当border-collapse:collapse时，才能设置border 　　3、background　　只有当单元格及其行有透明背景时，列或列组的背景才可见 　　4、width　　定义列或列组的最小宽度 数字 中文 英文 1 一 a 2 二 b 其他表格元素 【】 表格页眉 表格主体 表格页脚 　　[注意]它们的出现次序是：thead、tfoot、tbody，这样浏览器就可以在收到所有数据前呈现页脚 【表格标题】 【默认样式】 caption{ text-align: center; } 【样式】 caption-side: top(默认) caption-side: bottom [注意]标签必须紧随标签之后，且只能对每个表格定义一个标题 　 北京天气 地区 天气 北京 都雾霾 城八区 雾霾 郊区 雾霾 display table{display: table;} thead{display: table-header-group;} tbody{display: table-row-group;} tfoot{display: table-footer-group;} tr{display: table-row;} td,th{display: table-cell;} col{display: table-column;} colgroup{display: table-column-group;} caption{display: table-caption;} [注意]IE7-浏览器不支持为HTML元素设置与表格有关的display值 匿名表格对象　　CSS定义了一种机制，将遗漏的组件作为匿名对象插入。详细插入规则如下： 　　1、如果table-cell元素的父元素不是table-row元素，则插入匿名table-row对象 　　2、如果table-row元素的父元素不是table、inline-table或table-row-group元素，则插入匿名table元素 　　3、如果table-column元素父元素不是table、inline-table或table-row-group元素，则插入匿名table元素 　　4、如果table-row-group、table-header-group、table-footer-group、table-column-group或table-caption的父元素不是table元素，则插入匿名table元素 　　5、如果table元素或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption，则插入匿名table-row元素 　　6、如果table-row-group、table-header-group、table-footer-group元素的子元素不是table-row元素，则插入匿名table-row元素 　　7、如果table-row元素的子元素不是table-cell元素，则插入匿名tabel-cell元素 插入一段不合符规范的代码 122 233 看下浏览器的HTML效果： 浏览器自动补上了tr 表格层 　　CSS定义了6个不同的层，对应表各个方面的样式都在其各自的层上绘制。默认地，所有元素背景都是透明的，如果单元格、行、列等没有自己的背景，则table元素的背景将透明这些内部元素可见。 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 边距设置 【】　　若处于分隔边框模型，margin和padding都可设置　　若处于合并边框模型，只可设置margin 【】　　margin和padding都不可设置 【】　　不可设置margin，但可以设置padding 【】　　margin和padding都可设置 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:07:33 "},"JavaScript中attribute和property的区别以及最佳实践.html":{"url":"JavaScript中attribute和property的区别以及最佳实践.html","title":"[重难] JavaScript中attribute和property的区别以及最佳实践","keywords":"","body":"前言 使用JavaScript操作DOM元素时往往涉及到两个概念：attribute 和 property。 document.getElementById('test').getAttribute('id') 、 $('#test').attr('id') 、 document.getElementById('test').id 和 $('#test').prop('id') 都能返回正确的id：\"test\"。这篇文章主要介绍一下 property 和 attribute 的区别以及如何使用。 Attribute 1、Attribute由HTML来定义，并不存在于DOM中，即：只要是HTML标签内定义的都是attribute。 document.getElementById('test').attributes; // 返回：[custom-attr=\"hello\", class=\"button\", id=\"test\"] 2、Attribute是String类型。对于上面的div，document.getElementById('test').getAttribute('custom-attr') 或 $('#test').attr('custom-attr') 都会返回string: \"1\"。 Property 1、Property属于DOM，DOM的本质就是JavaScript中的一个object。我们可以像操作普通object一样读取、设置property，property可以是任意类型。 document.getElementById('test').foo = 1; // 设置property：foo为number: 1 document.getElementById('test').foo; // 读取property，返回number：1 $('#test').prop('foo'); // jQuery读取property，返回number：1 $('#test').prop('foo', { age: 23, name: 'John' }); // jQuery设置property：foo为一个object document.getElementById('test').foo.age; // 返回number：23 document.getElementById('test').foo.name; // 返回string：\"John\" 2、非自定义attribute，如id、class、titile等，都会有对应的property映射。 document.getElementById('test').id; // 返回string：\"test\" document.getElementById('test').className; // 返回string：\"button\" document.getElementById('test').foo; // 返回undefined，因为foo是自定义attribute 注：由于 class 为JavaScript的保留关键字，所以通过property操作class时应使用 className。 3、非自定义的property或attribute的变化多数是联动的。 var div = document.getElementById('test'); div.className = 'red-input'; div.getAttribute('class'); // 返回string：\"red-input\" div.setAttribute('class','green-input'); div.className; // 返回string：\"green-input\" 4、带有默认值的attribute不随property变化而变化。 var input = document.getElementById('search'); input.value = 'foo2'; input.getAttribute('value'); // 返回string：\"foo\" 最佳实践 使用JavaScript操作property更为方便、快捷，并且property支持各种不同的类型，尤其是对于布尔类型的attribute的自动转换，如：checked、disabled、selected等。 推荐用法 // 获取id document.getElementById('test').id; // 更改class document.getElementById('test').className = 'red'; // 获取、设置状态 document.getElementById('test').checked; document.getElementById('test').checked = true; $('#test').prop('checked'); $('#test').prop('checked', true); 不推荐的用法 // 获取id document.getElementById('test').getAttribute('id'); // 更改class document.getElementById('test').setAttribute('class', 'red'); Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:54:04 "},"【重难】table单元格中文字过长如何进行省略table-layout.html":{"url":"【重难】table单元格中文字过长如何进行省略table-layout.html","title":"[重难] table单元格中文字过长如何进行省略 table-layout","keywords":"","body":"前言 最近在项目中碰到了，需要在表格样式中对td立面进行过长省略处理，但是表格又是100%自适应的，td又是百分比的宽度，一时显得无从下手了，这篇文章我们主要讲解下如何处理这类问题 ﻿ 遇到的场景 这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字 row cell row cell row cell row cell 是不是非常难看，在我们一般的布局中都会给td一个半分比，从而不让它这么肆无忌惮。 这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字 row cell row cell row cell row cell 再来看下效果： 果然是如我们的预期的百分比进行分割的。那么此时我们希望第一个单元格进行文字省略处理。我们加上代码试试。 td{ overflow: hidden; // 按照宽度隐藏 text-overflow:ellipsis; // 省略 white-space: nowrap;// 不换行 } 从效果上面看：文字没有换行有效果，然而宽度被撑开的面目全非，这绝对不是我们想要的结果。 接下来就要介绍我们的一个样式了table-layout ﻿ table-layout /* Keyword values */ table-layout: auto; table-layout: fixed; ﻿ /* Global values */ table-layout: inherit; table-layout: initial; table-layout: unset; 【auto】大多数浏览器采用自动表格布局算法对表格布局。表格及单元格的宽度取决于其包含的内容。 【fixed】表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽。 使用 “fixed” 布局方式时，整个表格可以在其首行被下载后就被解析和渲染。这样对于 “automatic” 自动布局方式来说可以加速渲染，但是其后的单元格内容并不会自适应当前列宽。任何一个包含溢出内容的单元格可以使用 overflow 属性控制是否允许内容溢出。﻿ 我们把相应的样式添加上再看看效果： table{ table-layout: fixed; } td{ overflow: hidden; text-overflow:ellipsis; white-space: nowrap; } ﻿ 分析：我们发现左边的单元格和右边的单元格进行对比依然是 40% 60% 的比例宽度，但是它的省略功能也实现了。 [注意]td上不添加宽度的话，则平均分配宽度 总宽度/列的数量 小结 本文主要讲解了table-layout的两种方式：auto以及fixed ﻿ Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:10:18 "},"css文件引入的三种方式.html":{"url":"css文件引入的三种方式.html","title":"css文件引入的三种方式","keywords":"","body":"前言 1995年，W3C发布了CSS草案 1996年，W3C正式推出CSS1 1998年，推出CSS2 2001年从CSS3开始，CSS这门语言分割成多个独立的模块，每个模块独立分级，且只包含一小部分功能； 2011年开始设计CSS4 本文将主要介绍引入CSS样式的方式，包括外部样式表、内部样式表和行间样式三种方式 ﻿ [注意]CSS语法非常简单，但容易忽略的一点是不能省略分号(最后一个样式除外) ﻿ 外部样式表 ﻿ 内部样式表 body{ background-color: red; } ﻿ [注意]文档中可出现多个style标签，且样式规则与层叠样式规则一致 ﻿ 【使用@import指令】 @import指令用于指示Web浏览器加载一个外部样式表，并在表现HTML文档时使用其样式。唯一的区别在于命令的具体语法和位置。 @import指令常用于样式表需要使用另一个样式表中的样式的情况。 @import url(sheet2.css); body{ background-color: red; } [注意]@import必须出现在style元素中，且要放在其他CSS规则之前，否则将根本不起作用。 ﻿ 行间样式 如果只是想为单个元素指定一些样式，可以使用HTML的style属性来设置一个行间样式。 [注意]行间样式若存在多个style属性，只能识别第一个 ﻿ ﻿ [注意]标签和标签可以写在标签里面 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:56:58 "},"css选择器常规选择器，伪类选择器，伪元素选择器，根元素选择器.html":{"url":"css选择器常规选择器，伪类选择器，伪元素选择器，根元素选择器.html","title":"css选择器(常规选择器，伪类选择器，伪元素选择器，根元素选择器)","keywords":"","body":"前言 CSS的一个核心特性是能向文档中的一组元素类型应用某些规则，本文将详细介绍CSS选择器 ﻿ 选择器 ﻿ 【通配选择器】 星号*代表通配选择器，可以与任何元素匹配 *{color: red;} ﻿ 【元素选择器】 文档的元素是最基本的选择器 html{color: black;} p{color: gray;} h2{color: silver;} ﻿ 【类选择器】 类选择器用于选择一类元素 .div{color: red;} // 单个类的选择 .div1.div2{color: red;} // 多个类的选择，既包含div1类也包含div2类的元素将被选择 p.div{color: red;} // p元素且包含div类的元素将被选择 ﻿ 【ID选择器】 ID选择器用于选择一个元素 #test{color: red;} div#test{color: red;} 结合元素选择ID [注意]在实际中，浏览器并不会检查ID的唯一性，设置多个ID，可以为这些具有相同ID的元素应用相同样式，但在编写DOM脚本时只能识别该id的第一个元素。 ﻿ 【属性选择器】 属性选择器根据元素的属性及属性值来选择元素(IE6-不支持) // 简单属性选择器 h1[class]{color: red;} img[alt]{color: red;} a[href][title]{color: red;} #div[class]{color: red;} .box[id]{color: red;} [class]{color: red;} ﻿ // 具体属性选择器 a[href=\"http://www.baidu.com\"][title=\"baidu\"] {color: red;} [class=\"test box\"]{color: red;} // class里面的值以及顺序必须完全相同，并且不可多空格或者少空格 [id=\"tox\"]{color: red;} // ID选择器和指定id属性的属性选择器并不是一回事，主要在于优先级不同 ﻿ // 部分属性选择器 [class ~=\"b\"] 选择class属性值在用空格分隔的词列表中包含词语\"b\"的所有元素，例如：class=\"ab\"不满足[class ~=\"b\"]，而class=\"a b\"或class=\"b\"满足 [class |=\"b\"] 选择class属性值等于b或以b-开头的所有元素，例如：class=\"ab\"或class=\"ab-\"不满足[class |=\"a\"]，而class=\"a\"或class=\"a-\"满足 [class ^=\"b\"] 选择class属性值以\"b\"开头的所有元素 [class $=\"b\"] 选择class属性值以\"b\"结尾的所有元素 [class *=\"b\"] 选择class属性值包含\"b\"的所有元素 ﻿ 【分组选择器】 将要分组的选择器放在规则左边，并用逗号隔开 h1,p{color: red;} // 选择了h1 和 p 元素 ﻿ 【后代选择器】 ul li{color: red;} // ul 下面的所有 li元素 将被选择 div p, ul li{color: red;} // div元素 下面的所有p元素将被选择 并且 ul下面的所有 li元素将被选择 ﻿ 子元素选择器(IE6-不支持) ul > li{color: red;} // ul下面的子元素 li将被选择 ， 不选中孙子元素 ﻿ 【兄弟元素选择器】 // 相邻兄弟选择器(IE6-不支持) h1 + p{color: red;} // 选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素 [注意]两个元素之间的文本内容不会影响相邻兄弟结合符起作用 ﻿ 伪类选择器 伪类顺序：link-visited-focus-hover-active ﻿ 【静态伪类(只应用于超链接)】 [注意]visited伪类只能设置字体颜色、边框颜色、outline颜色的样式 ﻿ :link 未访问 :visited 已访问 a:link{color: red;} a:visited{color: green;} 【动态伪类(可应用于任何元素)】 :focus 拥有焦点(IE7-不支持) :hover 鼠标停留(IE6-不支持给以外的其他元素设置伪类) :active 正被点击(IE7-不支持给以外的其他元素设置伪类) ﻿ 【目标伪类:target(IE8-不支持)】 匹配锚点对应的目标元素 :target{color: red;} #test :target{color: red;}//id为test的目标元素 ﻿ 【UI元素伪类(IE8-不支持)】 :enabled 可用状态 :disabled 不可用状态 :checked 选中状态 ﻿ input:enabled{color: red} // [注意]input和:和enabled之间都不可以有空格 ﻿ 【结构伪类(IE8-不支持)】 E:first-child(IE6-不支持) 父元素的第一个子元素,且该子元素是E，与E:nth-child(1)等同 E:last-child(IE6-不支持) 父元素的最后一个子元素，且该子元素是E，与E:nth-last-child(1)等同 :root 选择文档的根元素，即元素 E F:nth-child(n) 选择父元素的第n个子元素，父元素是E，子元素是F E F:nth-last-child(n) 选择父元素的倒数第n个子元素，父元素是E，子元素是F E F:nth-of-type(n) 选择父元素的具有指定类型的第n个子元素，父元素是E，子元素是F E F:nth-last-of-type(n) 选择父元素的具有指定类型的倒数第n个子元素，父元素是E，子元素是F E:first-of-type 选择父元素中具有指定类型的第1个子元素，与E:nth-of-type(1)相同 E:last-of-type 选择父元素中具有指定类型的最后1个子元素，与E:nth-last-of-type(1)相同 E:only-child 选择父元素中只包含一个子元素，子元素是E E:only-of-type 选择父元素中只包含一个同类型的子元素，子元素是E E:empty 选择没有子元素的元素，而且该元素也不包含任何文本节点 [注意]n可以是整数(从1开始)，也可以是公式，也可以是关键字(even、odd) ﻿ p:first-child 代表的并不是的第一个子元素，而是元素是某元素的第一个子元素 p > i:first-child 匹配所有元素中的第一个元素 p:first-child i 匹配所有作为第一个子元素的元素中的所有元素 ﻿ 【:lang 相当于|=属性选择器(IE7-不支持)】 p:lang(en) 匹配语言为\"en\"的 ﻿ 【伪类的结合】 a:visited:hover:first-child{color: black;} // [注意]顺序无关 ﻿ 伪元素选择器 ﻿ IE8-浏览器仅支持伪元素选择器的单冒号表示法 ﻿ 【:first-letter 设置首字母样式】 所有前导标点符号应与第一个字母一同应用该样式； 只能与块级元素关联； 只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-letter中存在连接符的原因 ﻿ p:first-letter {color: red;} ﻿ 【:first-line 设置首行样式】 只能与块级元素关联； 只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-line中存在连接符的原因 p:first-line{color: red;} ﻿ 【:before 在元素内容前面插入内容(IE7-不支持)】 默认这个伪元素是行内元素，继承元素可继承的属性； 所有元素都必须放在出现该伪元素的选择器的最后面。 p:before{content:\"text\"} ﻿ 【:after 在元素内容后面插入内容(IE7-不支持)】 默认这个伪元素是行内元素，继承元素可继承的属性 p:after{content:\"text\"} ﻿ 【::selection 匹配被用户选择的部分】 目前selection只支持color和background两个属性，且只支持双冒号写法(IE8-浏览器不支持) ﻿ ::-moz-selection 　　 firefox浏览器需要添加前缀 ﻿ 【根元素选择器】 根元素选择器:root用来选择HTML元素，但由于其实质是伪类选择器，所以其优先级更高。在HTML上设置的样式，如果在:root上也设置了同样的样式，则会被覆盖 ﻿ html{font-size:20px;} :root{font-size:30px;} 最终是30px Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:57:50 "},"css层叠规则,优先级算法.html":{"url":"css层叠规则,优先级算法.html","title":"css层叠规则,优先级算法","keywords":"","body":"前言 层叠样式表CSS最基本的一个特性就是层叠。冲突的声明通过层叠进行排序，由此确定最终的文档表示。而这个过程的核心就是选择器及其相关声明的特殊性、重要性、来源及继承机制。本文将详细介绍CSS层叠 ﻿ 特殊性（优先级） 1、内联样式 -> 1,0,0,0 ﻿ 2、ID属性值 -> 0,1,0,0 ﻿ 3、类属性值、属性选择或伪类 -> 0,0,1,0 ﻿ 4、元素或伪元素 -> 0,0,0,1 ﻿ 5、结合符和通配选择器 -> 0,0,0,0 ﻿ 特殊性的值是从左向右排序的，特殊性值1,0,0,0大于以0开头的所有值，而无论后面是什么数。在一组规则中，特殊性最高的规则胜出 ﻿ h1{} -> 0,0,0,1 p em{} -> 0,0,0,2 .grape{} -> 0,0,1,0 *.bright{} -> 0,0,1,0 p.bright em.dark{} -> 0,0,2,2 #id121{} -> 0,1,0,0 div#side *[href]{} -> 0,1,1,1 ﻿ 重要性(iimportant) 有时某个声明可能非常重要，超过了所有其他声明，CSS2.1称之为重要声明。重要声明在声明的结束分号之前插入!important来标志，如果!important放在声明的任何其他位置，整个声明都将无效 ﻿ 如果一个声明是重要声明，则超过所有的非重要声明 ﻿ 继承 继承是从一个元素向其后代元素传递属性值所采用的机制。基于继承机制，样式不仅可以应用到指定的元素，还会应用到它的后代元素 ﻿ 在两个比较特殊的情况需要注意：一个是在HTML中，应用到body元素的背景样式可以传递到html元素；另一个是标签不会继承父元素的文本样式 ﻿ [注意]继承的属性没有特殊性 ﻿ 来源 CSS按来源的不同分为3类：author(作者)、user(用户)、user agent(代理) ﻿ 1、author(作者): 来自文档的样式文件。我们平常所写的样式基本上都是这一类的 ﻿ 2、user(用户): 用户指定的自定义的样式文件。一些UA允许用户导入自定义的样式文件 ﻿ 3、user agent(代理): 一些UA(如：浏览器)要为某些元素预设一个默认的样式，以方便阅读 ﻿ 关于用户CSS因为不常见，可能一些朋友不太理解。IE可以通过Internet 选项 -> 外观 -> 辅助功能 -> 用户样式表来指定样式文件。Chrome可以使用Stylish扩展来实现 ﻿ ﻿ 层叠 CSS层叠样式表的层叠特性就是让样式层叠在一起，通过特殊性、重要性、来源及继承机制来排列层叠样式的顺序及选出胜出者 ﻿ 1、首先，按照来源及重要性排序。在不考虑重要性的前提下，优先级顺序为：author(作者) > user(用户) > user agent(代理)。但是，如果考虑重要性，则user(用户)的优先级大于author(作者)的优先级，这样做是试图平衡author(作者)和user(用户)。所以，最终的优先级排序为：user(用户)!important > author(作者)!important > author > user > user agent ﻿ 2、接着，对于非重要声明来说，按照特殊性排序。特殊性越高的规则，权重越大 ﻿ 3、最后，如果特殊性相同，则按照出现顺序排序。声明在样式表或文档中越靠后出现，权重越大。如果样式表中有通过@import导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表的所有声明在后 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:58:17 "},"css长度单位学习em,rem,px,vw,vh.html":{"url":"css长度单位学习em,rem,px,vw,vh.html","title":"css长度单位学习(em,rem,px,vw,vh)","keywords":"","body":"绝对长度单位 绝对长度单位代表一个物理测量 ﻿ 【像素px(pixels)】 像素，为影像显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。仔细处理的话，一幅影像中的像素可以在任何尺度上看起来都不像分离的点或者方块；但是在很多情况下，它们采用点或者方块显示。每个像素可有各自的颜色值，可采三原色显示，因而又分成红、绿、蓝三种子像素（RGB色域），或者青、品红、黄和黑（CMYK色域，印刷行业以及打印机中常见）。照片是一个个取样点的集合，在影像没有经过不正确的/有损的压缩或相机镜头合适的前提下，单位面积内的像素越多代表分辨率越高，所显示的影像就会接近于真实物体。 ﻿ 在web上，像素px是典型的度量单位，很多其他长度单位直接映射成像素。最终，他们被按照像素处理 ﻿ 【英寸in(inches)】 1in = 2.54cm = 96px ﻿ 【厘米cm(centimeters)】 1cm = 10mm = 96px/2.54 = 37.8px ﻿ 【毫米mm(millimeters)】 1mm = 0.1cm = 3.78px ﻿ 【1/4毫米q(quarter-millimeters)】 1q = 1/4mm = 0.945px ﻿ 【点pt(points)】 点（英语：point，pt），也音译磅因、磅，是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。 1pt = 1/72in = =0.0139in = 1/722.54cm = 1/7296px = 1.33px ﻿ 【派卡pc(picas)】 派卡（英语：pica）是印刷行业使用的长度单位。 1pc = 12pt = 1/6in = 1/6*96px = 16px ﻿ 字体相关相对长度单位 em、ex、ch、rem是字体相关的相对长度单位 ﻿ 【em】[重点] em表示元素的font-size属性的计算值，如果用于font-size属性本身，相对于父元素的font-size；若用于其他属性，相对于本身元素的font-size ﻿ .box{font-size: 20px;} .in{ /* 相对于父元素，所以2*20px=40px */ font-size: 2em; /* 相对于本身元素，所以5*40px=200px */ height: 5em; /* 10*40px=400px */ width: 10em; background-color: lightblue; } ﻿ 【rem】 rem是相对于根元素html的font-size属性的计算值 兼容性: IE8-不支持 /* 浏览器默认字体大小为16px，则2*16=32px，所以根元素字体大小为32px */ html{font-size: 2rem;} /* 2*32=64px */ .box{font-size: 2rem;} .in{ /* 1*32=32px */ font-size: 1rem; /* 1*32=32px */ border-left: 1rem solid black; /* 4*32=128px */ height: 4rem; /* 6*32=192px */ width: 6rem; background-color: lightblue; } 默认地，浏览器的字体大小font-size是16px，也就是1rem=16px。而如果将HTML的font-size设置为100px，方便后续计算，不设置为10px是因为chrome下最小字体大小为12px ﻿ 【ex】 ex是指所用字体中小写x的高度。但不同字体x的高度可能不同。实际上，很多浏览器取em值一半作为ex值 [注意]ex在实际中常用于微调 ﻿ 【ch】 ch与ex类似，被定义为数字0的宽度。当无法确定数字0宽度时，取em值的一半作为ch值 ﻿ 兼容性: IE8-不支持 ﻿ [注意]ch在实际中主要用于盲文排版 ﻿ 视口相关相对长度单位 关于视口相关的单位有vh、vw、vmin、vmax4个单位 兼容性:IE8-不支持，IOS7.1-不支持，android4.3-不支持(对于vmax，所有IE浏览器都不支持) [注意]黑莓错误的将其相对于视觉视口来计算；而safari奇怪地相对于html元素来计算，如果html中增加了内容，这两个单位也会发生变化 ﻿ 【vw】【vh】 布局视口宽度的 1/100 布局视口高度的 1/100 body{margin: 0;} .vhbox{ /* 实现与屏幕等高的效果 */ height: 100vh; background-color: lightblue; } ﻿ 【vmin】 布局视口高度和宽度之间的最小值的 1/100 /*类似于contain效果*/ .box{ height: 100vmin; width: 100vmin; } ﻿ 【vmax】 布局视口高度和宽度之间的最大值的 1/100 /*类似于cover效果*/ .box{ height: 100vmax; width: 100vmax; } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:59:20 "},"css样式关键字initial,inherit,unset,revert,all.html":{"url":"css样式关键字initial,inherit,unset,revert,all.html","title":"css样式关键字(initial,inherit,unset,revert,all)","keywords":"","body":"关键字 在CSS中，有4个关键字理论上可以应用于任何的CSS属性，它们是initial(初始)、inherit(继承)、unset(未设置)、revert(还原)。而all的取值只能是以上这4个关键字。本文将介绍initial、inherit、unset、revert和all ﻿ initial 表示元素属性的初始默认值(该默认值由官方CSS规范定义) 兼容性: IE不支持 ﻿ div{display: initial;} // display初始默认值为inline ﻿ inherit 表示元素的直接父元素对应属性的计算值 兼容性: IE7-不支持 ﻿ .box_css1{ border: 1px solid red; padding: 10px; width: 100px; } .test_css1{ border: inherit; height: 30px; } 测试一 ﻿ unset unset相对于initial和inherit而言，相对复杂一点。表示如果该属性默认可继承，则值为inherit；否则值为initial。实际上，设置unset相当于不设置 兼容性: IE不支持，safari9-不支持，ios9.2-不支持，android4.4.4-不支持 ﻿ revert 表示样式表中定义的元素属性的默认值。若用户定义样式表中显式设置，则按此设置；否则，按照浏览器定义样式表中的样式设置；否则，等价于unset 兼容性: 只有safari9.1+和ios9.3+支持 ﻿ all 表示重设除unicode-bidi和direction之外的所有CSS属性的属性值，取值只能是initial、inherit、unset和revert 兼容性: IE不支持，safari9-不支持，ios9.2-不支持，android4.4-不支持 ﻿ .test{ border: 1px solid black; padding: 20px; color: red; } .in{ /* all: initial; //都取默认值 border:none;padding:0;color:black; all: inherit; // 都取父元素继承值 border:1px solid black;padding:20px;color:red; all: unset; // .in的所有属性都相当于不设置值，默认可继承的继承，不可继承的保持默认值border:none;padding:0;color:red; all: revert; // 等价于unset */ } 测试文字 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:59:56 "},"css伪类和伪元素.html":{"url":"css伪类和伪元素.html","title":"css伪类和伪元素","keywords":"","body":"前言 CSS的伪类和伪元素在平时的代码中经常会出现，可是一旦别人问你，什么是伪类，什么是伪元素，可能还是不能完整的表述出来，下面我们来一探究竟。 ﻿ 伪类和伪元素定义 伪类用于在页面中的元素处于某个状态时，为其添加指定的样式。 ﻿ 伪元素会创建一个抽象的伪元素，这个元素不是DOM中的真实元素，但是会存在于最终的渲染树中，我们可以为其添加样式。 ﻿ [重点]最常规的区分伪类和伪元素的方法是：实现伪类的效果可以通过添加类来实现，但是想要实现伪元素的等价效果只能创建实际的DOM节点。 ﻿ 注意伪类使用单冒号 “:” ; 伪元素使用双冒号 “::” ﻿ 伪元素 伪元素可以分为排版伪元素、突出显示伪元素、树中伪元素三类。 ﻿ 排版伪元素 ﻿ 【::first-line】 设置元素中第一行文本的样式 ﻿ 注意只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-line中存在连接符的原因 ﻿ .firstLine::first-line { width: 200px; text-transform: uppercase; background: #f3f3f3; } hello world hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world 虽然在DOM中看不到，但实际上，上面的这段HTML代码会通过添加虚拟标签的方式进行修改。 ﻿ 【::first-letter】 指定一个元素第一个字母的样式 ﻿ [注意1]所有前导标点符号应与第一个字母一同应用该样式 ﻿ [注意2]只能与块级元素关联 ﻿ [注意3]只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-letter中存在连接符的原因 ﻿ .letter{ width: 200px; border: 1px solid black; text-indent: 0.5em; } .letter:first-letter{ font-size: 30px; float: left; } ﻿ 测试首字母下层，测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层 ﻿ 突出显示伪元素 突出显示伪元素表示文档中特定状态的部分，通常采用不同的样式展示该状态。如页面内容的选中。突出显示伪元素不需要在元素树中有体现，并且可以任意跨越元素边界而不考虑其嵌套结构。 ﻿ 【::selection】 匹配被用户选择的部分 ﻿ [注意1]firefox浏览器需要添加-moz-前缀 [注意2]只支持双冒号写法 [注意3]只支持颜色和背景颜色两个样式 ﻿ div::selection{color: red;} p::selection{ color:#fff; } ﻿ ﻿ 树中伪元素 ﻿ 【::before & ::after】 ::before是在源元素的实际内容前添加伪元素。::after是在源元素的实际内容后添加伪元素。当::before/::after伪元素的content属性不为'none'时，这两类伪元素就会生成一个元素，作为源元素的子元素，可以和DOM树中的元素一样定义样式。 ﻿ [兼容]IE7-浏览器不支持 注意默认这个伪元素是行内元素，且继承元素可继承的属性；IE7-浏览器中必须声明!DOCTYPE，否则不起作用 ﻿ // content = 字符串 .box:after{content:\"后缀\"} ﻿ // content = url div:before{ content: url(\"arrow.gif\"); } ﻿ // content = attr div:before{ content: attr(data-before); } [特] content的内容可以直接使用 url() 引入图片 ﻿ 【::marker】 ::markder可以用于定义列表项标记的样式。 ﻿ .item::marker{ color:green; } ﻿ Item 1 Item 2 Item 3 该伪元素暂时只有safari支持，尝试的话请使用safari。可以用于该伪元素的属性也有限 ﻿ 【::placeholder】 表示输入框内占位提示文字。可以定义其样式。 ﻿ ::placeholder { color: blue; } ﻿ 伪元素速查表 ``` / Typographic Pseudo-elements / ::first-line / 选取文字块首行字符 / ::first-letter / 选取文字块首行首个字符 / ﻿ / Highlight Pseudo-elements / ::selection / 选取文档中高亮(反白)的部分/ ::inactive-selection / 选取非活动状态时文档中高亮(反白)的部分/ ::spelling-error / 选取被 UA 标记为拼写错误的文本 / ::grammar-error / 选取被 UA 标记为语法错误的文本 / ﻿ / Tree-Abiding Pseudo-elements / ::before / 在选中元素中创建一个前置的子节点 / ::after / 在选中元素中创建一个后置的子节点 / ::marker / 选取列表自动生成的项目标记符号 / ::placeholder / 选取字段的占位符文本(提示信息) / /* WebVTT Format */ ::cue /* 匹配所选元素中 WebVTT 提示 */ ﻿ / Fullscreen API / ::backdrop / 匹配全屏模式下的背景 / ﻿ ## 伪类 > 伪类经常与伪元素混淆，伪元素的效果类似于通过添加一个实际的元素才能达到，而伪类的效果类似于通过添加一个实际的类来达到。实际上css3为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 ﻿ ### 锚点 关于锚点``，有常见的5个伪类，分别是:link,:hover,:active,:focus,:visited a:link{background-color:pink;}/品红，未访问/ a:hover{background-color:lightblue;}/浅蓝，鼠标悬停/ a:active{background-color:lightgreen;}/浅绿，正被点击/ a:focus{background-color:lightgrey;}/浅灰，拥有焦点/ a:visited{color:orange;}/字体颜色为橙色，已被访问/ /注意visited伪类只能设置字体颜色、边框颜色、outline颜色的样式/ ﻿ ### 伪类顺序 对于伪类顺序，有一个口诀是love-hate，代表着伪类的顺序是link、visited、focus、hover、active。但是否伪类的顺序只能如此呢？为什么是这个顺序呢？ ﻿ CSS层叠中有一条法则十分重要，就是后面覆盖前面，所以伪类的顺序是需要精心考虑的。 ﻿ 【1】link和visited必须在最前面，且没有先后顺序，否则link或visited的效果将覆盖 hover active focus ﻿ [注意]link和visited称为静态伪类，只能应用于超链接 ﻿ 【2】hover、active、focus这三个伪类必须是focus、hover、active的顺序，因为在focus状态下，也需要触发hover和active，而要触发active一定要先触发hover，所以active要放在hover后面 ﻿ [注意]hover、active、focus称为动态伪类，可应用于任何元素，但IE7-浏览器不支持:focus，:hover和:active在IE6-浏览器下只支持给\\设置 ﻿ 所以最终的顺序只有两种:link、visited、focus、hover、active或visited、link、focus、hover、active a:link{background-color:pink;}/品红，未访问/ a:visited{color:orange;}/字体颜色为橙色，已被访问/ a:focus{background-color:lightgrey;}/浅灰，拥有焦点/ a:hover{background-color:lightblue;}/浅蓝，鼠标悬停/ a:active{background-color:lightgreen;}/浅绿，正被点击/ ﻿ ### UI元素伪类 > UI元素伪类包括:enabled、:disabled、:checked三个，主要针对于HTML中的form元素，IE8-浏览器不支持 :enabled 可用状态 :disabled 不可用状态 :checked 选中状态 ﻿ input:enabled{ border: 1px solid black; background-color: transparent; } input:disabled{ border: none; background-color: gray; } input:checked{ outline: 2px solid lightblue; } ﻿ 按钮可用 按钮不可用 Male Female ﻿ ### 结构伪类 > 结构伪类可分为以下3种情况，IE8-浏览器不支持 ﻿ 【1】:nth-child(n)、:nth-last-child(n)、first-child、last-child、:only-child E F:nth-child(n) 选择父元素的第n个子元素 E F:nth-last-child(n) 选择父元素的倒数第n个子元素 E F:first-child 父元素的第一个子元素，与E F:nth-child(1)等同 E F:last-child 父元素的最后一个子元素，与E F:nth-last-child(1)等同 E F:only-child 选择父元素中只包含一个子元素 ﻿ p:first-child 　　 代表的并不是的第一个子元素，而是元素是某元素的第一个子元素 p > i:first-child 匹配所有元素中的第一个元素 p:first-child i 　　 匹配所有作为第一个子元素的元素中的所有元素 [注]n可以是整数(从1开始)，也可以是公式，也可以是关键字(even、odd) ﻿ 【2】:nth-of-type(n)、:nth-last-of-type(n)、:first-of-type、:last-of-type、:only-of-type E F:nth-of-type(n) 选择父元素的具有指定类型的第n个子元素 E F:nth-last-of-type(n) 选择父元素的具有指定类型的倒数第n个子元素 E F:first-of-type 选择父元素中具有指定类型的第1个子元素，与E F:nth-of-type(1)相同 E F:last-of-type 　 选择父元素中具有指定类型的最后1个子元素，与E F:nth-last-of-type(1)相同 E F:only-of-type 　　 选择父元素中只包含一个同类型的子元素 ﻿ .box div:nth-of-type(even){color: red;} .box p:nth-last-of-type(3){color: green;} .box div:first-of-type{color: blue;} .box p:last-of-type{color: yellow;} .box div:only-of-type{color: pink;} ﻿ 【3】:root、:not、:empty、:target :root 　选择文档的根元素 :not 　选择除某个元素之外的所有元素 :empty 选择没有子元素的元素，而且该元素也不包含任何文本节点 :target 　 匹配锚点对应的目标元素 ﻿ ﻿ :root{color:red;} div:not{background-color: lightgrey;} p:empty{height:30px;width:30px;background:pink;} :target{color:blue;} // 当点击页面上面的锚点时，锚点到的目标元素会采用这个样式 ﻿ 【其它】 1、:lang() 匹配某个语言，IE7-浏览器不支持 p:lang(en) 匹配语言为\"en\"的 ﻿ 2、不仅可以使用单一伪类，也可以伪类结合使用 [注意]顺序无关 div:hover:first-child{background-color: lightgreen;} div:last-of-type:active{background-color: lightblue;} ﻿ ﻿ ## 伪类速查表 /* Logical Combinations */ :matches() /*:any()*/ /* 匹配 集合内指定 的元素 */ :not() /* 排除 满足指定关系 的元素 */ :has() /* 匹配 满足指定关系 的元素*/ ﻿ ﻿ / Linguistic Pseudo-classes / :dir() / 匹配 设置dir(文字书写方向)属性 的元素 / :lang() / 匹配 设置lang(定义元素语言)属性 的元素 / ﻿ ﻿ / Location Pseudo-classes / :any-link / 匹配 任意有链接锚点 的元素/ :link / 匹配 未处于访问记录中 的链接 / :visited / 匹配 处于访问记录中 的链接 / :target / 匹配 URL指向的锚点 的元素 / :scope / 匹配 设置scoped属性的style标签 的作用域 / ﻿ ﻿ / User Action Pseudo-classes / :hover / 匹配 处于鼠标悬停状态 的元素 / :active / 匹配 处于激活状态 的元素 / :focus / 匹配 处于聚焦状态 的元素 / :focus-ring / 匹配 处于聚焦状态元素 的UA样式(聚焦轮廓) / :focus-within / 匹配 子节点处于聚焦状态 的元素 / :drop / 匹配 处于拖拽状态 的元素 / :drop() / 匹配 处于指定拖拽状态 的元素 / ﻿ ﻿ / Time-dimensional Pseudo-classes / :current / 匹配 处于当前状态 的定义了timeline属性的元素 / :past / 匹配 处于过去状态 的定义了timeline属性的元素 / :future / 匹配 处于将来状态 的定义了timeline属性的元素 / ﻿ ﻿ / Resource State Pseudos / :playing / 匹配 处于播放状态 的元素 / :paused / 匹配 处于暂停状态 的元素 / ﻿ ﻿ / The Input Pseudo-classes / :enabled / 匹配 可以编辑 的元素 / :disabled / 匹配 禁止编辑 的元素 / :read-only / 匹配 内容只读 的元素 / :read-write / 匹配 内容可编辑 的元素 / :placeholder-shown / 匹配 显示字段占位符文本 的元素 / :default / 匹配 页面载入默认选中 的元素 / ﻿ :checked / 匹配 选中状态 的元素 / :indeterminate / 匹配 模糊状态 的元素 / ﻿ :valid / 匹配 输入内容通过类型验证 的元素 / :invalid / 匹配 输入内容无法通过类型验证 的元素 / :in-range / 匹配 输入数值符合范围 的元素 / :out-of-range / 匹配 输入数值溢出范围 的元素 / :required / 匹配 设置必填属性 的元素 / :optional / 匹配 可选字段 的元素 / :user-invalid / 匹配 用户输入内容未通过验证 的元素 / ﻿ / Tree-Structural pseudo-classes / :root / 匹配 文档树 的根元素/ :empty / 匹配 无子节点 的元素 / :blank / 匹配 仅包含空格或者换行符 的元素 / ﻿ :nth-child(n) / 匹配 符合元素集合中指定位置 的元素 / :nth-last-child(n) / 反序匹配 符合元素集合内指定位置 的元素 / :first-child / 匹配 符合元素集合内首个 的元素 / :last-child / 匹配 符合元素集合内末尾 的元素 / :only-child / 匹配 无兄弟节点 的元素 / ﻿ :nth-of-type(n) / 匹配 符合元素集合中同类型指定位置 的元素 / :nth-last-of-type(n) / 反序匹配 符合元素集合中同类型指定位置 的元素 / :first-of-type / 匹配 每个在元素集合中初次出现 的元素 / :last-of-type / 匹配 每个在元素集合中末次出现 的元素 / :only-of-type / 匹配 无同类兄弟节点 的元素/ ﻿ ﻿ / Fullscreen API / :fullscreen / 匹配 全屏显示模式中 的元素 / ﻿ ﻿ / Page Selectors / :first / 打印文档时首页的样式 / :left / 打印文档时左侧的样式 / :right / 打印文档时右侧的样式 / ``` Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 18:01:02 "},"CSS盒模型深入理解.html":{"url":"CSS盒模型深入理解.html","title":"CSS盒模型深入理解","keywords":"","body":"前言 所有文档元素都生成一个矩形框，这称为元素框(element box)，它描述了一个元素在文档布局中所占的空间大小。而且，每个框影响着其他元素框的位置和大小 ﻿ ﻿ 宽高 宽度width被定义为从左内边界到右内边界的距离，高度height被定义为从上内边界到下内边界的距离 ﻿ 在CSS中，可以对任何块级元素设置显式高度。如果指定高度大于显示内容所需高度，多余的高度会产生一个视觉效果，就好像有额外的内边距一样；如果指定高度小于显示内容所需高度，则会向元素添加一个滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性 ﻿ [注意]宽度和高度无法应用到行内非替换元素，且不能为负 ﻿ 【auto】 宽高和margin可以设置auto。 ﻿ 对于块级元素来说，宽度设置为auto，则会尽可能的宽。 元素宽度=包含块宽度—元素水平外边距-元素水平边距宽度-元素水平内边距； ﻿ 高度设置为auto，则会尽可能的窄。详细来说，元素高度=恰好足以包含其内联内容的高度 ﻿ [注意]如果没有显式声明包含块的height，则元素的百分数高度会重置为auto ﻿ 【怪异盒模型】 IE6-浏览器的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸 ﻿ 【最大最小宽高】 设置最大最小宽高的好处是可以相对安全地混合使用不同的单位。使用百分数大小的同时，也可以设置基于长度的限制 ﻿ min-width | min-height 值: | | inherit 初始值: 0 应用于: 块级元素和替换元素 继承性: 无 百分数: 相对于包含块的宽度(高度) ﻿ max-width | max-height 值: | | inherit 初始值: none 应用于: 块级元素和替换元素 继承性: 无 百分数: 相对于包含块的宽度(高度) [注意]IE6-浏览器不支持min-width | min-height | max-width | max-height [注意]当最小宽度(高度)大于最大宽度(高度)时，以最小宽高的值为准 ﻿ 内边距 相比于盒模型的其他属性(如在定位中经常使用负值的margin，因为CSS3的到来重获光彩的border等)，padding显得中规中矩了很多，没有什么兼容性，也没有一些特殊的问题 ﻿ 对于行内元素，左内边距应用到元素的开始处，右内边距应用到元素的结尾处，垂直内边距不影响行高，但会影响自身尺寸，加背景颜色可以看出 ﻿ [注意]内边距不能是负值 ﻿ padding 值:[ | ]{1,4} | inherit 初始值: 未定义 应用于: 所有元素 继承性: 无 百分数: 相对于包含块的width ﻿ 【50%】 块级元素通过padding:50%可以实现正方形的效果，因为水平和垂直padding的百分比值都是相对于包含块的宽度决定的，常常用于移动端头图 ﻿ 如果是内联元素使用padding:50%，必须配合font-size:0，因为使用inline元素的垂直padding会出现\"幽灵空白节点\"，也就是规范中\"strut\"。所以通过font-size:0使其尺寸为0 ﻿ 块元素效果展示 行内元素：选择font-size = 0; 去除“幽灵空白节点” 效果展示 ﻿ 【表单】 1、所有浏览器input/textarea/button都内置padding 2、部分浏览器select下拉内置padding，firefox、IE8+可以设置padding 3、除IE10-以外的其他浏览器，radio/checkbox单选复选框无内置padding，且无法设置padding。IE10-浏览器的radio/checkbox单选复选框有内置padding，且可以设置padding [注意]除IE10-以外的其他浏览器，radio/checkbox单选复选框无内置border，且无法设置border ﻿ 【button兼容】 1、在firefox浏览器中，设置padding:0，按钮左右两侧依然有padding，这时需要使用firefox自有样式 button::-moz-focus-inner{padding:0;} ﻿ 2、IE7-浏览器下文字越多，左右padding逐渐变大，设置overflow:visible可解决该问题 ﻿ 3、button按钮的padding与高度计算不兼容 button{ line-height:20px; padding:10px; border:none; } ﻿ //结果为： IE7: 45px firefox:42px chrome/IE8+:40px ﻿ 可以使用label标签来实现类似的效果，然后把按钮button进行可访问性隐藏即可 按钮 ﻿ label{ display:inline-block; line-height:20px; padding:10px; border:none; } ﻿ //结果为： IE7: 40px firefox:40px IE8+:40px chrome:40px ﻿ 外边距 设置外边距margin会在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景 ﻿ 外边距可以应用到行内元素，上下外边距对行高没有任何影响。由于上下外边距实际上是透明的，所以这个声明没有任何视觉效果。左外边距应用到元素开始处；右外边距应用到元素结束处 ﻿ margin 值:[ | | auto]{1,4} | inherit 初始值: 未定义 应用于: 所有元素 继承性: 无 百分数: 相对于包含块的width ﻿ [注意]对于普通元素来说，包含块就是块级父级元素，对于定位元素来说，包含块是定位父级。所以，普通元素的margin百分比相对于块级父级元素的width，定位元素的margin百分比相对于定位父级的width ﻿ [注意]margin负值的作用非常大 ﻿ 边框 元素外边距内就是元素的边框border，元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成 ﻿ 对于行内元素来说，边框实际上画在各行之外的下一个像素上，由于各行紧挨着，所以其边框会重叠。无论为行内元素的边框设置怎样的宽度，不会对行高有任何影响；但左右边框会分别显示在元素的开始处和结尾处 ﻿ .d1{ width: 200px; border: 1px solid red; } .s1{ border: 1px solid black; background-color: yellow; padding: 6px; margin: 6px; font-size: 30px; line-height: 50px; } ﻿ 测试文字测试文字测试文字 ﻿ box-sizing 在CSS中盒模型被分为两种，第一种是W3C的标准模型，第二种是IE怪异盒模型。 ﻿ 不同之处在于后者的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸。目前对于浏览器大多数元素都是基于W3C标准的盒模型，但对于表单form中的部分元素还是基于IE的怪异盒模型，如input里的radio、checkbox、button等元素，如果给其设置border和padding它们也只会往元素盒内延伸 ﻿ 在W3C的标准模型下，宽度和高度仅仅包含了内容宽度，除去了边框和内边距两个区域，这样为web设计师处理效果带来了不少麻烦。为了解决这个问题，CSS3新增了一个盒模型属性box-sizing，能够事先定义盒模型的尺寸解析方式 ﻿ [注意]IE7-浏览器不支持 ﻿ box-sizing 值: content-box | border-box | padding-box | inherit 初始值: content-box 应用于: 块级元素和替换元素 继承性: 无 ﻿ [注意1]只有firefox浏览器支持padding-box属性值 [注意2]IE浏览器在getComputedStyle得到width/height是按照标准模式计算的，而不论box-sizing的取值 ﻿ 效果展示 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 18:06:41 "},"CSS视觉格式化（基本框、包含块、盒模型、水平格式化、垂直格式化、行布局、em框、内容区、行间.html":{"url":"CSS视觉格式化（基本框、包含块、盒模型、水平格式化、垂直格式化、行布局、em框、内容区、行间.html","title":"* CSS 视觉格式化（基本框、包含块、盒模型、水平格式化、垂直格式化、行布局、em框、内容区、行间","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 18:16:48 "},"line-heightvertical-align学习总结.html":{"url":"line-heightvertical-align学习总结.html","title":"line-height && vertical-align 学习总结","keywords":"","body":"前言 line-height、font-size、vertical-align是设置行内元素布局的关键属性。这三个属性是相互依赖的关系，改变行间距离、设置垂直对齐等都需要它们的通力合作。 行高 line-height line-height行高是指文本行基线之间的距离。 行高line-height实际上只影响行内元素和其他行内内容，而不会直接影响块级元素，也可以为一个块级元素设置line-height，但这个值只是应用到块级元素的内联内容时才会有影响。 在应用到块级元素时，line-height定义了元素文本基线之间的最小距离，即最小行高 line-height 值: | | | normal | inherit 初始值: normal(通常line-height:normal的值为font-size值的1.2倍) 应用于: 所有元素 继承性: 有 百分数: 相对于元素的字体大小font-size [注意]如果块级元素中的某一个子级内联元素设置的“行高”比“最小行高”大，则行框以设置“行高”来渲染；如果小，则以“最小行高”来渲染。因为，每一个子级内联元素的行高都是行内框的高度，只有一行中所有的行内元素(包括代表父级元素的匿名文本)，最大的行内框高度才能成为整行的行高。 效果展示 重要概念 【内容区】 对于行内非替换元素或匿名文本某一部分，font-size确定了内容区的高度 【行内框】 内容区加上行间距等于行内框。如果一个行内非替换元素的font-size为15px，line-height为21px，则相差6px。用户代理将这6像素一分为二，将其一半分别应用到内容区的顶部和底部，这就得到了行内框 当line-height小于font-size时，行内框实际上小于内容区 【行框】 行框定义为行中最高行内框的顶端到最低行内框底端之间的距离，而且各行框的顶端挨着上一行行框的底端 【框属性】 内边距、外边距和边框不影响行框的高度，即不影响行高 行内元素的边框边界由font-size而不是line-height控制 外边距不会应用到行内非替换元素的顶端和底端 margin-left、padding-left、border-left应用到元素的开始处；而margin-right、padding-right、border-right应用到元素的结尾处 效果展示 【替换元素】 行内替换元素需要使用line-height值，从而在垂直对齐时能正确地定位元素。因为vertical-align的百分数值是相对于元素的line-height来计算的。对于垂直对齐来说，图像本身的高度无关紧要，关键是line-height的值 默认地，行内替换元素位于基线上。如果向替换元素增加下内边距、外边距或边框，内容区会上移。 替换元素的基线是正常流中最后一个行框的基线。除非，该替换元素内容为空或者本身的overflow属性值不是visible，这种情况下基线是margin底边缘 垂直对齐 vertical-align用来设置垂直对齐方式，所有垂直对齐的元素都会影响行高 值: baseline | sub | super | top | text-top | middle | bottom | text-bottom | | | inherit 初始值: baseline 应用于: 行内元素、替换元素、表单元格 继承性: 无 百分数: 相对于元素的行高line-height [注意]IE7-浏览器中vertical-align的百分比值不支持小数行高，且取baseline、middle、text-bottom等值时与标准浏览器在展示效果不一样，常用的解决办法是将行内元素设置display:inline-block vertical-align:baseline(元素的基线与父元素的基线对齐) vertical-align:sub(降低元素的基线到父元素合适的下标位置) vertical-align:super(升高元素的基线到父元素合适的上标位置) vertical-align:bottom(把对齐的子元素的底端与行框底端对齐) vertical-align:text-bottom(把元素的底端与父元素内容区域的底端对齐) vertical-align:top(把对齐的子元素的顶端与行框顶端对齐) vertical-align:text-top(把元素的顶端与父元素内容区域的顶端对齐) vertical-align:middle(元素的中垂点与父元素的基线加1/2父元素中字母X的高度对齐) vertical-align:(+-n)px(元素相对于基线上下偏移npx) vertical-align:x%(相对于元素的line-height值) vertical-align:inherit(从父元素继承vertical-align属性的值) 效果展示 【inline-block底部空隙】 inline-block元素在块级元素中留空隙就是因为图像的默认垂直对齐方式是基线对齐(基线对齐在原理上相当于图像底边与匿名文本大写英文字母X的底边对齐)；而匿名文本是有行高的，继承父级元素设置的行高，默认为normal(即font-size的1.2倍)，所以X的底边距离行框有一段距离，这段距离就是图像留出的空隙 于是，解决这个问题有以下几个解决办法 2、父级的line-height: 0 这样使匿名文本与行框的距离为0 3、vertical-align: top/middle/bottom 内联块元素底部空隙消除演示 应用 【1】单行文本水平垂直居中 div{ line-height: 100px; width: 100px; text-align: center; border: 1px solid black; } [注意]好多地方都写着单行文本垂直居中是将高度和行高设置成一样的值，但高度其实是没有必要设置的。仅仅设置行高就可以，文字在一行中本身就是垂直居中显示的 效果演示 【2】图片近似垂直居中 div{ line-height: 200px; text-align: center; } img{ vertical-align: middle; } 由于字符X在em框中并不是垂直居中的，且各个字体的字符X的高低位置不一致。所以，当字体大小较大时，这种差异就更明显 效果展示 【3】图片完全垂直居中 在方法2的基础上设置块级元素的font-size为0，则可以设置图片完全垂直居中 div{ line-height: 200px; text-align: center; font-size: 0; } img{ vertical-align: middle; } 效果演示 【4】多行文本水平垂直居中 由于方法3设置font-size为0的局限性，块级元素里面无法放置文本。方法4主要通过新增元素来实现垂直居中效果，该方法也可用于图片的水平垂直居中 div{ height: 100px; width: 200px; background-color: pink; text-align: center; } span{ display:inline-block; vertical-align: middle; line-height: 20px; width: 100px; } i{ display: inline-block; height: 100%; vertical-align: middle; } 我是特别长的特别长的特别长的特别长的多行文字 效果演示 【5】图标和文本对齐 1、使用长度负值 img{ vertical-align: -5px; } 根据实践经验，20*20像素的图标后面跟14px的文字，vertical-align设置为-5px可以达到比较好的对齐效果 2、使用文本底部对齐 img{ vertical-align: text-bottom; } 使用baseline会使图标偏上；使用top/bottom会受到其他行内元素影响造成定位偏差；使用middle需要恰好的字体大小且兼容性不高；使用text-bottom较合适，不受行高及其他内联元素影响 效果展示 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 18:41:54 "},"angular.html":{"url":"angular.html","title":"angular","keywords":"","body":"angular学习汇总 使用 Service + Rxjs 进行 Angular 的状态管理 Service的用途-博客文章 rxjs-博客文章 30 天精通 RxJS Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 08:28:30 "},"InputorInjectable.html":{"url":"InputorInjectable.html","title":"[重难]@Input() or @Inject()","keywords":"","body":"提纲 简单了解下input是什么，有什么作用 简单了解下inject是什么，有什么作用 基于他们的雷同之处，我们该如何做出选择 前言 在组件化开发的项目中，对于我们来说组件之间的传值是一个核心话题，父->子传值、子->父传值、兄弟组件传值。今天这篇文章不打算全部覆盖传值方式，主要来学习下input的传值方式和inject的传值方式 @Input() 一个装饰器，用来把某个类字段标记为输入属性，并且提供配置元数据。 声明一个可供数据绑定的输入属性，在变更检测期间，Angular 会自动更新它。 @Input()的工作方式：父组件 @Component({ selector: 'app', template: ` ` }) class App {} 子组件 @Component({ selector: 'bank-account', template: ` Bank Name: {{bankName}} Account Id: {{id}} ` }) class BankAccount { @Input() bankName: string; @Input('account-id') id: string; normalizedBankName: string; } 对就是这么简单，主要就是用于父子之间数据传递。没有其它更加复杂的东西 @Inject() 参考文献 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 17:57:22 "}}