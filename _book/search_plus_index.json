{"./":{"url":"./","title":"knowledge","keywords":"","body":"6月28日 [ing]Cookie 整理课件 + 完成作业 浏览器的 memory cache disk cache encodeURI() && encodeURIComponent() web worker service worker（缓存策略） string replace 方法详细学习 ApplicationRef(刷新组件的例子) Overlay renderer2 实现message组件 周计划(每周：系列+短文) angular angular组件中继承extends：https://segmentfault.com/a/1190000008976996 angular响应式表单 ui-router系列 directives Transition 后台管理系统实战案例 学习池 【短文】 call，apply，bind 方法详解 javascript运行机制 http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html 如何使用n管理node.js版本 JavaScript 浮点数陷阱及解法 https://github.com/camsong/blog/issues/9 常见的开源协议：MIT等等 javascript AOP的实现 JavaScript 函数式编程http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/(学完es5函数相关知识，再来写该文章) 四种常见的 POST 提交数据方式 如何实现栅格化系统布局 font-variant-numeric 设置为 tabular-nums，使其为等宽字体。(https://www.fonts.com/content/learning/fontology/level-3/numbers/proportional-vs-tabular-figures) CSRF攻击 HttpClient(完成rxjs之后在写) retina && 4k屏幕 Git Commit Message Git Hook Git 本地新建分支并推送到远端 【中文】 visual DOM (1、先阅读一些优秀文章。2、在进行自我的深度思考总结 3、输出属于自己的文章) sQuery Web Components redux理论及在angular中的应用(慕课视频) 【系列】 es5 函数 rxjs系列文章(2) es5 对象 设计模式 发布订阅模式 单例模式 工厂模式 babel es6 DOM 阅读 ant-design 源码 webpack typeScript 单元测试 Linux学习(可以进行持续学习，学习越深入对于程序的理解则越深入) vim学习 算法 css动画 过渡transition 变形transform(2d) 变形transform(3d) 变形transform的副作用 动画animation 动画animation的三个应用(漂浮的白云、旋转的星球和正方体合成) animate.css的使用 js运动 匀速运动 变速运动 曲线运动 抖动 缓冲运动和弹性运动 投掷和轨迹 鼠标跟随运动 碰壁运动 碰撞运动 时间版运动 velocity.js的使用 tween.js的使用 帧动画 svg svg 图案 svg 裁切和蒙版 svg 慕课视频 underscore源码阅读 【zc驱动】 todomvc backbone版本 backbone 框架源码 css规范学习 stylelint js规范学习 ESLint editorconfig的实践 HTML目录 【基础】 HTML 基础语法（HTML简介，HTML文档声明） HTML 元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则） HTML 属性 HTML 常用标签（a，img） HTML 表格 HTML iframe 使用postMessage方法进行跨文档消息传递 HTML 表单(form元素介绍，input元素的常用type类型，input元素的常用属性) HTML meta标签&base标签 HTML 条件注释规范 【重难】 attribute和property的区别 深入理解HTML表格 table单元格中文字过长如何进行省略 CSS目录 【CSS2 基础】 CSS文件引入 CSS 选择器(常规选择器，伪类选择器，伪元素选择器，根元素选择器) 层叠和结构 长度单位em,rem CSS 样式关键字(initial,inherit,unset,revert,all) 伪类和伪元素 *CSS 盒模型 *CSS 视觉格式化 line-height && vertical-align border CSS 外边距 margin CSS margin负值 outline overflow css滚动条 display visibility css浮动 css清除浮动 颜色color 背景background 透明度opacity 光标cursor 【定位】 position 定位之距离偏移 position 定位之层级z-index 绝对定位 绝对定位的应用 相对定位和固定定位 【字体和文本】 font字体 iconfont字体应用实战 文本样式 css文本方向 空白符和换行 文本溢出和文本阴影 【布局】 grid栅格布局 Media查询 flex布局 移动优先的响应式布局 水平垂直居中 两端对齐布局 单列定宽，单列自适应 两列自适应布局 三列布局 三栏式布局 等分布局 等高布局 全屏布局 sticky-footer布局 【CSS预处理语言】 less sass && scss 【动画】 过渡transition 变形transform(2d) 变形transform(3d) 线性渐变linear-gradient 径向渐变 动画animation animate.css库使用 【规范】 css 规范（reset , 命名） StyleLint 【其它】 css兼容总结 haslayout总结 css滤镜 剪裁clip clip-path 元素显示隐藏的思路 css变量variable 【重点难点】 BFC（格式化上下文）深入理解 font-size为0消除inline&&inline-block元素间隙 css中数学表达式calc height设置100%失效 && 分栏高度自适应布局 css-modules JavaScript目录 【ES5】【基本概念】 JavaScript 基础(语法、关键字和保留字、变量) JavaScript 基础(表达式) JavaScript 基础(动态脚本) JavaScript 基础(严格模式) JavaScript 运算符(语法概述) JavaScript 运算符(算术运算符) JavaScript 运算符(关系运算符) JavaScript 运算符(逻辑运算符) JavaScript 运算符(位运算符) JavaScript 运算符(条件、逗号、赋值、()和void运算符) JavaScript 语句(表达式语句、块语句、空语句和声明语句) JavaScript 语句(条件语句、循环语句和跳转语句) JavaScript 语句(eval和with) JavaScript 规范(javascript编码标准) JavaScript 规范(关于javascript代码优化的8点建议) JavaScript 规范(JS代码检查工具ESLint) 【变量、作用域和内存问题】 JavaScript 基本类型和引用类型 JavaScript 执行环境、作用域、内存管理及垃圾回收机制 【数据类型】 基本包装类型 null和undefined (void 0) 与 undefined Boolean布尔类型 Number数字类型 Math对象 String字符串类型 String字符串类型的属性和方法 【数组】 Array基础 数组方法总结 数组检测方式 判断两个数组是否相等的方法 【Date】 日期和时间基础知识 Date日期对象 日历实现 moment.js库的应用 【RegExp】 正则表达式基础 RegExp类型 javaScript模版引擎原理解析 【类型转换】 toString() && valueOf() 数据类型转换 JavaScript 有效的类型判断 【面向对象】 Object类型基础知识 对象的属性操作 对象的属性描述 彻底理解prototype、proto和constructor的三角关系 构造函数和原型对象 创建对象的几种方式 对象继承的几种方式 面向对象的6个概念 对象的深复制浅复制 【函数表达式】 函数概述 函数参数 函数的属性和方法 JavaScript 函数递归 JavaScript IIEF 模仿块级作用域 深入学习 JavaScript 闭包 函数式编程 高阶函数 函数柯里化 函数节流和函数防抖 惰性函数 【事件】 JavaScript 事件机制深入学习 JavaScript 事件类型汇总 复制黏贴 浏览器事件循环EventLoop node 事件循环 EventLoop 【BOM】 window对象 location对象 navigator对象 screen对象 history对象 【客户端检测】 能力检测 怪癖检测 浏览器检测 【DOM】 节点类型 获取节点 元素选择器 DOM样式操作 DOM遍历 DOM中的范围 【元素尺寸】 offset client scroll 回到顶部 元素视图的三个方法 【表单脚本】 表单的基础知识 文本框脚本 选择框脚本 【脚本化CSS】 JavaScript 动态操作CSS 【HTML5新特性】 跨文档消息传递 drag对象进行拖拽 视频播放器audio 音频播放器video 历史状态管理 Web Worker 【错误处理与调试】 错误处理try-catch 前端错误调试的几种常用方法 【数据传递与格式】 JSON语法 XHR对象 CORS 图片Ping JSONP iframe跨域 Fetch axios 前端上传文件的理解 【存储】 Cookie sessionStorage && localStorage 【模块化】 amd && cmd && CommonJs && ES6模块化 jquery插件是如何支持cmd,amd,commonJs 【高级技巧】 call，apply，bind 方法详解 setTimeout和setInterval 防篡改对象 滚动优化https://www.cnblogs.com/xiaohuochai/p/9188619.html 简易版jQuery——mQuery 实现富文本编辑器 【拖拽】 原生拖放 模拟拖拽 磁性吸附 碰撞检测 拖拽改变元素大小 模拟滚动条 【动画】 JavaScript 运动系列总结 帧动画requestAnimationFrame velocity.js tween.js 拖放实现 模拟滚动条 【性能&规范】 JavaScript 最佳实践 JavaScript 代码优化建议 ESLint 【重点难点】 this 作用域 【ES5 其它】 js浮点运算不精确的解决方案 如何实现中英文切换 JavaScript 判断数组和对象是否为空的方法 【Babel】 Babel 入门学习 【ES6基础】 let 和 const 命令 变量的解构赋值 字符串的扩展 正则的扩展 数值的扩展 函数的扩展 数组的扩展 对象的扩展 Symbol Set 和 Map 数据结构 Promise promise源码实现 Iterator 和 for...of 循环 Generator 函数的语法 async Class 语法 Module 语法 【ES6难点】 ES6 新增数组方法的实战用法 Node目录 【相关学习】 semver规范（语义化版本） npm入门教程 npm scripts 脚本基础指南 mac中如何升级node,npm npm publish 发布 【基础】 (1) 初识Node.js (2) 开发环境和调试工具 (3) commonJs 规范 (4) node 概念(global、process进程、调试) (5) node基础模块 path node基础模块 Buffer node基础模块 event node基础模块 fs node项目初始化 node搭建静态资源服务器 node单元测试 mocha node UI 测试 【http】 Restful架构的理解 node中的http请求 node 处理get请求 node 处理post请求 node 搭建开发环境 node 开发路由搭建 【数据库】 node 操作mysql 【登录功能】 node cookie node session node redis node nginx配置 【日志功能】 node 文件操作 node stream node 日志功能 【安全】 sql注入 xss攻击 【框架】 express框架 koa框架 【上线配置】 PM2工具 【实战】 node 爬虫实现 基于JWT标准的用户认证接口实现 https://www.cnblogs.com/xiaohuochai/p/8440335.html 网络协议目录 HTTP 【基础】 HTTP入门学习 网络基础 数据传输 网站架构演化 连接管理 缓存 【组成】 URL 报文起始行 报文首部 【结构】 Web服务器 代理 网关、隧道和中继 【安全】 Web攻击技术 客户端识别及Cookie 基本认证 摘要认证 安全HTTP 【编码】 实体和编码 字符集 内容协商 【内容发布】 Web主机托管 重定向和负载均衡 日志记录 【重难】 从输入URL到页面加载的全过程https://www.cnblogs.com/xiaohuochai/p/9193083.html get方法和post方法的区别 DNS预解析prefetch https://www.cnblogs.com/xiaohuochai/p/9185622.html websocket websocket协议基础 websocket聊天室项目实战 Nginx 使用nginx部署网站 https://www.cnblogs.com/xiaohuochai/p/9093819.html 移动端 移动端开发必须了解的知识 移动端高清屏适配方案 300ms以及点透事件产生的原因及处理方案 rem布局详解 JSBridge原理，js和native是如何通信的 H5优化首页白屏时间过长 Hybrid-App 移动端中的陀螺仪 https://www.cnblogs.com/xiaohuochai/p/8511935.html 移动web开发之touch事件 https://www.cnblogs.com/xiaohuochai/p/8293225.html 加载骨架屏幕 TypeScript 数据结构 数据结构之图 https://www.cnblogs.com/xiaohuochai/p/8185671.html 数据结构之树 https://www.cnblogs.com/xiaohuochai/p/8184989.html 数据结构之字典和散列表 https://www.cnblogs.com/xiaohuochai/p/8183020.html 数据结构之集合 https://www.cnblogs.com/xiaohuochai/p/8176248.html 数据结构之链表 https://www.cnblogs.com/xiaohuochai/p/8175716.html 数据结构之队列 https://www.cnblogs.com/xiaohuochai/p/8174854.html 数据结构之栈 https://www.cnblogs.com/xiaohuochai/p/8174742.html 设计模式 单例模式 观察者模式 算法 算法复杂度 https://www.cnblogs.com/xiaohuochai/p/8203717.html 算法模式 https://www.cnblogs.com/xiaohuochai/p/8203142.html 搜索算法 https://www.cnblogs.com/xiaohuochai/p/8203058.html 排序算法 https://www.cnblogs.com/xiaohuochai/p/8198275.html 代码管理工具 git学习总结 git分支管理策略 github上如何进行PR(pullRequest)操作 Git Commit Message Git Hook 浏览器 深入理解浏览器工作原理 chrome devTools 使用教程 渲染机制 缓存机制 资源预加载preload和资源预读取prefetch简明学习https://www.cnblogs.com/xiaohuochai/p/9183874.html 使用chrome开发者工具中的performance面板解决性能瓶颈 https://www.cnblogs.com/xiaohuochai/p/9182710.html 使用chrome开发者工具中的network面板测量网站网络性能 https://www.cnblogs.com/xiaohuochai/p/9182165.html Linux 常用bash命令 Linux用户组、文件权限 vim学习 shell编程入门 操作系统理解：unix、linux、windows linux常用命令级管理 计算机基础 base64原理及引用 unicode编码 时间格式说明 虚拟主机 代理、网关、隧道 Web Components 可重用网络组件 Custom Elements 独立的网络组件 Shadow DOM 前端框架 【react】 react实战项目开发(1) 搭建react开发环境初始化项目（Create-react-app） react实战项目开发(2) react基础语法之JSX [react实战项目开发() react组件条件渲染、列表渲染等基础语法] [react实战项目开发() react组件状态与组件生命周期] [react实战项目开发() react组件之间的传值] [react实战项目开发() react事件处理] [react实战项目开发() react实战todolist小项目] [react实战项目开发() react表单] [react实战项目开发() react类型检查] [react实战项目开发() react通过Refs访问DOM] 【vue】 vue 实战视频学习 vue 基础 vue 全家桶搭建开箱即用的脚手架 vue 实战xxx vue 是如何实现双向绑定的 vue 源码阅读学习 vue 相关深入学习 vuex 之类的 【AngularJS】 AngularJS基础 【Angular】 Angular 项目初始化 ng 常用命令 Angular 模板语法 Angular 生命周期 Angular 组件交互 Angular 样式 Angular 指令 Angular 管道 Angular 事件处理 NgModule Angular 依赖注入(DI)与服务 service 详解 [进阶]依赖注入实战 [进阶] angular 中组件的引用 Angular HttpClient Angular 内容投影 ng-content Angular 操作 DOM 详解 表单 模板驱动表单 wip:【表单】响应式表单 自定义表单验证器 【表单】自定义表单控件 重难点 @Input() or @Inject() 该如何选择 @Input()的 set or ngOnChanges() 【rxjs】 rxjs 简介 【路由】 UI-Router 基础 UI-Router Features UI-Router State对象 UI-Router params参数详解 UI-Router 常用指令 UI-Router 搭建一个简单的后台管理 【状态管理】 Mobx redux https://www.cnblogs.com/xiaohuochai/p/8652683.html 【visual DOM】 diff算法 【框架的重点难点】 vue 和 react 的区别 实现一个简单的 mvvm 框架 服务端渲染方案SSR 编写简单版的UI组件库 网站PWA升级https://www.cnblogs.com/xiaohuochai/p/9173959.html 单元测试 单元测试原则以及在开发中的作用 常见测试框架以及工具使用 TDD理论以及操作原则 TDD与BDD比较 TDD实践 前端构建 gulp webpack webpack基础 webpack实战 webpack Tree-shaking深入学习 抽象语法树AST 手写一个plugin rollup.js 实现一个打包工具 性能优化 前端性能优化的七大手段https://www.cnblogs.com/xiaohuochai/p/9178390.html 图片优化https://www.cnblogs.com/xiaohuochai/p/9183454.html 前端安全 跨域问题 跨站脚本攻击（XSS） 富文本编辑器如何解决XSS问题 CSRF攻击 oAuth2.0 前端监控 前端架构 如何进行技术方案选型 计算机图形 canvas svg svg 基本形状及样式设置 svg 文本 svg 路径 svg 辅助标签 svg 视野 svg 坐标系统及图形变换 svg 渐变 3D 常用工具 Homebrew yarn lerna 插件库 chart.js 实战配置、插件编写 jquery jquery如何编写插件 jquery幻灯片插件 jquery Deferred 对象 源码阅读 underscore underscore源码-内部方法 underscore源码-外部方法 ant-design 源码 checkbox的实现 发布 使用jenkins进行前端项目自动部署 写的更优雅 zc 【作业】 setTimeout和setInterval 幻灯片插件 用代码写个日记 【周报】 zc-第一周-周报 zc-第二周-周报 zc-第三周-周报 【内容core】 1、前端的自我修养 2、前端框架 3、前端规范 4、图片知多少 5、浏览器基础 IDEA IDEA快捷键 实战 积累一个自己的类库 使用react或者vue实现一个简易版的组件库 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-30 20:06:01 "},"core.html":{"url":"core.html","title":"core","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:30:01 "},"该如何进行学习.html":{"url":"该如何进行学习.html","title":"该如何进行学习","keywords":"","body":"前言 随着学习的知识越来越多，如果没有一套有效的方式，知识库会越来越混来，导致学的越多却一点都记不住，本文将边思考边总结一套适合自己的学习方式 好的习惯 针对重要的知识每月输出2篇原创文章。 一旦有知识点遗忘，马上翻看笔记，如果没有笔记则把该知识点列为优先级最高的学习状态。 能进行绘图理解的知识点，请尽量绘图，大脑对图形更加有记忆点。 为了能写出一篇好文章好去查阅更多资料，追本溯源的进行学习。 写一篇文章之前，务必要先列提纲，切不可想到哪里写到哪里。 笔记   选择做笔记应该是最好管理知识的方式了，正如以前小时候读书借助笔记一样，但是现在的知识不太一样了，有丰富的代码、图片、案例等东西。那么我们所需要的工具则会从之前的纸质笔记本进行提升到现在的网络工具。   可以多人协作，当然自己在多台电脑上可以进行操作笔记，方便随时进行翻阅记忆，无需自己折腾服务器之类的   于是乎选择了“showdoc”，更多的希望以该形式为主导的去积累自己的知识库，当积累到一定程度，便可以对例如“稀土掘金”，“segmentFault ” 等有人气有流量的网站去发表自己的原创博客。这应该也是所谓的“厚积薄发”吧，虽然很希望自己写的文章有人看，有人评价，但是更加希望写的文章是原创的且有质量的。 【showdoc】 主要用来组织自己的核心知识库 基础知识库组织，由于目录结构清晰因此方便在线搜索、随时查阅、提升知识稳固度。 工作驱动常用的文档编写，例如angular，react在实践过程可以积累到很多常用的方法，但是这些在官方文档是没有体现出来的，所以就需要自己记录下来。 公司项目的一些特有开发流程之类的笔记 【博客网站】  上面已经提到了，这些网站更加适合发表原创的，有中等或以上质量的文章，这是对自我的一个要求，宁缺毋滥，切莫害人害己 常用网站： segmentFault 稀土掘金 简书 博客园 架构   不论做大小事情，凡是先做好规划再行动也是稳妥的做成一件事情的先驱条件，例如马上要开始一个项目，我们就要对项目进行规划分类成一个一个小块，然后定好一个目标节点时间，定好每日应该当完成的工作量，以保证项目在如期的进度完成。 从此可以引申，大到人生规划，小至事件规划，都需要良好的架构进行支撑 个人规划 2019年唯一目标：  全面抓基础，仔仔细细学习前端的基础知识，力争做到不论项目多忙，每日一小文； 希望在2019年12月31日可以完成 html, css, js, node.js, 网络协议等等基础内容(以目录为标准)   2019年更加希望全家人身体健康，儿子快快乐乐长大。   ----2019年5月2日早5:20 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-25 13:21:43 "},"博客使用方法.html":{"url":"博客使用方法.html","title":"博客使用方法","keywords":"","body":"文章状态 有疑问：todo:problem 进行中：wip markdown 换行： 连续两个以上空格 使用html语言换行标签： 首行缩进两个字符：(每个表示一个空格，连续使用两个即可） &ensp; 半角的空格 &emsp; 全角的空格 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:24:03 "},"学习资源收藏.html":{"url":"学习资源收藏.html","title":"学习资源收藏","keywords":"","body":"前端面试 前端面试手册 掘金小册面试 常用查询网站 MDN caniuse 印记中文 lion实例 学习资源 个人博客) 学习资源 掘金小册 Angular 4.x 修仙之路 收藏文章 JavaScript深入系列 九种跨域方式实现原理（完整版） 前端下载总结 JavaScript 复杂判断的更优雅写法 逐行阅读redux源码（一) createStore 前端 H5 横屏 独特处理方案详解 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:22:28 "},"gitbook的使用以及快速部署.html":{"url":"gitbook的使用以及快速部署.html","title":"gitbook的使用以及快速部署","keywords":"","body":"前言 本文主要介绍如何使用 gitbook 并且发布到github pages中 安装 安装前需要自行安装node.js sudo npm install gitbook -g 一键上传命令 gitbook build && git add . && git commit -m \"message\" && git push && gh-pages -d _book 使用 1、创建一个git仓库 2、拉取git仓库 git clone https://github.com/shiyou00/book.git cd book/ 3、初始化gitbook gitbook init 初始化 gitbook serve 启动服务 4、打开界面 http://localhost:4000 目录结构 $ tree book/ book/ ├── README.md └── SUMMARY.md 0 directories, 2 files 可以看到一个初始化的书籍已经出现了 发布到 github pages 1、推送代码到git仓库 git add . git commit -m \"add pages\" git push 2、安装工具 sudo npm install -g gh-pages 3、执行gitbook build 把书籍打包到_book目录下 4、执行命令gh-pages -d _book 至此就发布成立可以打开相应的链接：Your site is published at https://shiyou00.github.io/book/ 好了已经成功部署到github pages中托管了，以后可以直接线上访问了，非常方便。 gitbook的使用教程 gitbook的使用教程 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-06 17:04:15 "},"English.html":{"url":"English.html","title":"English","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 07:32:34 "},"syntax.html":{"url":"syntax.html","title":"syntax","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 07:40:45 "},"word.html":{"url":"word.html","title":"word","keywords":"","body":"common word implement vt. 实施，执行；实现，使生效 n. 工具，器具；手段 wrap vt. 包；缠绕；隐藏；掩护 vi. 包起来；缠绕；穿外衣 n. 外套；围巾 trick n. 诡计；恶作剧；窍门；花招；骗局；欺诈 vt. 欺骗；哄骗；装饰；打扮 vi. 哄骗；戏弄 adj. 特技的；欺诈的；有决窍的 n. (Trick)人名；(英)特里克 attempt n. 企图，试图；攻击 vt. 企图，试图；尝试 major adj. 主要的；重要的；主修的；较多的 n. [人类] 成年人；主修科目；陆军少校 vi. 主修 issue n. 问题；流出；期号；发行物 vt. 发行，发布；发给；放出，排出 vi. 发行；流出；造成…结果；传下 plain adj. 平的；简单的；朴素的；清晰的 n. 平原；无格式；朴实无华的东西 adv. 清楚地；平易地 detect vt. 察觉；发现；探测 reference n. 参考，参照；涉及，提及；参考书目；介绍信；证明书 vi. 引用 vt. 引用 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 07:55:40 "},"statement.html":{"url":"statement.html","title":"statement","keywords":"","body":"常用语句记录 easier to identify by the user 更容易被用户识别 a couple of 三两个…；一对… step-by-step 循序渐进的 in summary 总之 break down 分解 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 09:11:01 "},"HTML.html":{"url":"HTML.html","title":"HTML","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:30:14 "},"HTML基础语法（HTML简介，HTML文档声明）.html":{"url":"HTML基础语法（HTML简介，HTML文档声明）.html","title":"HTML 基础语法（HTML简介，HTML文档声明）","keywords":"","body":"HTML 概念介绍 【概念】 (Hyper Text Markup Language)超文本标记语言，是用来描述网页的一种语言 超文本(Hyper Text):不只包括文本，也可以包括图片、链接、音乐、视频等非文本元素 标记语言(Markup Language):标记语言是一套标记标签，HTML使用标记标签来描述网页 【标签】 单标签： 双标签： HTML标签对大小写不敏感，但要全小写 【属性】标签的属性 常用属性： class 类 id 元素ID style 元素的行内样式 title 元素的额外信息，可在工具提示中显示 【元素】HTML元素以开始标签起始，以结束标签终止，元素的内容是开始标签与结束标签之间的内容。 【文档】HTML文档被称为网页，由嵌套的HTML元素构成 【注释】注释是在HTML插入的描述性文本，用来解释该代码或提示其他信息。 ps: 注释只出现在代码中，不会在页面中显示；且注释不可嵌套 HTML文档声明 HTML文档通常以类型声明开始，该声明将帮助浏览器确定其尝试解析和显示的HTML文档类型。 特点 文档声明必须是HTML文档的第一行、且顶格显示，对大小写不敏感。因为任何放在DOCTYPE前面的东西，比如批注或XML声明，会令IE9或更早期的浏览器触发怪异模式(后面的渲染模式会介绍) 由于文档类型声明不是标签，因此不应具有关闭标签 【HTML5】 在HTML5之前，文档声明一般有三种类型：严格型strict、过渡型transitional、框架frameset 严格型DTD包含所有HTML元素和属性，但不包含展示性的和弃用的元素(如font)；而过渡型或宽松型(loose)则包含展示性和弃用的元素 【HTML4.01】（1999） 【XHTML1.0】（2000） 【DTD】  DTD称为文档类型定义，它可以定义合法的XML文档构建模块，它使用一系列合法的元素来定义文档的结构。在HTML中，DTD使用XML定义了HTML标签规范   由于HTML5不基于SGML，所以不需要引用DTD。但是需要doctype来启用标准模式(后面的渲染模式会介绍)。HTML5的语法元素来自SGML、HTML、XHTML1.X，使它成为一种有自己规则的合成语言 【渲染模式】  在很久以前的网络上，页面通常有两种版本：为网景(Netscape)的Navigator准备的版本以及为微软(Microsoft)的Internet Explorer准备的版本。当W3C创立网络标准后，为了不破坏当时既有的网站，浏览器不能直接起用这些标准。因此，浏览器采用了两种模式，用以把能符合新规范的网站和老旧网站区分开。   浏览器排版引擎有三种模式：怪异模式(Quirks mode)、接近标准模式(Almost standards mode)以及标准模式(Standards mode)。在怪异模式下，排版会模拟Navigator4与Internet Explorer 5的非标准行为。为了支持在网络标准被广泛采用前，就已经建好的网站，这么做是必要的。在标准模式下，行为即由HTML与CSS的规范描述的行为。在接近标准模式下，只有少数的怪异行为被实现   对HTML文档来说，浏览器使用文档开头的DOCTYPE来决定用怪异模式处理或标准模式处理。如果文档中没有DOCTYPE将触发文档的怪异模式。怪异模式最明显的影响是会触发怪异盒模型。在CSS中盒模型被分为两种，第一种是W3C的标准模型，第二种是怪异盒模型。不同之处在于怪异盒模型的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸 小结   通过本节的内容，我们初步了解了什么是HTML，并且同时了解了HTML的文档头的声明，以及标准模型和怪异模型是通过文档头的定义来触发 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:32:17 "},"HTML元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则）.html":{"url":"HTML元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则）.html","title":"HTML元素（整体结构，块级元素，内联元素，结构元素，交互元素，元素嵌套规则）","keywords":"","body":"HTML整体结构解释 ﻿ // 文件应以“”首行顶格开始，推荐使用“” // 必须声明文档的编码charset，且与文件本身编码保持一致，指定字符编码的 meta 必须是 head 的第一个直接子元素。推荐使用UTF-8编码 // 页面title是不可缺少的一项，title 必须作为 head 的直接子元素，并紧随 charset 声明之后 Document ﻿ // 设置视口 // 引入 CSS 时必须指明 rel=\"stylesheet\" // link标签必须在head标签中引入 ﻿ // 1. js引入要放在body的最下方(防止页面阻塞) 2. 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。这是因为使用 protocol-relative URL 引入 CSS，在 IE7/8 下，会发两次请求。是否使用 protocol-relative URL 应充分考虑页面针对的环境 ﻿ HTML元素 块级元素 【h1, h2, h3, h4, h5, h6】含义：标题元素分为六个等级的标签注意：h1 在一个HTML中最好只出现一次(seo方面) 【p】含义：段落元素 【div】含义：块级空元素 【hr】含义：分割元素 【pre】含义：预定义格式文本在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符(比如空格和换行符)都会显示出来，通常表示已排版的内容，如代码块和字符画等 【blockquote】含义：HTML块级引用元素代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进。若引文来源于网络，则可以将原内容的出处URL地址设置到cite特性上，若要以文本的形式告知读者引文的出处时，可以通过元素 【address】含义：联系信息骨架类：html body表单类：form fieldset output legend optgroup option列表类：ul ol li dl dd dtHTML5新增结构标签：article aside header footer nav sectionHTML5新增多媒体：figure figcaptionHTML5新增功能型：summary details 内联元素 ﻿ 通用容器：span强调重要：em strong文字间隔：i(斜体) b(粗体)不精确文字：s(在HTML5中重新定义为有错的、过时的、不被建议使用的文本，常用于表示价格变动等)高亮显示：mark次要评论：small术语处理：dfn(定义术语) abbr(缩写词)引用：cite(表示作品标题的引用，可以是书影音画等) q(表示短引用，常用于引用别人说的话，用引号可以表达等价语义)换行：br wbr(指定单词可以换行的位置)上下标：sup sub文本删改：ins(文档中插入的内容) del(文档中删除的内容)特定时间：time(表示日期)注音标识：ruby(ruby标签定义注音标识，多用于CJK文字，CJK是指中日韩统一表意文字(Chinese、Japanese、Korean)) rt(标记文字) tp(标记括号) 复制代码 汉 ( hàn ) 语 ( yǔ ) 文字方向：bdi(忽略周围文字方向的文字) bdo(覆盖两种方向的设置，允许显式设置方向，并覆盖所有其他当前方向) When rendered by a browser, these words will appear as 'sdroweseht' 代码：code(计算机代码) kbd(键盘码) samp(计算机例子代码) tt(打字机代码) var(变量) ﻿ 结构元素 section：表示文档中的一个区域(或节)，是区块级通用元素article：表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构。aside：表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。nav：HTML导航栏()描绘一个含有多个超链接的区域，这个区域包含转到其他页面，或者页面内部其他部分的链接列表header：表示页面头部或区块头部footer：表示最近一个章节内容或者根节点(sectioning root)元素的页脚main(IE不支持)：main元素()呈现了文档或应用的主体部分。 ﻿ ﻿ 交互元素(浏览器的支持度太低) details ： 主要用于描述文档或文档某个部分的细节dialog ：用来定义对话框或窗口，且该对话框位于窗口的水平居中位置 ﻿ HTML 元素嵌套规则 1、块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素例： —— 对 —— 对 —— 错 ﻿ 2、块级元素不能放在里面包括p本身 —— 错 —— 错 ﻿ 3、有几个特殊的块级元素只能包含内联元素，不能再包含块级元素，这几个特殊的标签是 h1、h2、h3、h4、h5、h6、p、dt ﻿ 4、a 标签可以嵌套块级元素 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:18:28 "},"HTML属性.html":{"url":"HTML属性.html","title":"HTML 属性","keywords":"","body":"HTML 属性 属性 【class】规定元素的一个或多个类注意: 类不能以数字开头 class = \"classA classB\" // 多个类的写法 ﻿ 【id】规定元素的唯一标识注意：若浏览器中出现多个id名的情况，CSS样式对所以该id名的元素都生效，但javascript脚本仅对第一个出现该id名的元素生效 【dir】文字的方向值：ltr/rtl/auto 【lang】HTML的lang属性可用于标记网页或部分网页的语言。也就是说lang这个属性不仅仅可以用在html标签上 en:英文 zh:中文 zh-CN：简体中文 ﻿ ﻿ You'd say that in Chinese as 文献情报中心. ﻿ 有什么作用？简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。比如可以根据根据lang属性来设定不同语言的css样式，或者字体 告诉搜索引擎做精确的识别 让语法检查程序做语言识别 帮助翻译工具做识别 帮助网页阅读程序做识别等... 【style】设置行间样式 ﻿ 【tabindex】规定元素的tab键次序（1开始） cc bb aa ﻿ 【title】规定关于元素的额外信息，鼠标移到元素上时显示一段提示文本 百度 ﻿ HTML5新增的属性 【contenteditable】作用：指定是否可以在浏览器里编辑内容值：true/false注意：设置document.designMode ='on'时，页面的任意位置都可以编辑；使用contenteditable ='true'则只对具体元素和其包含的元素起作用移动端：移动端ios5以及android3之后才支持该属性 【data-*】作用：用于存储页面或应用程序的私有定制数据注意：属性名不应包含任何大写字母，且在前缀\"data-\"之后必须有至少一个字符；属性值可以是任意字符串使用：可以在所有浏览器中使用getAttribute方法来获取data-属性的值，也可以使用javascript中dataset属性访问data-属性的值，不过IE10-浏览器不支持dataset 【draggable】IE8- 不支持作用：用户是否可以拖动元素值：true/false/auto注意：链接和图像默认是可拖动的 【hidden】(IE7-不支持)作用：显示或隐藏该元素(与display:none的作用一样)值：hidden=\"\" || hidden= \"hidden\" 【spellcheck】(IE9-不支持)作用：规定是否对元素进行拼写和语法检查,对拼写错误的单词会在其下方出现红线范围：可编辑区域（表单或contenteditable元素）值：true/false注意：移动端支持不好 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:39:09 "},"HTML常用标签（a，img）.html":{"url":"HTML常用标签（a，img）.html","title":"HTML 常用标签（a，img）","keywords":"","body":"a元素 元素 (或HTML锚元素, Anchor Element)通常用来表示一个锚点/链接。但严格来说，元素不是一个链接，而是超文本锚点，可以链接到一个新文件、用id属性指向任何元素。如果没有元素没有href属性的话，可以作为原本链接位置的占位符，常用于home链接 [注意]任何文档流内容都可以被嵌套，只要不是交互内容类别(如按钮、链接等) 【href】href属性表示地址，共包括以下3种： 链接地址:百度 下载地址:下载测试 锚点: href:#id名 目录 内容 ﻿ href:页面地址#id名 足球比赛规则 ﻿ 手机号码： 在移动端，使用15012345678可以唤出手机拨号盘 href属性一定不要留空，若暂时不需要写地址，则写#或javascript:;。若href留空，会刷新页面 【href与src的区别】href(hypertext reference)指超文本引用，表示当前页面引用了别处的内容src(source)表示来源地址，表示把别处的内容引入到当前页面，相当于资源占位所以、、等应该使用src，而和应该使用href ﻿ 【target】target属性表示链接打开方式1、_self 当前窗口（默认）2、_blank 新窗口3、_parent 父框架集4、_top 整个窗口5、_framename 指定框架 【download】download属性用来设置下载文件的名称(firefox/chrome/opera支持) ﻿ test ﻿ 【注意事项】1、标签的文本颜色只能自身进行设置，从父级继承不到2、标签的下划线颜色跟随文本颜色进行变化3、标签不可嵌套标签 img 表示image图像，从技术上讲，标签并不会在网页中插入图像，而是从网页上链接图像。 标签创建的是被引用图像的占位空间。 【必须属性】1、src:地址2、alt:图像替代文本，供探索引擎抓取使用 【可选属性】1、height:图像高度2、width:图像宽度3、ismap:为图像定义为服务器端图像映射4、longdesc:与alt属性类似，提供多于1024字符的长文本描述5、usemap:为图像定义客户端图像映射 usemap = \"#\\元素的name或id属性\"6、srcset:指定图片的地址和对应的图片质量。属性格式：图片地址 宽度描述w 多个资源之间用逗号分隔。对于srcset里面出现了一个w单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用，当然，浏览器会自动选择一个最小的可用图片。但是，会发现随着浏览器窗口宽度变大，图片也在不断变大 [注意]浏览器会自动匹配最佳显示的图片，如果大图既然缓存了就用大图了，再缩小也不会变成小图了 7、sizes:用来设置图片的尺寸零界点，主要跟响应式布局打交道。属性格式：媒体查询 宽度描述(支持px)，多条规则用逗号分隔 [注意]如果加上sizes属性，会发现，随着浏览器宽度变大，图片一直保持其初始尺寸。所以，应该sizes和srcset两个属性配合使用 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:50:45 "},"HTML表格.html":{"url":"HTML表格.html","title":"HTML 表格","keywords":"","body":"标准表格 Monthly savings Header 1 Header 2 row 1, cell 1 row 1, cell 2 row 1, cell 2 row 2, cell 1 row 2, cell 2 标签解释 定义表格 定义表格的表头 定义表格的行 定义表格单元 定义表格标题 定义表格列的组 定义用于表格列的属性 定义表格的页眉 定义表格的主体 定义表格的页脚 属性解释 rowspan = \"n\" 纵向合并单元格colspan = \"n\" 横向合并单元格 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 10:52:20 "},"HTMLiframe使用postMessage方法进行跨文档消息传递.html":{"url":"HTMLiframe使用postMessage方法进行跨文档消息传递.html","title":"HTML iframe 使用postMessage方法进行跨文档消息传递","keywords":"","body":"什么是iframe HTML内联框架元素 表示嵌套的浏览上下文，有效地将另一个HTML页面嵌入到当前页面中。 【src】嵌套页面的URL地址。使用遵守同源策略的 'about:blank' 来嵌套空白页。 同源策略 同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 协议相同: http https ftp 指的是协议 域名相同: www.baidu.com www.taobao.com 指的是域名 端口相同: 默认是80端口 8800 8899这个指的是端口 https://www.baidu.com:80（80是默认的可以省略） 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） ﻿ 跨文档消息传递 跨文档消息传送(cross-document messaging)，有时候简称为 XDM，指的是在来自不同域的页面间 传递消息。例如，www.wrox.com 域中的页面与位于一个内嵌框架中的 p2p.wrox.com 域中的页面通信。 在 XDM 机制出现之前，要稳妥地实现这种通信需要花很多工夫。XDM 把这种机制规范化，让我们能 既稳妥又简单地实现跨文档通信。 XDM 的核心是 postMessage()方法。在 HTML5 规范中，除了 XDM 部分之外的其他部分也会提 到这个方法名，但都是为了同一个目的:向另一个地方传递数据。对于 XDM 而言，“另一个地方”指的 是包含在当前页面中的元素，或者由当前页面弹出的窗口。 postMessage postMessage()方法接收两个参数:一条消息和一个表示消息接收方来自哪个域的字符串。第二 个参数对保障安全通信非常重要，可以防止浏览器把消息发送到不安全的地方 var iframeWindow = document.getElementById(\"myframe\").contentWindow; iframeWindow.postMessage(\"A secret\", \"http://www.wrox.com\");// 第一个参数如果需要传入对象请JSON.stringify() 最后一行代码尝试向内嵌框架中发送一条消息，并指定框架中的文档必须来源于\"http:// www.wrox.com\"域。如果来源匹配，消息会传递到内嵌框架中;否则，postMessage()什么也不做。﻿ 如果传给 postMessage()的第二个参 数是\"*\"，则表示可以把消息发送给来自任何域的文档，但我们不推荐这样做。﻿ 接收到 XDM 消息时，会触发 window 对象的 message 事件。这个事件是以异步形式触发的，因此 从发送消息到接收消息(触发接收窗口的 message 事件)可能要经过一段时间的延迟。触发 message 事件后，传递给 onmessage 处理程序的事件对象包含以下三方面的重要信息 data:作为 postMessage()第一个参数传入的字符串数据。 origin:发送消息的文档所在的域，例如\"http://www.wrox.com\"。 source:发送消息的文档的 window 对象的代理。这个代理对象主要用于在发送上一条消息的 窗口中调用 postMessage()方法。如果发送消息的窗口来自同一个域，那这个对象就是 window。 window.onmessage = function(event){ //确保发送消息的域是已知的域 if (event.origin == \"http://www.wrox.com\"){ //处理接收到的数据 processMessage(event.data); //可选:向来源窗口发送回执 event.source.postMessage(\"Received!\", \"http://p2p.wrox.com\"); } }; [注意]event.source 大多数情况下只是 window 对象的代理，并非实际的 window 对 象。换句话说，不能通过这个代理对象访问 window 对象的其他任何信息。记住，只通过这个代理调用 postMessage()就好，这个方法永远存在，永远可以调用。 ﻿ 兼容 支持 XDM 的浏览器有 IE8+、Firefox 3.5+、Safari 4+、Opera、Chrome、iOS 版 Safari 及 Android 版 WebKit。XDM 已经作为一个规范独立出来，现在它的名字叫 Web Messaging，官方页面是 http://dev.w3.org/html5/postmsg/。 小结 通过本文我学习了什么是iframe，以及iframe如何和父窗口进行数据通信 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:26:11 "},"HTML表单form元素介绍，input元素的常用type类型，input元素的常用属性.html":{"url":"HTML表单form元素介绍，input元素的常用type类型，input元素的常用属性.html","title":"HTML 表单(form元素介绍，input元素的常用type类型，input元素的常用属性)","keywords":"","body":"前言 表单是网页与用户的交互工具，由一个元素作为容器构成，封装其他任何数量的表单控件，还有其他任何元素里可用的标签 表单能够包含、、、、、等表单控件元素 [注意]表单里嵌套表单是不允许的 ﻿ form元素 form元素有accept-charset、action、autocomplete、enctype、method、name、novalidate、target共8个属性，其中action和name属性为必需项 var oForm = document.forms.test; console.log(oForm.method);//get 【字符集】accept-charset 属性是一个空格分隔的字符集列表，规定了服务器处理表单数据所接受的字符集。accept-charset 属性允许指定一系列字符集，服务器必须支持这些字符集，从而得以正确解释表单中的数据。该属性的值是用引号包含字符集名称列表。 【提交地址】action属性规定提交表单时，向何处发送表单数据；如果忽略这个属性，表单会重定向到表单所在的URL。这个值可以被 或者 元素中的 formaction属性重载(覆盖) 【数据编码】enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。大多数情况下该属性不需要设置。这个值可以被 或者 元素中的 formenctype属性重载(覆盖)。当 method属性值为 post时， enctype是提交form给服务器的内容的 MIME 类型 。可能的取值有: application/x-www-form-urlencoded 　　在发送前编码所有字符（默认） multipart/form-data 　　　　　　　　 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 text/plain 　　　　　　　　　　　　 空格转换为 \"+\" 加号，但不对特殊字符编码 【数据发送】表单可以用两种方式(method)发送数据：GET和POST，默认为GET方法。这个值可以被 或者 元素中的 formmethod属性重载(覆盖) 【POST方法】　　如果采用POST方法，浏览器将会按照下面两步来发送数据。首先，浏览器将与action属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器　　在服务器端，一旦POST样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数 【GET方法】如果采用GET方法，浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的action URL之后。这两者之间用问号进行分隔。 【自动完成】autocomplete是HTML5新增的一个属性，规定表单是否应该启用自动完成功能。当用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项 [注意]IE浏览器不支持该属性，只有元素拥有name属性，该属性才有效 //该属性默认为on，当设置为off时，规定禁用自动完成功能 ﻿ input元素的常用type类型 ﻿ 传统输入控件：button：定义可点击按钮checkbox：复选框file：文件上传hidden：隐藏的输入字段（常常用于附带的一些内容传递给后台，但是又不想让用户看见的）image：定义图像形式的提交按钮password：密码输入radio：单选按钮reset：重置按钮submit：表单提交text：单行的文字输入 checkbox 单选 H5新增控件： color 　　　　　　 定义调色板 tel 　　　　 　　 定义包含电话号码的输入域 email 　　　 　　定义包含email地址的输入域 url 　　　　 　　 定义包含URL地址的输入域 search 　　　　　 定义搜索域 number 　　 　　 定义包含数值的输入域 range 　　 　　 定义包含一定范围内数字值的输入域 date 　　　　　 定义选取日、月、年的输入域 month 　　 　　 定义选取月、年的输入域 week 　　　　　 定义选取周、年的输入域 time 　　 　　 定义选取月、年的输入域 datetime 　　　 定义选取时间、日 月、年的输入域(UTC时间) datatime-local 　 定义选取时间、日 月、年的输入域(本地时间) H5新增的控件在使用前可以去can i ues中查看下兼容问题 ﻿ ﻿ input元素的常用属性 传统属性：accept、alt、checked、disabled、maxlength、name、readonly、size、src、type、value﻿ H5新增属性：autocomplete、autofocus、form、formaction、formenctype、formmethod、formnovalidate、formtarget、height、list、max、min、multiple、novalidate、pattern、placeholder、required、step、width 【name】name属性用于规定input元素的名称，用于对提交到服务器后的表单数据进行标识，或者在客户端通过javascript引用表单数据 [注意]只有设置了name属性的表单元素才能在提交表单时传递它们的值 【type】type属性用来规定input元素的类型 【accept】accept属性用来规定能够通过文件上传进行提交的文件类型。理论上可以用来限制上传文件类型，然而它只是建设性的，并很可能被忽略，它接受逗号分隔的MIME类型 [注意]该属性只能与type=\"file\"配合使用 ﻿ 【alt】alt属性为图像输入规定替代文本，功能类似于image元素的alt属性，为用户由于某些原因无法查看图像时提供备选信息 [注意]alt属性只能与type=\"image\"的input元素配合使用 【checked】checked属性规定在页面加载时应该被预先选定的input元素，也可以在页面加载后，通过javascript进行设置 [注意]checked属性只能与type=\"radio\"或type=\"checkbox\"的input元素配合使用 【disabled】disabled属性规定应该禁用input元素。被禁用的字段是不能修改的，也不可以使用tab按键切换到该字段，但可以选中或拷贝其文本 [注意1]disabled属性无法与type=\"hidden\"的input元素一起使用[注意2]对于IE7-浏览器必须设置为disabled=\"disabled\"，而不可以直接设置disabled，否则使用javascript控制时将失效 【readonly】readonly属性规定输入字段为只读。只读字段是不能修改的，但用户仍然可以使用tab按键切换到该字段，还可以选中或拷贝其文本readonly属性可与type=\"text\"或\"password\"的input元素配合使用 [注意]IE7-浏览器不支持使用javascript控制readonly属性 【maxlength】maxlength属性规定输入字段的最大长度，以字符个数计 [注意]该属性只能与type=\"text\"或type=\"password\"的input元素配合使用 ﻿ 【size】size属性对于type=\"text\"或\"password\"的input元素是可见的字符数；而对于其他类型，是以像素为单位的输入字段宽度 [注意]由于size属性是一个可视化的设计属性，推荐使用CSS来代替它 ﻿ ﻿ 【src】src属性作为提交按钮显示的图像的URL [注意]src属性只能且必须与type=\"image\"的input元素配合使用 ﻿ 【value】value属性为input元素设定值。对于不同的输入类型，value属性的用法也不同： type=\"button\"、\"reset\"、\"submit\"用于定义按钮上的显示的文本 type=\"text\"、\"password\"、\"hidden\"用于定义输入字段的初始值 type=\"checkbox\"、\"radio\"、\"image\"用于定义与输入相关联的值 [注意1]type=\"checkbox\"或\"radio\"必须设置value属性 [注意2]value属性无法与type=\"file\"的input元素一起使用 ﻿ ﻿ H5新增属性 【autocomplete】autocomplete属性可以在个别元素或整个表单上开启或关闭浏览器的自动完成功能。当用户在字段开始键入时，浏览器基于之前键入过的值，显示出在字段中填写的选项 autocomplete属性适用form元素以及以下类型的input元素：text、search、url、telephone、email、password、date pickers、range、color [注意]IE浏览器不支持该属性，只有元素拥有name属性，该属性才有效 【autofocus】autofocus属性规定在页面加载时，域自动地获得焦点autofous属性适用于button、input、keygen、select和textarea元素 ﻿ 【novalidate】novalidate属性规定在提交表单时不验证form或input域novalidate属性适用于form元素以及以下类型的input元素：text、search、url、telephone、email、password、date pickers、range、color [注意]IE9-浏览器不支持 【height】【width】用于规定image类型的input标签的图像高度和宽度(不常用) 【list】大多数输入类型包含一个属性list，它和一个新元素datalist结合使用，这个元素定义当在表单控件输入数据时可用的一个选项列表。datalist元素自身不会在页面显示，而是为其他元素的list属性提供数据 list属性适用于form元素以及以下类型的input元素：text、search、url、telephone、email、password、date pickers、range、color [注意]IE9-浏览器及safari浏览器不支持 【min】【max】规定输入域所允许的最小值，最大值 【step】step属性为输入域规定合法的数字间隔 min、max、step属性适用于以下类型的input元素:date pickers、number、range ﻿ 【multiple】multiple属性规定按住ctrl按键，输入字段可以选择多个值该属性适用于type=\"email\"和\"file\"的input元素 [注意]该属性IE9-浏览器不支持 ﻿ 打开文件多选 关闭文件多选 btn1.onclick = function(){ test.setAttribute('multiple',''); }; btn2.onclick = function(){ test.removeAttribute('multiple'); }; 【pattern】pattern属性规定用于验证input域的模式。模型pattern是正则表达式pattern属性适用于以下类型的input元素：text、search、url、tel、email、password [注意]IE9-浏览器及safari浏览器不支持 ﻿ 【placeholder】placeholder属性提供占位符文字，描述输入域所期待的值。占位符会在输入域为空时显示出现，在输入域获得焦点时消失 placeholder属性适用于以下类型的input元素:text、search、url、tel、email、password [注意]IE9-浏览器不支持 要修改placeholder的颜色需要使用::placeholder ::placeholder{color:green;} 【required】required属性规定必须在提交之前填写输入域(不能为空) required属性适用于以下类型的input元素：text、search、url、telephone、email、password、date pickers、number、checkbox、radio、file [注意]IE9-浏览器及safari浏览器不支持 ﻿ 【form】form属性规定输入域所属的一个或多个表单，form属性必须和所属表单的id form属性适用于所有input标签的类型，若需要引用一个以上的表单时，用空格分隔 [注意]IE浏览器不支持该属性，只有元素拥有name属性，该属性才有效 ﻿ 表单重写属性 表单重写属性允许重写form元素的某些属性设定。其中，formnovalidate适用于button或input元素，而其他属性适用于submit或reset的button或input元素 【formaction】重写表单的action属性 ﻿ First name: Last name: ﻿ 【formenctype】重写表单的enctype属性 ﻿ First name: ﻿ 【formmethod】重写表单的method属性 First name: Last name: ﻿ 【formnovalidate】重写表单的novalidate属性 ﻿ E-mail: ﻿ ﻿ 【formtarget】重写表单的target属性 ﻿ First name: Last name: 小结 通过本文我们学习了form元素及其常用属性，input常用的type类型和相关属性。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:02:52 "},"HTMLmeta标签,base标签.html":{"url":"HTMLmeta标签,base标签.html","title":"HTML meta标签,base标签","keywords":"","body":"HTML meta元素 标签(meta-information)用于提供页面有关的元数据，除了提供文档字符集、使用语言、作者等基本信息外，还涉及对关键词和网页等级的设定。通过设置不同的属性，元数据可以分为以下几种: // charset声明声明当前文档所使用的字符编码，但该声明可以被任何一个元素的lang特性的值覆盖。文档的编码一定要与文件本身的编码保持一致，否则会出现乱码，推荐使用UTF-8编码 // 关键词 // 描述 // 作者 // 版权 // 视口设置 // IE浏览器渲染 如果安装了GCF(Google Chrome Frame谷歌内嵌浏览器框架GCF)，则使用GCF来渲染页面，如果没有安装，则使用最高版本的IE内核进行渲染 // 如果是双核浏览器，则使用webkit内核渲染 // 让网页多少秒刷新 // 跳转到其他网页 // 可以用于设定网页的到期时间，一旦过期则必须到服务器上重新调用。需要注意的是必须使用GMT时间格式 // 用于设定禁止浏览器从本地机的缓存中调阅页面内容，用户无法脱机浏览 // 强制页面在当前窗口中以独立页面显示，可以防止自己的网页被别人当作一个frame页调用 【base标签】 // 用于指定文档里所有相对URL地址的基础URL，为页面上所有链接规定默认地址和默认打开方式。文档中的基础URL可以使用document.baseURI进行查询 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:03:23 "},"HTML条件注释规范.html":{"url":"HTML条件注释规范.html","title":"HTML 条件注释规范","keywords":"","body":"HTML 条件注释(hack常用) IE条件注释是微软从IE5开始就提供的一种非标准逻辑语句，作用是可以灵活的为不同IE版本浏览器导入不同html元素。很显然这种方法的最大好处就在于属于微软官方给出的兼容解决办法而且还能通过W3C的效验 【识别IE】 只在IE中会显示 【识别IE具体版本】 6 [if IE 6] 7 [if IE 7] 8 [if IE 8] 9 [if IE 9] // 只在IE7中显示 【IE范围】 gt 大于(greater than) gte 　大于等于(greater than or equal) lt 小于(less than) lte 小于等于(less than or equal) // 小于等于IE7识别 识别非IE 实际上识别的是IE10+浏览器和其他非IE浏览器 实际应用中我们常常用来判断IE版本来引入相应的JS进行hack，或者通过不同IE版本引入不同的jquery版本 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:32:18 "},"【重难】深入理解HTML表格.html":{"url":"【重难】深入理解HTML表格.html","title":"[重难] 深入理解HTML表格","keywords":"","body":"前言 在CSS出现之前，table元素常常用来布局。这种做法在HTML4之后不再推荐使用。而现在有些矫枉过正，使用table展示数据都可能会被说不规范。本文将详细介绍HTML表格table table 【默认样式】 //IE7-浏览器不支持border-spacing table{ 　　border-collapse: separate; 　　border-spacing: 2px; 　　border: 1px solid gray; } 【属性】1、border(在html5中，border只能为\"1\"或\" \")(html5已废弃) border=\"0\"//没有边框 border=\"8\"//8像素宽的边框 2、cellpadding(px/%)(html5已废弃)规定单元边界与单元内容之间的间距 3、cellspacing(px/%)(html5已废弃)规定单元格之间的间距 4、summary(html5已废弃)表格内容的摘要 5、width(html5已废弃)表格宽度 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 6、frame(IE7-浏览器不能正常显示)(html5已废弃) void 不显示外侧边框。 above 显示上部的外侧边框。 below 显示下部的外侧边框。 hsides 显示上部和下部的外侧边框。 vsides 显示左边和右边的外侧边框。 lhs 显示左边的外侧边框。 rhs 显示右边的外侧边框。 box 在所有四个边上显示外侧边框。 border 在所有四个边上显示外侧边框。 7、rules(IE7-浏览器不能正常显示)(html5已废弃) none 没有线条。 groups 位于行组和列组之间的线条。 rows 位于行之间的线条。 cols 位于列之间的线条。 all 位于行和列之间的线条。 【样式】1、border-spacing 可替代HTML属性cellspaing(IE7-不支持)[注意]只有当border-collapse值为separate时，该样式才有效 border-spacing: x y //x:水平间距 y:垂直间距。若只有一个值，则水平间距和垂直间距相等。注意，不可为负值。 2、empty-cells(IE7-不支持) empty-cells: hide 不在空单元格周围绘制边框和背景，类似于hidden效果 empty-cells: show(默认) 在空单元格周围绘制边框和背景 3、CSS实际上有两种截然不同的边框模型。按布局术语来说，如果单元格相互之间是分隔的，是分隔边框模型在起作用；另一种是合并边框模型，单元格边框会相互合并。 border-collapse:separate; [注意]在分隔边框模型中，不能为行、行组、列和列组设置边框。 border-collapse:collapse; 　　在合并边框模型中，表格无法设置内边距padding，且单元格边框之间也没有间距。单元格之间的边框会在单元格间的假想表格线上居中，且表格宽度只包含表格边框的一半 【边框合并的规则】　　a、某个合并边框的border-style为hidden，它会优先于所有其他合并边框。这个位置上的所有边框都隐藏　　b、某个合并边框的border-style为none，它的优先级最低　　c、宽边框优先于窄边框　　d、若宽度相同，double\\solid\\dashed\\dotted\\ridge\\outset\\groove\\inset，优先级逐渐降低　　e、若样式也相同，cell\\row\\row group\\column\\column group\\table，优先级逐渐降级 4、table-layout table-layout:auto//自动宽度布局 【自动布局的步骤】 　　a、对于一列中的单元格，计算最小和最大单元格宽度 　　b、对于各一列，计算最小和最大列宽 　　c、若单元格跨列，最小列宽之和要等于跨列单元格最小单元格宽度 table-layout:fixed//固定宽度布局 [注意]对于表单元格的长文本来说，使用word-wrap或word-break来强制换行，使用text-overflow实现文本溢出控制都需要设置table-layout:fixed 【固定布局的步骤】 　　a、width属性值不是auto的所有列元素会根据width值设置该列的宽度 　　b、如果一个列的宽度为auto，则根据该单元格设置此列宽度，如果跨多列，则宽度平均分配 　　c、如果列宽度仍为auto，则自动确定其大小，使其宽度尽可能相等 　　[注意]使用固定宽度布局，浏览器可以更快地计算出表格的布局 5、vertical-align vertical-align: top;//顶端对齐 vertical-align: bottom;//底端对齐 vertical-align: middle;//中间对齐 vertical-align: baseline(默认);//基线对齐 [注意]vertical-align:sub\\super\\text-top\\text-bottom应用到表格单元格时会被忽略 行 【】 行 table row 表头 table head 表格数据 table data 【默认样式】 th{ padding: 1px; text-align: center; font-weight: bold; } td{ padding: 1px; } 【属性】1、colspan　　规定单元格可纵跨的列数 2、rowspan　　规定单元格可横跨的行数 　　[注意]关于行的表格元素生成矩形框，这些框有内容、内边距和边框，但是没有外边距margin。表头呈现为居中的粗体文本 Month Savings Savings for holiday! January $100 $50 February $80 列 【】 -> column 列　　为表格中一个或多个列定义属性值 -> column group 列组　　对表格中的列进行组合，以便对其进行格式化 【属性】　　span　　规定col元素应该横跨的列数 【样式】 　　1、visibility:collapse　　该列或列组的所有单元格不显示(设置为其他值则无效) 　　2、border　　只有当border-collapse:collapse时，才能设置border 　　3、background　　只有当单元格及其行有透明背景时，列或列组的背景才可见 　　4、width　　定义列或列组的最小宽度 数字 中文 英文 1 一 a 2 二 b 其他表格元素 【】 表格页眉 表格主体 表格页脚 　　[注意]它们的出现次序是：thead、tfoot、tbody，这样浏览器就可以在收到所有数据前呈现页脚 【表格标题】 【默认样式】 caption{ text-align: center; } 【样式】 caption-side: top(默认) caption-side: bottom [注意]标签必须紧随标签之后，且只能对每个表格定义一个标题 　 北京天气 地区 天气 北京 都雾霾 城八区 雾霾 郊区 雾霾 display table{display: table;} thead{display: table-header-group;} tbody{display: table-row-group;} tfoot{display: table-footer-group;} tr{display: table-row;} td,th{display: table-cell;} col{display: table-column;} colgroup{display: table-column-group;} caption{display: table-caption;} [注意]IE7-浏览器不支持为HTML元素设置与表格有关的display值 匿名表格对象　　CSS定义了一种机制，将遗漏的组件作为匿名对象插入。详细插入规则如下： 　　1、如果table-cell元素的父元素不是table-row元素，则插入匿名table-row对象 　　2、如果table-row元素的父元素不是table、inline-table或table-row-group元素，则插入匿名table元素 　　3、如果table-column元素父元素不是table、inline-table或table-row-group元素，则插入匿名table元素 　　4、如果table-row-group、table-header-group、table-footer-group、table-column-group或table-caption的父元素不是table元素，则插入匿名table元素 　　5、如果table元素或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-column-group或table-caption，则插入匿名table-row元素 　　6、如果table-row-group、table-header-group、table-footer-group元素的子元素不是table-row元素，则插入匿名table-row元素 　　7、如果table-row元素的子元素不是table-cell元素，则插入匿名tabel-cell元素 插入一段不合符规范的代码 122 233 看下浏览器的HTML效果： 浏览器自动补上了tr 表格层 　　CSS定义了6个不同的层，对应表各个方面的样式都在其各自的层上绘制。默认地，所有元素背景都是透明的，如果单元格、行、列等没有自己的背景，则table元素的背景将透明这些内部元素可见。 row 1, cell 1 row 1, cell 2 row 2, cell 1 row 2, cell 2 边距设置 【】　　若处于分隔边框模型，margin和padding都可设置　　若处于合并边框模型，只可设置margin 【】　　margin和padding都不可设置 【】　　不可设置margin，但可以设置padding 【】　　margin和padding都可设置 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:07:33 "},"JavaScript中attribute和property的区别以及最佳实践.html":{"url":"JavaScript中attribute和property的区别以及最佳实践.html","title":"[重难] JavaScript中attribute和property的区别以及最佳实践","keywords":"","body":"前言 使用JavaScript操作DOM元素时往往涉及到两个概念：attribute 和 property。 document.getElementById('test').getAttribute('id') 、 $('#test').attr('id') 、 document.getElementById('test').id 和 $('#test').prop('id') 都能返回正确的id：\"test\"。这篇文章主要介绍一下 property 和 attribute 的区别以及如何使用。 Attribute 1、Attribute由HTML来定义，并不存在于DOM中，即：只要是HTML标签内定义的都是attribute。 document.getElementById('test').attributes; // 返回：[custom-attr=\"hello\", class=\"button\", id=\"test\"] 2、Attribute是String类型。对于上面的div，document.getElementById('test').getAttribute('custom-attr') 或 $('#test').attr('custom-attr') 都会返回string: \"1\"。 Property 1、Property属于DOM，DOM的本质就是JavaScript中的一个object。我们可以像操作普通object一样读取、设置property，property可以是任意类型。 document.getElementById('test').foo = 1; // 设置property：foo为number: 1 document.getElementById('test').foo; // 读取property，返回number：1 $('#test').prop('foo'); // jQuery读取property，返回number：1 $('#test').prop('foo', { age: 23, name: 'John' }); // jQuery设置property：foo为一个object document.getElementById('test').foo.age; // 返回number：23 document.getElementById('test').foo.name; // 返回string：\"John\" 2、非自定义attribute，如id、class、titile等，都会有对应的property映射。 document.getElementById('test').id; // 返回string：\"test\" document.getElementById('test').className; // 返回string：\"button\" document.getElementById('test').foo; // 返回undefined，因为foo是自定义attribute 注：由于 class 为JavaScript的保留关键字，所以通过property操作class时应使用 className。 3、非自定义的property或attribute的变化多数是联动的。 var div = document.getElementById('test'); div.className = 'red-input'; div.getAttribute('class'); // 返回string：\"red-input\" div.setAttribute('class','green-input'); div.className; // 返回string：\"green-input\" 4、带有默认值的attribute不随property变化而变化。 var input = document.getElementById('search'); input.value = 'foo2'; input.getAttribute('value'); // 返回string：\"foo\" 最佳实践 使用JavaScript操作property更为方便、快捷，并且property支持各种不同的类型，尤其是对于布尔类型的attribute的自动转换，如：checked、disabled、selected等。 推荐用法 // 获取id document.getElementById('test').id; // 更改class document.getElementById('test').className = 'red'; // 获取、设置状态 document.getElementById('test').checked; document.getElementById('test').checked = true; $('#test').prop('checked'); $('#test').prop('checked', true); 不推荐的用法 // 获取id document.getElementById('test').getAttribute('id'); // 更改class document.getElementById('test').setAttribute('class', 'red'); Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-28 17:54:04 "},"【重难】table单元格中文字过长如何进行省略table-layout.html":{"url":"【重难】table单元格中文字过长如何进行省略table-layout.html","title":"[重难] table单元格中文字过长如何进行省略 table-layout","keywords":"","body":"前言 最近在项目中碰到了，需要在表格样式中对td立面进行过长省略处理，但是表格又是100%自适应的，td又是百分比的宽度，一时显得无从下手了，这篇文章我们主要讲解下如何处理这类问题 ﻿ 遇到的场景 这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字 row cell row cell row cell row cell 是不是非常难看，在我们一般的布局中都会给td一个半分比，从而不让它这么肆无忌惮。 这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字这是一段特别长的文字 row cell row cell row cell row cell 再来看下效果： 果然是如我们的预期的百分比进行分割的。那么此时我们希望第一个单元格进行文字省略处理。我们加上代码试试。 td{ overflow: hidden; // 按照宽度隐藏 text-overflow:ellipsis; // 省略 white-space: nowrap;// 不换行 } 从效果上面看：文字没有换行有效果，然而宽度被撑开的面目全非，这绝对不是我们想要的结果。 接下来就要介绍我们的一个样式了table-layout ﻿ table-layout /* Keyword values */ table-layout: auto; table-layout: fixed; ﻿ /* Global values */ table-layout: inherit; table-layout: initial; table-layout: unset; 【auto】大多数浏览器采用自动表格布局算法对表格布局。表格及单元格的宽度取决于其包含的内容。 【fixed】表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽。 使用 “fixed” 布局方式时，整个表格可以在其首行被下载后就被解析和渲染。这样对于 “automatic” 自动布局方式来说可以加速渲染，但是其后的单元格内容并不会自适应当前列宽。任何一个包含溢出内容的单元格可以使用 overflow 属性控制是否允许内容溢出。﻿ 我们把相应的样式添加上再看看效果： table{ table-layout: fixed; } td{ overflow: hidden; text-overflow:ellipsis; white-space: nowrap; } ﻿ 分析：我们发现左边的单元格和右边的单元格进行对比依然是 40% 60% 的比例宽度，但是它的省略功能也实现了。 [注意]td上不添加宽度的话，则平均分配宽度 总宽度/列的数量 小结 本文主要讲解了table-layout的两种方式：auto以及fixed ﻿ Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 11:10:18 "},"css.html":{"url":"css.html","title":"CSS","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:31:05 "},"css基础.html":{"url":"css基础.html","title":"基础","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:31:24 "},"css文件引入的三种方式.html":{"url":"css文件引入的三种方式.html","title":"css文件引入的三种方式","keywords":"","body":"前言 1995年，W3C发布了CSS草案 1996年，W3C正式推出CSS1 1998年，推出CSS2 2001年从CSS3开始，CSS这门语言分割成多个独立的模块，每个模块独立分级，且只包含一小部分功能； 2011年开始设计CSS4 本文将主要介绍引入CSS样式的方式，包括外部样式表、内部样式表和行间样式三种方式 ﻿ [注意]CSS语法非常简单，但容易忽略的一点是不能省略分号(最后一个样式除外) ﻿ 外部样式表 ﻿ 内部样式表 body{ background-color: red; } ﻿ [注意]文档中可出现多个style标签，且样式规则与层叠样式规则一致 【使用@import指令】@import指令用于指示Web浏览器加载一个外部样式表，并在表现HTML文档时使用其样式。唯一的区别在于命令的具体语法和位置。 @import指令常用于样式表需要使用另一个样式表中的样式的情况。 @import url(sheet2.css); body{ background-color: red; } [注意]@import必须出现在style元素中，且要放在其他CSS规则之前，否则将根本不起作用。 行间样式 如果只是想为单个元素指定一些样式，可以使用HTML的style属性来设置一个行间样式。 [注意]行间样式若存在多个style属性，只能识别第一个 [注意]标签和标签可以写在标签里面 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 19:43:17 "},"css选择器常规选择器，伪类选择器，伪元素选择器，根元素选择器.html":{"url":"css选择器常规选择器，伪类选择器，伪元素选择器，根元素选择器.html","title":"css选择器(常规选择器，伪类选择器，伪元素选择器，根元素选择器)","keywords":"","body":"前言 CSS的一个核心特性是能向文档中的一组元素类型应用某些规则，本文将详细介绍CSS选择器 ﻿ 选择器 ﻿ 【通配选择器】星号*代表通配选择器，可以与任何元素匹配 *{color: red;} ﻿ 【元素选择器】文档的元素是最基本的选择器 html{color: black;} p{color: gray;} h2{color: silver;} ﻿ 【类选择器】类选择器用于选择一类元素 .div{color: red;} // 单个类的选择 .div1.div2{color: red;} // 多个类的选择，既包含div1类也包含div2类的元素将被选择 p.div{color: red;} // p元素且包含div类的元素将被选择 ﻿ 【ID选择器】ID选择器用于选择一个元素 #test{color: red;} div#test{color: red;} 结合元素选择ID [注意]在实际中，浏览器并不会检查ID的唯一性，设置多个ID，可以为这些具有相同ID的元素应用相同样式，但在编写DOM脚本时只能识别该id的第一个元素。 【属性选择器】属性选择器根据元素的属性及属性值来选择元素(IE6-不支持) // 简单属性选择器 h1[class]{color: red;} img[alt]{color: red;} a[href][title]{color: red;} #div[class]{color: red;} .box[id]{color: red;} [class]{color: red;} ﻿ // 具体属性选择器 a[href=\"http://www.baidu.com\"][title=\"baidu\"] {color: red;} [class=\"test box\"]{color: red;} // class里面的值以及顺序必须完全相同，并且不可多空格或者少空格 [id=\"tox\"]{color: red;} // ID选择器和指定id属性的属性选择器并不是一回事，主要在于优先级不同 ﻿ // 部分属性选择器 [class ~=\"b\"] 选择class属性值在用空格分隔的词列表中包含词语\"b\"的所有元素，例如：class=\"ab\"不满足[class ~=\"b\"]，而class=\"a b\"或class=\"b\"满足 [class |=\"b\"] 选择class属性值等于b或以b-开头的所有元素，例如：class=\"ab\"或class=\"ab-\"不满足[class |=\"a\"]，而class=\"a\"或class=\"a-\"满足 [class ^=\"b\"] 选择class属性值以\"b\"开头的所有元素 [class $=\"b\"] 选择class属性值以\"b\"结尾的所有元素 [class *=\"b\"] 选择class属性值包含\"b\"的所有元素 【分组选择器】将要分组的选择器放在规则左边，并用逗号隔开 h1,p{color: red;} // 选择了h1 和 p 元素 ﻿ 【后代选择器】 ul li{color: red;} // ul 下面的所有 li元素 将被选择 div p, ul li{color: red;} // div元素 下面的所有p元素将被选择 并且 ul下面的所有 li元素将被选择 ﻿ 子元素选择器(IE6-不支持) ul > li{color: red;} // ul下面的子元素 li将被选择 ， 不选中孙子元素 ﻿ 【兄弟元素选择器】 // 相邻兄弟选择器(IE6-不支持) h1 + p{color: red;} // 选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素 [注意]两个元素之间的文本内容不会影响相邻兄弟结合符起作用 伪类选择器 伪类顺序：link-visited-focus-hover-active 【静态伪类(只应用于超链接)】[注意]visited伪类只能设置字体颜色、边框颜色、outline颜色的样式 ﻿ :link 未访问 :visited 已访问 a:link{color: red;} a:visited{color: green;} 【动态伪类(可应用于任何元素)】 :focus 拥有焦点(IE7-不支持) :hover 鼠标停留(IE6-不支持给以外的其他元素设置伪类) :active 正被点击(IE7-不支持给以外的其他元素设置伪类) 【目标伪类:target(IE8-不支持)】匹配锚点对应的目标元素 :target{color: red;} #test :target{color: red;}//id为test的目标元素 ﻿ 【UI元素伪类(IE8-不支持)】 :enabled 可用状态 :disabled 不可用状态 :checked 选中状态 ﻿ input:enabled{color: red} // [注意]input和:和enabled之间都不可以有空格 ﻿ 【结构伪类(IE8-不支持)】 E:first-child(IE6-不支持) 父元素的第一个子元素,且该子元素是E，与E:nth-child(1)等同 E:last-child(IE6-不支持) 父元素的最后一个子元素，且该子元素是E，与E:nth-last-child(1)等同 :root 选择文档的根元素，即元素 E F:nth-child(n) 选择父元素的第n个子元素，父元素是E，子元素是F E F:nth-last-child(n) 选择父元素的倒数第n个子元素，父元素是E，子元素是F E F:nth-of-type(n) 选择父元素的具有指定类型的第n个子元素，父元素是E，子元素是F E F:nth-last-of-type(n) 选择父元素的具有指定类型的倒数第n个子元素，父元素是E，子元素是F E:first-of-type 选择父元素中具有指定类型的第1个子元素，与E:nth-of-type(1)相同 E:last-of-type 选择父元素中具有指定类型的最后1个子元素，与E:nth-last-of-type(1)相同 E:only-child 选择父元素中只包含一个子元素，子元素是E E:only-of-type 选择父元素中只包含一个同类型的子元素，子元素是E E:empty 选择没有子元素的元素，而且该元素也不包含任何文本节点 [注意]n可以是整数(从1开始)，也可以是公式，也可以是关键字(even、odd) ﻿ p:first-child 代表的并不是的第一个子元素，而是元素是某元素的第一个子元素 p > i:first-child 匹配所有元素中的第一个元素 p:first-child i 匹配所有作为第一个子元素的元素中的所有元素 ﻿ 【:lang 相当于|=属性选择器(IE7-不支持)】 p:lang(en) 匹配语言为\"en\"的 ﻿ 【伪类的结合】 a:visited:hover:first-child{color: black;} // [注意]顺序无关 ﻿ 伪元素选择器 IE8-浏览器仅支持伪元素选择器的单冒号表示法 【:first-letter 设置首字母样式】所有前导标点符号应与第一个字母一同应用该样式；只能与块级元素关联；只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-letter中存在连接符的原因 p:first-letter {color: red;} 【:first-line 设置首行样式】只能与块级元素关联；只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-line中存在连接符的原因 p:first-line{color: red;} ﻿ 【:before 在元素内容前面插入内容(IE7-不支持)】默认这个伪元素是行内元素，继承元素可继承的属性；所有元素都必须放在出现该伪元素的选择器的最后面。 p:before{content:\"text\"} ﻿ 【:after 在元素内容后面插入内容(IE7-不支持)】默认这个伪元素是行内元素，继承元素可继承的属性 p:after{content:\"text\"} ﻿ 【::selection 匹配被用户选择的部分】目前selection只支持color和background两个属性，且只支持双冒号写法(IE8-浏览器不支持) ﻿ ::-moz-selection 　　 firefox浏览器需要添加前缀 ﻿ 【根元素选择器】根元素选择器:root用来选择HTML元素，但由于其实质是伪类选择器，所以其优先级更高。在HTML上设置的样式，如果在:root上也设置了同样的样式，则会被覆盖 ﻿ html{font-size:20px;} :root{font-size:30px;} 最终是30px Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 19:46:04 "},"css层叠规则,优先级算法.html":{"url":"css层叠规则,优先级算法.html","title":"css层叠规则,优先级算法","keywords":"","body":"前言 层叠样式表CSS最基本的一个特性就是层叠。冲突的声明通过层叠进行排序，由此确定最终的文档表示。而这个过程的核心就是选择器及其相关声明的特殊性、重要性、来源及继承机制。本文将详细介绍CSS层叠 ﻿ 特殊性（优先级） 1、内联样式 -> 1,0,0,0 2、ID属性值 -> 0,1,0,0 3、类属性值、属性选择或伪类 -> 0,0,1,0 4、元素或伪元素 -> 0,0,0,1 5、结合符和通配选择器 -> 0,0,0,0 特殊性的值是从左向右排序的，特殊性值1,0,0,0大于以0开头的所有值，而无论后面是什么数。在一组规则中，特殊性最高的规则胜出 ﻿ h1{} -> 0,0,0,1 p em{} -> 0,0,0,2 .grape{} -> 0,0,1,0 *.bright{} -> 0,0,1,0 p.bright em.dark{} -> 0,0,2,2 #id121{} -> 0,1,0,0 div#side *[href]{} -> 0,1,1,1 重要性(iimportant) 有时某个声明可能非常重要，超过了所有其他声明，CSS2.1称之为重要声明。重要声明在声明的结束分号之前插入!important来标志，如果!important放在声明的任何其他位置，整个声明都将无效 如果一个声明是重要声明，则超过所有的非重要声明 ﻿ 继承 继承是从一个元素向其后代元素传递属性值所采用的机制。基于继承机制，样式不仅可以应用到指定的元素，还会应用到它的后代元素 在两个比较特殊的情况需要注意：一个是在HTML中，应用到body元素的背景样式可以传递到html元素；另一个是标签不会继承父元素的文本样式 [注意]继承的属性没有特殊性 ﻿ 来源 CSS按来源的不同分为3类：author(作者)、user(用户)、user agent(代理) 1、author(作者): 来自文档的样式文件。我们平常所写的样式基本上都是这一类的 2、user(用户): 用户指定的自定义的样式文件。一些UA允许用户导入自定义的样式文件 3、user agent(代理): 一些UA(如：浏览器)要为某些元素预设一个默认的样式，以方便阅读 关于用户CSS因为不常见，可能一些朋友不太理解。IE可以通过Internet 选项 -> 外观 -> 辅助功能 -> 用户样式表来指定样式文件。Chrome可以使用Stylish扩展来实现 层叠 CSS层叠样式表的层叠特性就是让样式层叠在一起，通过特殊性、重要性、来源及继承机制来排列层叠样式的顺序及选出胜出者 1、首先，按照来源及重要性排序。在不考虑重要性的前提下，优先级顺序为：author(作者) > user(用户) > user agent(代理)。但是，如果考虑重要性，则user(用户)的优先级大于author(作者)的优先级，这样做是试图平衡author(作者)和user(用户)。所以，最终的优先级排序为：user(用户)!important > author(作者)!important > author > user > user agent 2、接着，对于非重要声明来说，按照特殊性排序。特殊性越高的规则，权重越大 3、最后，如果特殊性相同，则按照出现顺序排序。声明在样式表或文档中越靠后出现，权重越大。如果样式表中有通过@import导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表的所有声明在后 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 19:46:55 "},"css长度单位学习em,rem,px,vw,vh.html":{"url":"css长度单位学习em,rem,px,vw,vh.html","title":"css长度单位学习(em,rem,px,vw,vh)","keywords":"","body":"绝对长度单位 绝对长度单位代表一个物理测量 【像素px(pixels)】 像素，为影像显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。仔细处理的话，一幅影像中的像素可以在任何尺度上看起来都不像分离的点或者方块；但是在很多情况下，它们采用点或者方块显示。每个像素可有各自的颜色值，可采三原色显示，因而又分成红、绿、蓝三种子像素（RGB色域），或者青、品红、黄和黑（CMYK色域，印刷行业以及打印机中常见）。照片是一个个取样点的集合，在影像没有经过不正确的/有损的压缩或相机镜头合适的前提下，单位面积内的像素越多代表分辨率越高，所显示的影像就会接近于真实物体。 在web上，像素px是典型的度量单位，很多其他长度单位直接映射成像素。最终，他们被按照像素处理 【英寸in(inches)】1in = 2.54cm = 96px 【厘米cm(centimeters)】1cm = 10mm = 96px/2.54 = 37.8px 【毫米mm(millimeters)】1mm = 0.1cm = 3.78px 【1/4毫米q(quarter-millimeters)】1q = 1/4mm = 0.945px 【点pt(points)】点（英语：point，pt），也音译磅因、磅，是印刷所使用的长度单位，用于表示字型的大小，也用于余白（字距、行距）等其他版面构成要素的长度。1pt = 1/72in = =0.0139in = 1/722.54cm = 1/7296px = 1.33px 【派卡pc(picas)】派卡（英语：pica）是印刷行业使用的长度单位。1pc = 12pt = 1/6in = 1/6*96px = 16px ﻿ 字体相关相对长度单位 em、ex、ch、rem是字体相关的相对长度单位 【em】[重点]em表示元素的font-size属性的计算值，如果用于font-size属性本身，相对于父元素的font-size；若用于其他属性，相对于本身元素的font-size .box{font-size: 20px;} .in{ /* 相对于父元素，所以2*20px=40px */ font-size: 2em; /* 相对于本身元素，所以5*40px=200px */ height: 5em; /* 10*40px=400px */ width: 10em; background-color: lightblue; } 【rem】rem是相对于根元素html的font-size属性的计算值兼容性: IE8-不支持 /* 浏览器默认字体大小为16px，则2*16=32px，所以根元素字体大小为32px */ html{font-size: 2rem;} /* 2*32=64px */ .box{font-size: 2rem;} .in{ /* 1*32=32px */ font-size: 1rem; /* 1*32=32px */ border-left: 1rem solid black; /* 4*32=128px */ height: 4rem; /* 6*32=192px */ width: 6rem; background-color: lightblue; } 默认地，浏览器的字体大小font-size是16px，也就是1rem=16px。而如果将HTML的font-size设置为100px，方便后续计算，不设置为10px是因为chrome下最小字体大小为12px 【ex】ex是指所用字体中小写x的高度。但不同字体x的高度可能不同。实际上，很多浏览器取em值一半作为ex值[注意]ex在实际中常用于微调 【ch】ch与ex类似，被定义为数字0的宽度。当无法确定数字0宽度时，取em值的一半作为ch值 兼容性: IE8-不支持 [注意]ch在实际中主要用于盲文排版 视口相关相对长度单位 关于视口相关的单位有vh、vw、vmin、vmax4个单位兼容性:IE8-不支持，IOS7.1-不支持，android4.3-不支持(对于vmax，所有IE浏览器都不支持)[注意]黑莓错误的将其相对于视觉视口来计算；而safari奇怪地相对于html元素来计算，如果html中增加了内容，这两个单位也会发生变化 【vw】【vh】布局视口宽度的 1/100布局视口高度的 1/100 body{margin: 0;} .vhbox{ /* 实现与屏幕等高的效果 */ height: 100vh; background-color: lightblue; } 【vmin】 布局视口高度和宽度之间的最小值的 1/100 /*类似于contain效果*/ .box{ height: 100vmin; width: 100vmin; } 【vmax】 布局视口高度和宽度之间的最大值的 1/100 /*类似于cover效果*/ .box{ height: 100vmax; width: 100vmax; } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 19:50:28 "},"css样式关键字initial,inherit,unset,revert,all.html":{"url":"css样式关键字initial,inherit,unset,revert,all.html","title":"css样式关键字(initial,inherit,unset,revert,all)","keywords":"","body":"关键字 在CSS中，有4个关键字理论上可以应用于任何的CSS属性，它们是initial(初始)、inherit(继承)、unset(未设置)、revert(还原)。而all的取值只能是以上这4个关键字。本文将介绍initial、inherit、unset、revert和all initial 表示元素属性的初始默认值(该默认值由官方CSS规范定义)兼容性: IE不支持 div{display: initial;} // display初始默认值为inline ﻿ inherit 表示元素的直接父元素对应属性的计算值兼容性: IE7-不支持 .box_css1{ border: 1px solid red; padding: 10px; width: 100px; } .test_css1{ border: inherit; height: 30px; } 测试一 ﻿ unset unset相对于initial和inherit而言，相对复杂一点。表示如果该属性默认可继承，则值为inherit；否则值为initial。实际上，设置unset相当于不设置兼容性: IE不支持，safari9-不支持，ios9.2-不支持，android4.4.4-不支持 revert 表示样式表中定义的元素属性的默认值。若用户定义样式表中显式设置，则按此设置；否则，按照浏览器定义样式表中的样式设置；否则，等价于unset兼容性: 只有safari9.1+和ios9.3+支持 all 表示重设除unicode-bidi和direction之外的所有CSS属性的属性值，取值只能是initial、inherit、unset和revert兼容性: IE不支持，safari9-不支持，ios9.2-不支持，android4.4-不支持 .test{ border: 1px solid black; padding: 20px; color: red; } .in{ /* all: initial; //都取默认值 border:none;padding:0;color:black; all: inherit; // 都取父元素继承值 border:1px solid black;padding:20px;color:red; all: unset; // .in的所有属性都相当于不设置值，默认可继承的继承，不可继承的保持默认值border:none;padding:0;color:red; all: revert; // 等价于unset */ } 测试文字 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 19:51:07 "},"css伪类和伪元素.html":{"url":"css伪类和伪元素.html","title":"css伪类和伪元素","keywords":"","body":"前言 CSS的伪类和伪元素在平时的代码中经常会出现，可是一旦别人问你，什么是伪类，什么是伪元素，可能还是不能完整的表述出来，下面我们来一探究竟。 伪类和伪元素定义 伪类用于在页面中的元素处于某个状态时，为其添加指定的样式。 伪元素会创建一个抽象的伪元素，这个元素不是DOM中的真实元素，但是会存在于最终的渲染树中，我们可以为其添加样式。 [重点]最常规的区分伪类和伪元素的方法是：实现伪类的效果可以通过添加类来实现，但是想要实现伪元素的等价效果只能创建实际的DOM节点。 [注意]伪类使用单冒号 “:” ; 伪元素使用双冒号 “::” 伪元素 伪元素可以分为排版伪元素、突出显示伪元素、树中伪元素三类。 排版伪元素 【::first-line】 设置元素中第一行文本的样式 [注意]::first-line伪元素只有应用在块级容器上才有效，且必须出现在相同流中的块级子孙元素中（即没有定位和浮动）。 [注意]只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-line中存在连接符的原因 ﻿ .firstLine::first-line { width: 200px; text-transform: uppercase; background: #f3f3f3; } hello world hello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello worldhello world 虽然在DOM中看不到，但实际上，上面的这段HTML代码会通过添加虚拟标签的方式进行修改。 【::first-letter】 指定一个元素第一个字母的样式 [注意1]所有前导标点符号应与第一个字母一同应用该样式 [注意2]只能与块级元素关联 [注意3]只有当选择器部分和左大括号之间有空格时，IE6-浏览器才支持。因为first-letter中存在连接符的原因 .letter{ width: 200px; border: 1px solid black; text-indent: 0.5em; } .letter:first-letter{ font-size: 30px; float: left; } ﻿ 测试首字母下层，测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层测试首字母下层 突出显示伪元素 突出显示伪元素表示文档中特定状态的部分，通常采用不同的样式展示该状态。如页面内容的选中。突出显示伪元素不需要在元素树中有体现，并且可以任意跨越元素边界而不考虑其嵌套结构。 【::selection】 匹配被用户选择的部分 [注意1]firefox浏览器需要添加-moz-前缀[注意2]只支持双冒号写法[注意3]只支持颜色和背景颜色两个样式 div::selection{color: red;} p::selection{ color:#fff; } ﻿ 树中伪元素 【::before & ::after】 ::before是在源元素的实际内容前添加伪元素。::after是在源元素的实际内容后添加伪元素。当::before/::after伪元素的content属性不为'none'时，这两类伪元素就会生成一个元素，作为源元素的子元素，可以和DOM树中的元素一样定义样式。 [兼容]IE7-浏览器不支持[注意]默认这个伪元素是行内元素，且继承元素可继承的属性；IE7-浏览器中必须声明!DOCTYPE，否则不起作用 // content = 字符串 .box:after{content:\"后缀\"} ﻿ // content = url div:before{ content: url(\"arrow.gif\"); } ﻿ // content = attr div:before{ content: attr(data-before); } [特] content的内容可以直接使用 url() 引入图片 【::marker】 ::markder可以用于定义列表项标记的样式。 .item::marker{ color:green; } ﻿ Item 1 Item 2 Item 3 该伪元素暂时只有safari支持，尝试的话请使用safari。可以用于该伪元素的属性也有限 【::placeholder】 表示输入框内占位提示文字。可以定义其样式。 ::placeholder { color: blue; } 伪元素速查表 /* Typographic Pseudo-elements */ ::first-line /* 选取文字块首行字符 */ ::first-letter /* 选取文字块首行首个字符 */ ﻿ /* Highlight Pseudo-elements */ ::selection /* 选取文档中高亮(反白)的部分*/ ::inactive-selection /* 选取非活动状态时文档中高亮(反白)的部分*/ ::spelling-error /* 选取被 UA 标记为拼写错误的文本 */ ::grammar-error /* 选取被 UA 标记为语法错误的文本 */ ﻿ /* Tree-Abiding Pseudo-elements */ ::before /* 在选中元素中创建一个前置的子节点 */ ::after /* 在选中元素中创建一个后置的子节点 */ ::marker /* 选取列表自动生成的项目标记符号 */ ::placeholder /* 选取字段的占位符文本(提示信息) */ /* WebVTT Format */ ::cue /* 匹配所选元素中 WebVTT 提示 */ ﻿ /* Fullscreen API */ ::backdrop /* 匹配全屏模式下的背景 */ 伪类 伪类经常与伪元素混淆，伪元素的效果类似于通过添加一个实际的元素才能达到，而伪类的效果类似于通过添加一个实际的类来达到。实际上css3为了区分两者，已经明确规定了伪类用一个冒号来表示，而伪元素则用两个冒号来表示。 锚点 关于锚点，有常见的5个伪类，分别是:link,:hover,:active,:focus,:visited a:link{background-color:pink;}/*品红，未访问*/ a:hover{background-color:lightblue;}/*浅蓝，鼠标悬停*/ a:active{background-color:lightgreen;}/*浅绿，正被点击*/ a:focus{background-color:lightgrey;}/*浅灰，拥有焦点*/ a:visited{color:orange;}/*字体颜色为橙色，已被访问*/ /*[注意]visited伪类只能设置字体颜色、边框颜色、outline颜色的样式*/ 伪类顺序 对于伪类顺序，有一个口诀是love-hate，代表着伪类的顺序是link、visited、focus、hover、active。但是否伪类的顺序只能如此呢？为什么是这个顺序呢？ CSS层叠中有一条法则十分重要，就是后面覆盖前面，所以伪类的顺序是需要精心考虑的。 【1】link和visited必须在最前面，且没有先后顺序，否则link或visited的效果将覆盖 hover active focus [注意]link和visited称为静态伪类，只能应用于超链接 【2】hover、active、focus这三个伪类必须是focus、hover、active的顺序，因为在focus状态下，也需要触发hover和active，而要触发active一定要先触发hover，所以active要放在hover后面 [注意]hover、active、focus称为动态伪类，可应用于任何元素，但IE7-浏览器不支持:focus，:hover和:active在IE6-浏览器下只支持给\\设置 所以最终的顺序只有两种:link、visited、focus、hover、active或visited、link、focus、hover、active a:link{background-color:pink;}/*品红，未访问*/ a:visited{color:orange;}/*字体颜色为橙色，已被访问*/ a:focus{background-color:lightgrey;}/*浅灰，拥有焦点*/ a:hover{background-color:lightblue;}/*浅蓝，鼠标悬停*/ a:active{background-color:lightgreen;}/*浅绿，正被点击*/ UI元素伪类 UI元素伪类包括:enabled、:disabled、:checked三个，主要针对于HTML中的form元素，IE8-浏览器不支持 :enabled 可用状态 :disabled 不可用状态 :checked 选中状态 ﻿ input:enabled{ border: 1px solid black; background-color: transparent; } input:disabled{ border: none; background-color: gray; } input:checked{ outline: 2px solid lightblue; } ﻿ 按钮可用 按钮不可用 Male Female 结构伪类 结构伪类可分为以下3种情况，IE8-浏览器不支持 【1】:nth-child(n)、:nth-last-child(n)、first-child、last-child、:only-child E F:nth-child(n) 选择父元素的第n个子元素 E F:nth-last-child(n) 选择父元素的倒数第n个子元素 E F:first-child 父元素的第一个子元素，与E F:nth-child(1)等同 E F:last-child 父元素的最后一个子元素，与E F:nth-last-child(1)等同 E F:only-child 选择父元素中只包含一个子元素 ﻿ p:first-child 　　 代表的并不是的第一个子元素，而是元素是某元素的第一个子元素 p > i:first-child 匹配所有元素中的第一个元素 p:first-child i 　　 匹配所有作为第一个子元素的元素中的所有元素 [注]n可以是整数(从1开始)，也可以是公式，也可以是关键字(even、odd) 【2】:nth-of-type(n)、:nth-last-of-type(n)、:first-of-type、:last-of-type、:only-of-type E F:nth-of-type(n) 选择父元素的具有指定类型的第n个子元素 E F:nth-last-of-type(n) 选择父元素的具有指定类型的倒数第n个子元素 E F:first-of-type 选择父元素中具有指定类型的第1个子元素，与E F:nth-of-type(1)相同 E F:last-of-type 　 选择父元素中具有指定类型的最后1个子元素，与E F:nth-last-of-type(1)相同 E F:only-of-type 　　 选择父元素中只包含一个同类型的子元素 ﻿ .box div:nth-of-type(even){color: red;} .box p:nth-last-of-type(3){color: green;} .box div:first-of-type{color: blue;} .box p:last-of-type{color: yellow;} .box div:only-of-type{color: pink;} 【3】:root、:not、:empty、:target :root 　选择文档的根元素 :not 　选择除某个元素之外的所有元素 :empty 选择没有子元素的元素，而且该元素也不包含任何文本节点 :target 　 匹配锚点对应的目标元素 ﻿ [注意]:not选择器常用于导航之间的竖线处理，如li:not(:last-of-type) ﻿ :root{color:red;} div:not{background-color: lightgrey;} p:empty{height:30px;width:30px;background:pink;} :target{color:blue;} // 当点击页面上面的锚点时，锚点到的目标元素会采用这个样式 【其它】1、:lang() 匹配某个语言，IE7-浏览器不支持 p:lang(en) 匹配语言为\"en\"的 2、不仅可以使用单一伪类，也可以伪类结合使用[注意]顺序无关 div:hover:first-child{background-color: lightgreen;} div:last-of-type:active{background-color: lightblue;} ﻿ 伪类速查表 /* Logical Combinations */ :matches() /*:any()*/ /* 匹配 集合内指定 的元素 */ :not() /* 排除 满足指定关系 的元素 */ :has() /* 匹配 满足指定关系 的元素*/ ﻿ ﻿ /* Linguistic Pseudo-classes */ :dir() /* 匹配 设置dir(文字书写方向)属性 的元素 */ :lang() /* 匹配 设置lang(定义元素语言)属性 的元素 */ ﻿ ﻿ /* Location Pseudo-classes */ :any-link /* 匹配 任意有链接锚点 的元素*/ :link /* 匹配 未处于访问记录中 的链接 */ :visited /* 匹配 处于访问记录中 的链接 */ :target /* 匹配 URL指向的锚点 的元素 */ :scope /* 匹配 设置scoped属性的style标签 的作用域 */ ﻿ ﻿ /* User Action Pseudo-classes */ :hover /* 匹配 处于鼠标悬停状态 的元素 */ :active /* 匹配 处于激活状态 的元素 */ :focus /* 匹配 处于聚焦状态 的元素 */ :focus-ring /* 匹配 处于聚焦状态元素 的UA样式(聚焦轮廓) */ :focus-within /* 匹配 子节点处于聚焦状态 的元素 */ :drop /* 匹配 处于拖拽状态 的元素 */ :drop() /* 匹配 处于指定拖拽状态 的元素 */ ﻿ ﻿ /* Time-dimensional Pseudo-classes */ :current /* 匹配 处于当前状态 的定义了timeline属性的元素 */ :past /* 匹配 处于过去状态 的定义了timeline属性的元素 */ :future /* 匹配 处于将来状态 的定义了timeline属性的元素 */ ﻿ ﻿ /* Resource State Pseudos */ :playing /* 匹配 处于播放状态 的元素 */ :paused /* 匹配 处于暂停状态 的元素 */ ﻿ ﻿ /* The Input Pseudo-classes */ :enabled /* 匹配 可以编辑 的元素 */ :disabled /* 匹配 禁止编辑 的元素 */ :read-only /* 匹配 内容只读 的元素 */ :read-write /* 匹配 内容可编辑 的元素 */ :placeholder-shown /* 匹配 显示字段占位符文本 的元素 */ :default /* 匹配 页面载入默认选中 的元素 */ ﻿ :checked /* 匹配 选中状态 的元素 */ :indeterminate /* 匹配 模糊状态 的元素 */ ﻿ :valid /* 匹配 输入内容通过类型验证 的元素 */ :invalid /* 匹配 输入内容无法通过类型验证 的元素 */ :in-range /* 匹配 输入数值符合范围 的元素 */ :out-of-range /* 匹配 输入数值溢出范围 的元素 */ :required /* 匹配 设置必填属性 的元素 */ :optional /* 匹配 可选字段 的元素 */ :user-invalid /* 匹配 用户输入内容未通过验证 的元素 */ ﻿ /* Tree-Structural pseudo-classes */ :root /* 匹配 文档树 的根元素*/ :empty /* 匹配 无子节点 的元素 */ :blank /* 匹配 仅包含空格或者换行符 的元素 */ ﻿ :nth-child(n) /* 匹配 符合元素集合中指定位置 的元素 */ :nth-last-child(n) /* 反序匹配 符合元素集合内指定位置 的元素 */ :first-child /* 匹配 符合元素集合内首个 的元素 */ :last-child /* 匹配 符合元素集合内末尾 的元素 */ :only-child /* 匹配 无兄弟节点 的元素 */ ﻿ :nth-of-type(n) /* 匹配 符合元素集合中同类型指定位置 的元素 */ :nth-last-of-type(n) /* 反序匹配 符合元素集合中同类型指定位置 的元素 */ :first-of-type /* 匹配 每个在元素集合中初次出现 的元素 */ :last-of-type /* 匹配 每个在元素集合中末次出现 的元素 */ :only-of-type /* 匹配 无同类兄弟节点 的元素*/ ﻿ ﻿ /* Fullscreen API */ :fullscreen /* 匹配 全屏显示模式中 的元素 */ ﻿ ﻿ /* Page Selectors */ :first /* 打印文档时首页的样式 */ :left /* 打印文档时左侧的样式 */ :right /* 打印文档时右侧的样式 */ Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 19:54:24 "},"CSS盒模型深入理解.html":{"url":"CSS盒模型深入理解.html","title":"CSS盒模型深入理解","keywords":"","body":"前言 所有文档元素都生成一个矩形框，这称为元素框(element box)，它描述了一个元素在文档布局中所占的空间大小。而且，每个框影响着其他元素框的位置和大小 ﻿ ﻿ 宽高 宽度width被定义为从左内边界到右内边界的距离，高度height被定义为从上内边界到下内边界的距离 在CSS中，可以对任何块级元素设置显式高度。如果指定高度大于显示内容所需高度，多余的高度会产生一个视觉效果，就好像有额外的内边距一样；如果指定高度小于显示内容所需高度，则会向元素添加一个滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性 [注意]宽度和高度无法应用到行内非替换元素，且不能为负 【auto】宽高和margin可以设置auto。 对于块级元素来说，宽度设置为auto，则会尽可能的宽。 元素宽度=包含块宽度—元素水平外边距-元素水平边距宽度-元素水平内边距； ﻿ 高度设置为auto，则会尽可能的窄。详细来说，元素高度=恰好足以包含其内联内容的高度 ﻿ [注意]如果没有显式声明包含块的height，则元素的百分数高度会重置为auto 【怪异盒模型】IE6-浏览器的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸 【最大最小宽高】设置最大最小宽高的好处是可以相对安全地混合使用不同的单位。使用百分数大小的同时，也可以设置基于长度的限制 min-width | min-height 值: | | inherit 初始值: 0 应用于: 块级元素和替换元素 继承性: 无 百分数: 相对于包含块的宽度(高度) ﻿ max-width | max-height 值: | | inherit 初始值: none 应用于: 块级元素和替换元素 继承性: 无 百分数: 相对于包含块的宽度(高度) [注意]IE6-浏览器不支持min-width | min-height | max-width | max-height [注意]当最小宽度(高度)大于最大宽度(高度)时，以最小宽高的值为准 内边距 相比于盒模型的其他属性(如在定位中经常使用负值的margin，因为CSS3的到来重获光彩的border等)，padding显得中规中矩了很多，没有什么兼容性，也没有一些特殊的问题 对于行内元素，左内边距应用到元素的开始处，右内边距应用到元素的结尾处，垂直内边距不影响行高，但会影响自身尺寸，加背景颜色可以看出 [注意]内边距不能是负值 padding 值:[ | ]{1,4} | inherit 初始值: 未定义 应用于: 所有元素 继承性: 无 百分数: 相对于包含块的width ﻿ 【50%】块级元素通过padding:50%可以实现正方形的效果，因为水平和垂直padding的百分比值都是相对于包含块的宽度决定的，常常用于移动端头图 如果是内联元素使用padding:50%，必须配合font-size:0，因为使用inline元素的垂直padding会出现\"幽灵空白节点\"，也就是规范中\"strut\"。所以通过font-size:0使其尺寸为0 [块元素效果展示] 行内元素：选择font-size = 0; 去除“幽灵空白节点” 【表单】1、所有浏览器input/textarea/button都内置padding2、部分浏览器select下拉内置padding，firefox、IE8+可以设置padding3、除IE10-以外的其他浏览器，radio/checkbox单选复选框无内置padding，且无法设置padding。IE10-浏览器的radio/checkbox单选复选框有内置padding，且可以设置padding[注意]除IE10-以外的其他浏览器，radio/checkbox单选复选框无内置border，且无法设置border 【button兼容】1、在firefox浏览器中，设置padding:0，按钮左右两侧依然有padding，这时需要使用firefox自有样式 button::-moz-focus-inner{padding:0;} 2、IE7-浏览器下文字越多，左右padding逐渐变大，设置overflow:visible可解决该问题 3、button按钮的padding与高度计算不兼容 button{ line-height:20px; padding:10px; border:none; } ﻿ //结果为： IE7: 45px firefox:42px chrome/IE8+:40px 可以使用label标签来实现类似的效果，然后把按钮button进行可访问性隐藏即可 按钮 ﻿ label{ display:inline-block; line-height:20px; padding:10px; border:none; } ﻿ //结果为： IE7: 40px firefox:40px IE8+:40px chrome:40px 外边距 设置外边距margin会在元素外创建额外的空白，空白通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景 外边距可以应用到行内元素，上下外边距对行高没有任何影响。由于上下外边距实际上是透明的，所以这个声明没有任何视觉效果。左外边距应用到元素开始处；右外边距应用到元素结束处 margin 值:[ | | auto]{1,4} | inherit 初始值: 未定义 应用于: 所有元素 继承性: 无 百分数: 相对于包含块的width ﻿ [注意]对于普通元素来说，包含块就是块级父级元素，对于定位元素来说，包含块是定位父级。所以，普通元素的margin百分比相对于块级父级元素的width，定位元素的margin百分比相对于定位父级的width [注意]margin负值的作用非常大 边框 元素外边距内就是元素的边框border，元素的边框是围绕元素内容的内边距的一条或多条线。边框由粗细、样式和颜色三部分组成 对于行内元素来说，边框实际上画在各行之外的下一个像素上，由于各行紧挨着，所以其边框会重叠。无论为行内元素的边框设置怎样的宽度，不会对行高有任何影响；但左右边框会分别显示在元素的开始处和结尾处 .d1{ width: 200px; border: 1px solid red; } .s1{ border: 1px solid black; background-color: yellow; padding: 6px; margin: 6px; font-size: 30px; line-height: 50px; } ﻿ 测试文字测试文字测试文字 ﻿ box-sizing 在CSS中盒模型被分为两种，第一种是W3C的标准模型，第二种是IE怪异盒模型。 不同之处在于后者的宽高定义的是可见元素框的尺寸，而不是元素框的内容区尺寸。目前对于浏览器大多数元素都是基于W3C标准的盒模型，但对于表单form中的部分元素还是基于IE的怪异盒模型，如input里的radio、checkbox、button等元素，如果给其设置border和padding它们也只会往元素盒内延伸 在W3C的标准模型下，宽度和高度仅仅包含了内容宽度，除去了边框和内边距两个区域，这样为web设计师处理效果带来了不少麻烦。为了解决这个问题，CSS3新增了一个盒模型属性box-sizing，能够事先定义盒模型的尺寸解析方式 [注意]IE7-浏览器不支持 box-sizing 值: content-box | border-box | padding-box | inherit 初始值: content-box 应用于: 块级元素和替换元素 继承性: 无 [注意1]只有firefox浏览器支持padding-box属性值[注意2]IE浏览器在getComputedStyle得到width/height是按照标准模式计算的，而不论box-sizing的取值 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-01 20:20:33 "},"CSS视觉格式化（基本框、包含块、盒模型、水平格式化、垂直格式化、行布局、em框、内容区、行间.html":{"url":"CSS视觉格式化（基本框、包含块、盒模型、水平格式化、垂直格式化、行布局、em框、内容区、行间.html","title":"* CSS 视觉格式化（基本框、包含块、盒模型、水平格式化、垂直格式化、行布局、em框、内容区、行间","keywords":"","body":"前言 CSS视觉格式化这个词可能比较陌生，但说起盒模型可能就恍然大悟了。实际上，盒模型只是CSS视觉格式化的一部分。视觉格式化分为块级和行内两种处理方式。理解视觉格式化，可以确定得到的效果是应该显示的正确效果，还是浏览器兼容性的bug。 基本概念 【基本框】CSS假定每个元素都会生成一个或多个矩形框，这称为元素框。 各元素框中心有一个内容区(content area)。 这个内容区周围有可选的内边距、边框和外边距。 可以用多种属性设置外边距、边框和内边距。内容的背景也会应用到内边距。外边距通常是透明的，从中可以看到父元素的背景。内边距不能是负值，但是外边距可以 对于不同类型的元素格式化时存在着差别。块级元素的处理不同于行内元素，而浮动元素和定位元素也分别有着各自不同的表现 【包含块】每个元素都相对于其包含块摆放，包含块就是一个元素的布局上下文。对于正常的文本流中的一个元素而言，包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成[注意]行内元素的摆放方式并不直接依赖于包含块 【其他术语】1、正常流  文本从左向右、从上向下显示，是传统HTML文档的文本布局 2、非替换元素  如果元素的内容包含在文档中，则称之为非替换元素 3、替换元素  指作为其他内容占位符的一个元素(、、等)。但，inline-block元素在布局中也当作替换元素处理。所以，又包含大量的表单类元素及表格类元素 4、块级元素  在正常流中，在其元素框之前和之后生成“换行”，且会垂直摆放的元素。通过声明display:block可以让元素生成块级框 5、行内元素  在正常流中，不会在元素框之前或之后生成“行分隔符”，是块级元素的后代。通过声明display:inline可以让元素生成行内框 6、根元素  位于文档树顶端的元素，在HTML文档中，是元素HTML 盒模型 盒模型又叫框模型，由宽高、内边距、边框和外边距组成 【四个盒子】关于盒模型，首先要确定四个盒子的概念 1、元素框是指margin box  元素框: width/height + padding + border + margin 2、可视区域是指border box  [注意]关于可视区域，一直都有两个争论，一个指border box，另一个指padding box。但从字面去理解，可视区域应该就是指可以看到的区域，应该以border box为准  可视区域：width/height + padding + border 3、客户区(client)是指padding box  [注意]关于客户区这种说法来源于javascript中的clientWidth和clientHeight   客户区：width/height + padding 4、内容区是指content box(width和height组成)  内容区：width/heigh  对于水平和垂直布局，有着不同的效果，下面以水平格式化和垂直格式化分别介绍 【水平格式化】  水平格式化的规则是正常流中块级元素框的水平总和等于父元素的width 水平格式化的7大属性是margin-left、border-left、padding-left、width、padding-right、border-right、margin-right。7个属性的值加在一起是元素包含块的宽度，这往往是块元素的父元素的width值(因为块级元素的父级元素几乎都是块级元素) auto 视觉格式化中比较重要的一个概念就是auto。auto值是用来弥补实际值与所需总和的差距 在水平格式化的7个属性中只有margin-left、width、margin-right三个属性可以设置为auto，其余属性必须设置为特定的值，或者默认宽度为0 1、1个auto  若只有一个值为auto，则根据7个水平属性的总结等于父级width的公式，计算出auto所表示的值  由于width默认值为auto，而margin、border和padding默认值都为0。所以，会有块级元素默认撑满父元素的表现 2、2个auto  若margin-left和margin-right为auto，则元素将在父元素中居中显示  若margin-left和width为auto，则margin-left将被重置为0  若margin-right和width为auto，则margin-right将被重置为0 3、3个auto  若三个值都为auto，则margin-left和margin-right都被重置为0 4、0个auto  若margin-left/width/margin-right三个属性都设置为非auto的某个值，这种情况叫做格式化属性过分受限。这样margin-right将被重置为auto 效果展示： 替换元素     上面介绍的是正常文本流中非替换块级元素的水平格式化，而替换块级元素管理起来则更简单一些。非替换块元素的所有规则同样适用于替换块元素，只有一个例外：如果width是auto，元素的宽度则是内容的固有宽度 下面以图片为例子来说明块级替换元素，但由于图片是行内替换元素，所以需要将display设置为block 如果一个替换元素的width不同于其固有宽度，那么height值也会成比例变化，除非Height显式设置一个特定值，反过来也一样 效果演示： 【垂直格式化】 一个元素的默认高度由其内容决定，高度还会受内容宽度的影响，段落越窄，相应地就会越高，以便容纳其中所有的内联内容 在CSS中，可以对任何块级元素设置显式高度。如果指定高度大于显示内容所需高度，多余的高度会产生一个视觉效果，就好像有额外的内边距一样；如果指定高度小于显示内容所需高度，则会向元素添加一个滚动条。如果元素内容的高度大于元素框的高度，浏览器的具体行为取决于overflow属性 与水平格式化的情况类似，垂直格式化也有7个相关属性：margin-top/border-top/padding-top/height/padding-bottom/border-bottom/margin-bottom 垂直格式化7大属性的和必须等于元素包含块的height auto 在垂直格式化的7个属性中，只有margin-top、height、margin-bottom三个属性可以设置为auto 与水平格式化不同，垂直格式化的auto处理较为简单。如果块级正常流元素设置为height:auto，显示时其高度将恰好足以包含其内联内容的行盒；如果margin-top或margin-bottom设置为auto，它会自动计算为0 [注意]对于定位元素的上下外边距的auto处理，则有所不同 行布局 行内元素没有块级元素那么简单和直接，块级元素只是生成框，通常不允许其他内容与这些框并存 在了解行内元素视觉格式化之前要先了解一些涉及到的基本术语 【术语】1、匿名文本  匿名文本(anonymous text)是指所有未包含在行内元素中的字符串 2、em框  em框在字体中定义，也称为字符框(character box)。实际的字形可能比其em框更高或更矮。在CSS中，font-size的值确定了各个em框的高度 3、内容区  在非替换元素中，内容区是元素中各字符的em框串在一起构成的框；而在替换元素中，内容区就是元素的固有高度再加上可能有的外边距、边框或内边距。内容区类似于一个块级元素的内容框(content box) 4、行间距  行间距(leading)是font-size和line-height之差。这个差实际上要分为两半，分别应用到内容区的顶部和底部[注意]行间距只应用于非替换元素 5、行内框  行内框通过向内容区增加行间距来描述。对于非替换元素，元素行内框的高度等于line-height的高度；对于替换元素，元素行内框的高度则恰好等于内容区的高度，因为行间距不应用到替换元素[注意]行内框的区域与内联元素背景颜色所在的区域无关 6、行框  行框是包含该行中出现的行内框的最高点和最低点的最小框。换句话说，行框的上边界要位于最高行内框的上边界；而行框的底边要放在最低行内框的下边界 【构造行框】行框构造是行布局中非常重要的一个环节，接下来介绍行框构造的步骤 1、构造各元素的行内框    a、对于替换元素来说，得到各元素的height、margin-top、margin-bottom、padding-top、padding-bottom、border-top-width、border-bottom-width值，把它们加在一起(因为，行间距不应用到替换元素上，所以替换元素的内容大小等于行内框大小)    b、对于非替换元素来说，得到各行内非替换元素及不属于后代行内元素的所有文本的font-size值和line-height值，再将line-height减去font-size，得到行的行间距，这个行间距除以2，将其一半分别应用到em框的顶部和底部 2、对于各内容区，确定它在整行基线的上方和下方分别超出多少。对于非替换元素来说，确定各元素及匿名文本各部分的基线的位置，并知道该行本身基线的位置，然后将其对齐；对于替换元素来说，将其底边放在整行的基线上 3、对于指定了vertical-align值的元素，确定其垂直偏移量。由此可知，该元素的行内框要向上或向下移动多远，并改变元素在基线上方或下方超出的距离 4、既然已经知道了所有行内框会放在哪里，再来计算最后的行框高度。为此，只需将基线与最高行内顶端之间的距离加上基线与最低行内框底端之间的距离 行的高度(又叫行框的高度)由其组成元素和其他内容(如文本)的高度确定。行高line-height实际上只影响行内元素和其他行内内容，而不会直接影响块级元素 在行布局中，替换元素和非替换元素并不相同，接下来将分别进行介绍 【行内非替换元素】首先，对于行内非替换元素或匿名文本某一部分，font-size值确定了内容区的高度。如果一个行内元素的font-size为15px，则内容区的高度为15px 内容区加上行间距等于行内框。如果一个行内非替换元素的font-size为15px，line-height为21px，则相差6px。用户代理将这6像素一分为二，将其一半分别应用到内容区的顶部和底部，这就得到了行内框 当line-height小于font-size时，行内框实际上小于内容区 行框定义为行中最高行内框的顶端到最低行内框底端之间的距离，而且各行框的顶端挨着上一行行框的底端 如果一行中存在行高相同但字体大小不同的行内元素，虽然所有行内框大小都相等，但它们排列得并不整齐，因为文本都是按照基线对齐的 如果改变行内框的垂直对齐，比如设置垂直对齐为4px，这会同时提升其内容区和行内框。如果设置的该行内框是行中的最高点，则会把整个行框的顶端也向上移动4像素 框属性 如果一个行内元素存在边框或内边距，而没有设置一个足够大的行高line-height来容纳它们，就有覆盖其他行的危险 内边距和边框不会改变内容区的尺寸，不过它会影响这个元素行内框的高度，但并不会影响行框的生成和布局，即不改变行高。至于外边距，它不会应用到行内非替换元素的顶端和底端，不会影响行框的高度 尽管内边距、边框和外边距不影响行高，但是它们确实能影响一个元素内容的布局。可能将文本推离其左右两端。实际上，如果左、右两外边距为负，可能会把文本拉近行内元素，甚至导致重叠 margin-left、padding-left、border-left应用到元素的开始处；而margin-right、padding-right、border-right应用到元素的结尾处 效果展示：可以观察到 padding-top padding-bottom 是不影响行高的 【行内替换元素】一般地，行内替换元素(如图像)都有固有的高度和宽度。有固有高度的替换元素可能导致行框比正常要高。但这不会改变行中任何元素的行高line-height值，包括替换元素本身。相反，只是让行框高度恰好能包含替换元素 行内替换元素需要行高line-height值，从而在垂直对齐时能够正确地定位元素。因为垂直对齐vertical-align的百分数值是相对于元素的行高line-height来计算的。对于垂直对齐来说，图像本身的高度无关紧要，关键是line-height的值 由于行内替换元素行内框的高度由高度height、内边距padding、边框border和外边距margin共同决定。所以，盒模型属性的变化会影响行内框的高度，进而可能会影响行框的高度 默认地，行内替换元素位于基线上。如果向替换元素增加下内边距、外边距或边框，内容区会上移。替换元素并没有自己的基线，所以相对来说最好的办法是将其行内框的底端与基线对齐。因此，实际上是下外边距边界与基线对齐 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 07:17:21 "},"line-heightvertical-align学习总结.html":{"url":"line-heightvertical-align学习总结.html","title":"line-height && vertical-align 学习总结","keywords":"","body":"前言 line-height、font-size、vertical-align是设置行内元素布局的关键属性。这三个属性是相互依赖的关系，改变行间距离、设置垂直对齐等都需要它们的通力合作。 行高 line-height line-height行高是指文本行基线之间的距离。 行高line-height实际上只影响行内元素和其他行内内容，而不会直接影响块级元素，也可以为一个块级元素设置line-height，但这个值只是应用到块级元素的内联内容时才会有影响。 在应用到块级元素时，line-height定义了元素文本基线之间的最小距离，即最小行高 line-height 值: | | | normal | inherit 初始值: normal(通常line-height:normal的值为font-size值的1.2倍) 应用于: 所有元素 继承性: 有 百分数: 相对于元素的字体大小font-size [注意]如果块级元素中的某一个子级内联元素设置的“行高”比“最小行高”大，则行框以设置“行高”来渲染；如果小，则以“最小行高”来渲染。因为，每一个子级内联元素的行高都是行内框的高度，只有一行中所有的行内元素(包括代表父级元素的匿名文本)，最大的行内框高度才能成为整行的行高。 效果展示： 重要概念 【内容区】 对于行内非替换元素或匿名文本某一部分，font-size确定了内容区的高度 【行内框】 内容区加上行间距等于行内框。如果一个行内非替换元素的font-size为15px，line-height为21px，则相差6px。用户代理将这6像素一分为二，将其一半分别应用到内容区的顶部和底部，这就得到了行内框 当line-height小于font-size时，行内框实际上小于内容区 【行框】 行框定义为行中最高行内框的顶端到最低行内框底端之间的距离，而且各行框的顶端挨着上一行行框的底端 【框属性】内边距、外边距和边框不影响行框的高度，即不影响行高 行内元素的边框边界由font-size而不是line-height控制 外边距不会应用到行内非替换元素的顶端和底端 margin-left、padding-left、border-left应用到元素的开始处；而margin-right、padding-right、border-right应用到元素的结尾处 效果展示： 【替换元素】行内替换元素需要使用line-height值，从而在垂直对齐时能正确地定位元素。因为vertical-align的百分数值是相对于元素的line-height来计算的。对于垂直对齐来说，图像本身的高度无关紧要，关键是line-height的值 默认地，行内替换元素位于基线上。如果向替换元素增加下内边距、外边距或边框，内容区会上移。 替换元素的基线是正常流中最后一个行框的基线。除非，该替换元素内容为空或者本身的overflow属性值不是visible，这种情况下基线是margin底边缘 垂直对齐 vertical-align用来设置垂直对齐方式，所有垂直对齐的元素都会影响行高 值: baseline | sub | super | top | text-top | middle | bottom | text-bottom | | | inherit 初始值: baseline 应用于: 行内元素、替换元素、表单元格 继承性: 无 百分数: 相对于元素的行高line-height [注意]IE7-浏览器中vertical-align的百分比值不支持小数行高，且取baseline、middle、text-bottom等值时与标准浏览器在展示效果不一样，常用的解决办法是将行内元素设置display:inline-block vertical-align:baseline(元素的基线与父元素的基线对齐) vertical-align:sub(降低元素的基线到父元素合适的下标位置) vertical-align:super(升高元素的基线到父元素合适的上标位置) vertical-align:bottom(把对齐的子元素的底端与行框底端对齐) vertical-align:text-bottom(把元素的底端与父元素内容区域的底端对齐) vertical-align:top(把对齐的子元素的顶端与行框顶端对齐) vertical-align:text-top(把元素的顶端与父元素内容区域的顶端对齐) vertical-align:middle(元素的中垂点与父元素的基线加1/2父元素中字母X的高度对齐) vertical-align:(+-n)px(元素相对于基线上下偏移npx) vertical-align:x%(相对于元素的line-height值) vertical-align:inherit(从父元素继承vertical-align属性的值) 效果展示： 【inline-block底部空隙】 inline-block元素在块级元素中留空隙就是因为图像的默认垂直对齐方式是基线对齐(基线对齐在原理上相当于图像底边与匿名文本大写英文字母X的底边对齐)；而匿名文本是有行高的，继承父级元素设置的行高，默认为normal(即font-size的1.2倍)，所以X的底边距离行框有一段距离，这段距离就是图像留出的空隙 于是，解决这个问题有以下几个解决办法 2、父级的line-height: 0这样使匿名文本与行框的距离为0 3、vertical-align: top/middle/bottom 内联块元素底部空隙消除演示： 应用 【1】单行文本水平垂直居中 div{ line-height: 100px; width: 100px; text-align: center; border: 1px solid black; } [注意]好多地方都写着单行文本垂直居中是将高度和行高设置成一样的值，但高度其实是没有必要设置的。仅仅设置行高就可以，文字在一行中本身就是垂直居中显示的 效果展示： 【2】图片近似垂直居中 div{ line-height: 200px; text-align: center; } img{ vertical-align: middle; } 由于字符X在em框中并不是垂直居中的，且各个字体的字符X的高低位置不一致。所以，当字体大小较大时，这种差异就更明显 效果展示： 【3】图片完全垂直居中 在方法2的基础上设置块级元素的font-size为0，则可以设置图片完全垂直居中 div{ line-height: 200px; text-align: center; font-size: 0; } img{ vertical-align: middle; } 效果展示： 【4】多行文本水平垂直居中由于方法3设置font-size为0的局限性，块级元素里面无法放置文本。方法4主要通过新增元素来实现垂直居中效果，该方法也可用于图片的水平垂直居中 div{ height: 100px; width: 200px; background-color: pink; text-align: center; } span{ display:inline-block; vertical-align: middle; line-height: 20px; width: 100px; } i{ display: inline-block; height: 100%; vertical-align: middle; } 我是特别长的特别长的特别长的特别长的多行文字 效果展示： 【5】图标和文本对齐 1、使用长度负值 img{ vertical-align: -5px; } 根据实践经验，20*20像素的图标后面跟14px的文字，vertical-align设置为-5px可以达到比较好的对齐效果 2、使用文本底部对齐 img{ vertical-align: text-bottom; } 使用baseline会使图标偏上；使用top/bottom会受到其他行内元素影响造成定位偏差；使用middle需要恰好的字体大小且兼容性不高；使用text-bottom较合适，不受行高及其他内联元素影响 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 07:25:07 "},"深入学习CSS外边距margin重叠效果，margin传递效果，marginauto实现块级元素.html":{"url":"深入学习CSS外边距margin重叠效果，margin传递效果，marginauto实现块级元素.html","title":"深入学习CSS外边距margin（重叠效果，margin传递效果，margin:auto实现块级元素）","keywords":"","body":"前言 margin是盒模型几个属性中一个非常特殊的属性。简单举几个例子：只有margin不显示当前元素背景，只有margin可以设置为负值，margin和宽高支持auto，以及margin具有非常奇怪的重叠特性。 重叠 margin重叠又叫margin合并，发生这种情况有两个前提1、只发生在block元素上(不包括float、absolute、inline-block元素)2、只发生在垂直方向上(不考虑writing-mode) 【相邻的兄弟元素】 margin重叠效果展示：item1 和 item2 是相邻的块级元素，我们可以看到垂直方向上，发生了margin重叠效果 具体的叠加规则是什么？ 正正取大值、正负值相加、负负最负值 【margin传递】 父级元素和第一个或最后一个子元素，父子级的margin重叠又叫margin传递 条件相对比相邻兄弟元素margin重叠来说，父子级margin重叠需要满足以下几个条件(以margin-top重叠为例)：a、父元素不是BFC元素 b、父元素没有padding-top值 c、父元素没有border-top值 d、父元素和第一个子元素之间没有inline元素分隔 如果是父子级的margin-bottom重叠，第d条改为父元素和最后一个子元素之间没有inline元素分隔，以及还需要满足父元素没有height、min-height、max-height限制 效果展示：在item1上面添加一个margin-top:20px;时父元素跟着一起下来了20px，这种现象就叫做“margin传递”。我们通过在父元素上添加一些属性就可以破坏margin传递，下面是实际案例，可以动手点点 【空的block元素】先看下HTML结构 效果展示：第一步：我们选择了margin:20px 0; 此时你会发现你一点变化都没有，为什么父元素没有被撑开？第二步：我们再选择父元素的overflow:hidden，你会发现这时候可以看到父元素的浅蓝色背景色了，但是明明是上下margin都是20px一起应该是40px，可是父元素高度只有20px。 [注意]实际布局时，极少情况下我们会如此布局。 第一步解释： 父元素如果不是BFC的情况下，子元素margin-top margin-bottom 是不会撑开父元素的高度。 第二步解释：则是发生了margin重叠，同样地，空block元素发生margin重叠也需要满足一些条件 a、子元素(case-item)没有border值 b、子元素(case-item)没有padding值 c、里面没有inline元素 d、子元素(case-item)没有height或min-height 效果展示： -webkit-margin-collapse -webkit-margin-collapse: (默认重叠) | (取消) | (分隔) 效果展示： auto 只有width/height和margin可以设置auto。 【为什么margin:auto无法实现垂直居中】水平方向可以居中是因为块级元素的宽度默认是撑满父级元素的，如果给宽度设置一个固定值，而左右margin设置为auto，则可以平分剩余空间 垂直方向不可以居中是因为块级元素的高度默认是内容高度，与父级元素的高度并没有直接的关系，而上下margin设置为auto，则被重置为0 【为什么图片使用margin:auto不能水平居中】图片无法水平居中，类似于块级元素无法垂直居中。因为图片的宽度width默认是自身宽度，与父元素的宽度没有直接关系。左右margin设置为auto，会被重置为0 所以，图片要水平居中，需要设置为display:block元素 【实现垂直居中】使用margin:auto实现垂直居中，有以下两种方法 1、使用writing-mode:vertical-lr;writing-mode代表页面流方向，默认是水平方向。改为垂直方向后，可实现垂直居中，但水平不居中了 2、将元素变为绝对定位元素(IE7-浏览器不支持)将元素变为绝对定位元素后，设置top:0;bottom:0;left:0;right:0;，使绝对定位元素与定位父级的高度和宽度有了直接的联系。再设置margin:auto;，使margin-top，margin-bottom，margin-left,margin-right平分剩余空间，达到水平垂直居中的效果 效果展示： 小结 通过本文我们学习了：margin重叠的几种情况(块级元素之间，父子之间的margin传递) -webkit-margin-collapse设置是否重叠的新属性margin auto的一些情况，例如块级元素margin:auto;为什么无法垂直居中，图片margin:auto为什么无法水平居中 最后通过position:absolute配合margin:auto;实现水平垂直居中显示 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 07:31:16 "},"CSSmargin负值学习及实际应用.html":{"url":"CSSmargin负值学习及实际应用.html","title":"CSS margin负值学习及实际应用","keywords":"","body":"前言 margin属性在实际中非常常用，也是平时踩坑较多的地方。margin折叠部分相信不少人都因为这样那样的原因中过招。margin负值也是很常用的功能，很多特殊的布局方法都依赖于它。 表现 虽然margin可以应用到所有元素，但display属性不同时，表现也不同 【1】block元素可以使用四个方向的margin值 【2】inline元素使用上下方向的margin值无效 【3】inline-block使用上下方向的margin负值看上去无效 [注意]inline-block使用上下方向的margin负值只是看上去无效，这与其默认的vertical-align:baseline有关系，当垂直对齐的属性值为其他值时，则会显示不同的视觉效果 效果展示： 重叠 margin负值并不总是后面元素覆盖前面元素，它与元素display属性有关系 【1】两个block元素重叠时，后面元素可以覆盖前面元素的背景，但无法覆盖其内容 【2】当两个inline元素，或两个line-block元素，或inline与inline-block元素重叠时，后面元素可以覆盖前面元素的背景和内容 【3】当inline元素(或inline-block元素)与block元素重叠时，inline元素(或inline-block元素)覆盖block元素的背景，而内容的话， 后面的元素覆盖前面的元素 综上所述，个人理解，在普通流布局中，浏览器将页面布局分为内容和背景，内容的层叠显示始终高于背景。block元素分为内容和背景，而inline元素或inline-block元素，它本身就是内容(包括其背景等样式设置) 效果展示： 应用 【1】水平垂直居中 如果要居中的元素的宽/高是不变的或者说是确定的，比如width/height=100px，那么设置absolute的top/left=50%，然后margin-left/margin-top=-50px即可 如果要居中的元素的宽/高是不确定的，这时margin负值就不能使用具体的px了，可以使用百分比。但由于margin的百分比都是相对于包含块的宽度，所以这里限制了只能设置宽高相同的居中元素。包含块的宽度如何获得呢？利用absolute的包裹性，在需要居中的元素外面套一个空的元素即可 .box{ position:relative; width: 200px; height: 200px; background-color: lightgreen; border: 2px solid black; } .out{ position: absolute; left: 50%; top: 50%; } .in{ height: 100px; width: 100px; background-color: pink; margin-left: -50%; margin-top: -50%; } 测试内容 效果展示： 【2】列表项两端对齐 比如外层元素宽度为200px，内层3个元素，宽度为60px，margin-right为10px。这里，正常流中块级元素框的水平总和总共为210px，超过了父元素的宽度200px，则第三个元素会被挤下来。当然可以给第三个元素设置margin-right=0。但，这种方法不优雅，为布局而布局，第三个元素并没有什么特殊的，却被设置了特殊的样式 优雅的方法应该是内层元素和外层元素之间包一层元素，设置margin-right=-10px，使块级元素框的水平总和总共为210px - 10px = 200x ，等于父元素的宽度即可 [注意]设置overflow:hidden用于清除浮动 ul{ margin: 0; padding: 0; list-style:none; } .box{ width: 200px; background-color: pink; } .list{ overflow: hidden; margin-right: -10px; } .in{ float: left; width: 60px; height: 100px; background-color: lightgreen; margin-right: 10px; } 1 2 3 效果展示： 【3】三栏自适应布局 中间的主体使用双层标签，外层\\宽度100%显示，并且浮动，内层\\为真正的主体内容，含有左右110px的margin值。左栏和右栏都采用margin负值。左栏左浮动，margin-left为-100%，正好使左栏位于页面左侧。右栏左浮动，大小为其本身的宽度100px html,body{ height: 100%; } body{ margin: 0; } .main{ width: 100%; height: 100%; float: left; } .main .in{ margin: 0 110px; background-color: pink; height: 100%; } .left,.right{ height: 100%; width: 100px; float: left; background-color: lightgreen; } .left{ margin-left: -100%; } .right{ margin-left: -100px; } 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 15:59:20 "},"css浮动float全方位案例解析.html":{"url":"css浮动float全方位案例解析.html","title":"css浮动(float)全方位案例解析","keywords":"","body":"前言 浮动最早的使用是出自，用于文本环绕图片的排版处理。当然也是一种常用的布局方式。 float 浮动 浮动元素脱离普通流，然后按照指定方向，向左或者向右移动，碰到父级边界或者另外一个浮动元素停止 值: left | right | none | inherit(继承) 初始值: none 应用于: 所有元素 继承性: 无 浮动特性 【浮动流】正常流中元素一个接一个排列；浮动元素也构成浮动流 效果展示： 默认是display:block 独占一行，当使用float的时候可以看到形成了一个浮动流。 【块级框】浮动元素自身会生成一个块级框，而不论这个元素本身是什么，使浮动元素周围的外边距不会合并 效果展示： 【包裹性】浮动元素的包含块是指其最近的块级祖先元素，后代浮动元素不应该超出包含块的上、左、右边界。若不设置包含块的高度，包含块若浮动，则包含块会延伸，进而包含其所有后代浮动元素；若不设置包含块的宽度，包含块若浮动，则包含块宽度由后代浮动元素撑开。 通俗的理解就是：子元素若不设置浮动，父元素如果没有设置高度的话，则是由子元素撑开，如果子元素设置了浮动，父元素的高度则不会由子元素撑开。除非父元素也是浮动或者清除浮动，都可以让父元素包裹住子元素 效果展示： 【破坏性】浮动元素脱离正常流，并破坏了自身的行框属性，使其包含块元素的高度塌陷，使浮动框旁边的行框被缩短，从而给浮动框留出空间，行框围绕浮动框重新排列 效果展示： 浮动的主要特性就是以上几点，动起手来多点点案例，就会对这个特性更加熟悉。 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:02:38 "},"css清除浮动.html":{"url":"css清除浮动.html","title":"css清除浮动","keywords":"","body":"前言 之所以要清除浮动，就是解决浮动元素造成的一些问题，如包含块高度塌陷，浮动流造成的布局混乱等问题。 clear清除 值: left | right | both | none | inherit 初始值: none 应用于: 块级元素(块级元素指block元素，不包括inline-block元素) 继承性: 无 left:左侧不允许存在浮动元素 right:右侧不允许存在浮动元素 both:左右两侧不允许存在浮动元素 none:允许左右两侧存在浮动元素 [注意]设置clear属性的元素并不能改变浮动元素，而只能改变自身 CSS2.1引入了一个清除区域，清除区域是在元素上外边距之上增加的额外间隔，不允许任何浮动元素进入这个范围，这意味着元素设置clear属性时，它的外边距不改变 效果展示： 对于标准浏览器来说，清浮动其实就两种方法: 一种是在浮动元素下面添加新元素设置clear属性; 另一种是触发包含块的BFC，使其包含浮动元素。而对于IE7-浏览器，则用到其特有属性haslayout 【clear属性】 [1] [注意]并不是很适用，若包含块为，则子元素只能为，则在后面添加元素不合适 [2] [注意]虽然clear属性只应用于块级元素，但在除IE7-以外的其他浏览器都可以将clear属性应用于元素 [3]为浮动元素的after伪元素设置clear属性 .clear:after{content:\"\"; display: block; clear: both;} [注意]IE7-浏览器不支持after伪元素 【BFC】 触发条件： [1]float: left/right [2]position:absolute/fixed [3]display:inline-block/table-cell/table-caption/flex [4]overflow:hidden/scroll/auto 【IE7-】 关于IE7-浏览器有一个其特有的属性haslayout，当触发包含块的haslayout时，浮动元素被layout元素自动包含 触发条件： [1]display:inline-block [2]height/width:除auto外 [3]float: left/right [4]position: absolute [5]writing-mode: tb-rl [6]zoom: 除normal外 兼容写法 【版本1】 .clear:after{content:\"\"; display: block; clear: both;} .clear{zoom: 1;} // IE6、7兼容 【版本2】 .clearfix:before,.clear:after{content:\"\";display:table;} // 因为display: table会产生一些匿名盒子，这些匿名盒子的其中一个（display值为table-cell）会形成Block Formatting Context。 .cleafixr:after{clear:both;} .clearfix{zoom:1} // IE6、7兼容 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:06:35 "},"定位.html":{"url":"定位.html","title":"定位","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:11:41 "},"CSS定位深入理解定位position的偏移.html":{"url":"CSS定位深入理解定位position的偏移.html","title":"CSS定位 深入理解定位(position)的偏移","keywords":"","body":"前言 CSS有三种基本的布局机制：普通流、浮动和绝对定位。利用定位，可以准确地定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。但元素究竟如何定位，定位到什么位置，主要依靠top/right/bottom/left这四个偏移属性。本文就定位中的偏移做详细介绍 position定位 值: static | relative | absolute | fixed | inherit 初始值: static 应用于: 所有元素 继承性: 无 static:元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中 relative:元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留 absolute:元素框从文档流完全删除，并相对于其包含块定位，包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框 fixed:元素框的表现类似于将position设置为absolute，不过其包含块是视窗本身 [注意]相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置 效果展示： 包含块 【1】根元素根元素HTML的包含块(也称为初始包含块)是一个视窗大小的矩形，即HTML的父级document 【2】非根元素如果position值是relative或static，包含块由最近的块级框、表单元格或行内祖先框的内容边界构成 如果position值是absolute，包含块设置为最近的position值不是static的祖先元素(可以是任何类型)，过程如下: [1]如果这个祖先是块级元素，包含块则设置为该元素的内边距边界。换句话说，就是由边框界定的区域 [2]如果这个祖先是行内元素，包含块则设置为该祖先元素的内容边界 [3]如果没有祖先，元素的包含块定义为初始包含块，即document [注意]由于元素可以定位到其包含块的外面。这与浮动元素使用负外边距浮动到其父元素内容区外面很类似。所以这里包含块实际上应该是定位上下文，或者定位父级 偏移属性 三种定位机制使用了4个属性来描述定位元素各边相对于其包含块的偏移。这4个属性被称为偏移属性。 top/right/bottom/left 值: | | auto | inherit 初始值: auto 应用于: 定位元素(也就是position值不是static的元素) 继承性: 无 百分数: 对于top和bottom，相对于包含块的clientHeight；对于right和left，相对于包含块的clientWidth 这些属性描述了距离包含块最近边的偏移。top描述了定位元素上外边界离其包含块的顶端有多远。如果top为正值，会把定位元素的上外边距边界下移，若为负值，则会把定位元素的上外边距移到其包含块的顶端之上。类似地，left描述了定位元素的左外边距边界在其包含块左边界右边(正值)或左边(负值)有多远。如果是正值，会把定位元素的外边距边界移到包含块左边界右边，而负值则将其移到包含块左边界左边。所以，正值会导致向内偏移，使边界朝着包含块的中心移动，而负值会导致向外偏移。 偏移定位元素的外边距边界时，带来的影响是元素的所有一切(包含外边距、边框、内边距和内容)都会在定位的过程中移动 [注意]定位元素的边界是指定位元素margin外侧的边界；包含块的包含区域是指包含块的border内侧的padding+content区域 效果展示： 绝对定位 元素绝对定位时，会从文档流中完全删除。然后相对于其包含块定位，其边界根据偏移属性(top、left等)放置。定位元素不会流入其他元素的内容，反之亦然。元素绝对定位时，会为其后代元素建立一个包含块 [注意]如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位 当元素绝对定位时，偏移属性表现如下: left:0 元素的左边界(margin-left外侧)位于包含块的左边界内侧(border-left内侧) top:0 元素的上边界(margin-rop外侧)位于包含块的上边界内侧(border-top内侧) right:0 元素的右边界(margin-right外侧)位于包含块的右边界内侧(border-right内侧) bottom:0 元素的下边界(margin-bottom外侧)位于包含块的下边界内侧(border-bottom内侧) 当top、right、bottom、left四个值都为auto时(即都处于默认状态时)， left:auto 元素的左边界位于元素处于静态位置时的左边界 top:auto 元素的上边界位于元素处于静态位置时的上边界 right:auto 元素的右边界位于正好能包裹住元素的横向区域的右边界(margin-right外侧) bottom:auto 元素的下边界位于正好能包裹住元素的纵向区域的下边界(margin-bottom外侧) [注意]元素的静态位置是指元素在正常流中原本的位置，更确切的讲，顶端的静态位置是从包含块的上边界到假想框的上外边距边界之间的距离。假想框是假设元素position属性为static时元素的第一个框。如果这个假想框在包含块的上面，则这个值为负 效果展示： 格式化 对于普通流的元素来说，水平格式化的7大属性是margin-left、border-left、padding-left、width、padding-right、border-right、margin-right7个属性的值加在一起必须是元素包含块的宽度，这往往是块元素的父元素的width值(因为块级元素的父级元素几乎都是块级元素)。垂直方向也类似。 但是对于绝对定位元素则不相同。它的水平格式化等式为: left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = 包含块的clientWidth 类似的，垂直格式化等式为: top + margin-top + border-top-width + padding-top + height + padding-bottom + border-bottom-width + margin-bottom + bottom = 包含块的clientHeight auto auto值是用来弥补实际值与所需总和的差距。 水平方向上，可以为auto的属性有left、margin-left、width、margin-right、right。类似地，垂直方向上，可以为auto的属性有top、margin-top、height、margin-bottom、bottom 1、margin-left:auto; margin-right:auto; left:0; right:0; 块元素可以横向居中显示2、margin-top:auto; margin-bottom:auto; top:0; right:0; 块元素可以纵向居中显示 结合上面两点可以实现水平垂直居中显示 [注意1]IE7-浏览器不支持绝对定位元素通过将上下外边距设置为auto来实现垂直居中的行为 [注意2]IE6-浏览器不支持绝对定位元素不设置宽度，而通过设置top/left/right/bottom来撑开宽高的行为 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:14:58 "},"字体.html":{"url":"字体.html","title":"字体和文本","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:16:25 "},"CSSfont字体知识学习.html":{"url":"CSSfont字体知识学习.html","title":"CSS font字体知识学习","keywords":"","body":"字体系列 【1】5种通用字体系列：拥有相似外观的字体系列 serif字体:字体成比例，且有上下短线(衬线字体)，包括Times\\Georgia\\New century Schoolbook sans-serif字体:字体成比例，且没有上下短线(无衬线字体)，包括Helvetica\\Geneva\\Verdana\\Arial\\Univers Monospace字体:字体不成比例，等宽字体，包括Courier\\Courier New\\Andale Mono Cursive字体:手写体，包括Zapf Chancery\\Author\\Comic Sans Fantasy字体:无法归类的字体，包括Western\\Woodblock\\Klingon 【2】特定字体系列：具体的字体系列 font-family:\"宋体\"; font-family:\"arial\"; 【3】默认字体系列chrome/opera:\"宋体\" firefox:\"微软雅黑\" safari/IE:Times,\"宋体\" font-family:字体系列1,字体系列2 …… //【注意】若浏览器识别第一个字体，则以第一个字体显示；如果不识别，则尝试下一个。 font-family: arial，“宋体”,“微软雅黑”; //【注意】若写英文字体，一定要把英文字体写在前面，英文字体会影响到英文、数字和标点符号。 font-family: Times, 'New Century Schoolbook','New York', serif; //【注意】若字体名中有一个或多个空格，要添加引号 【4】中文字体 对于中文字体来说，常见的是宋体和微软雅黑。宋体是衬线字体，而微软雅黑是无衬线字体。衬线字体常用于排版印刷，而无衬线字体则常用于网页中 一般地，一行中有30-40个文字时，行高为1.5时，有较好的阅读体验。对于标题来说， 更好的样式是取消其加粗设置，并改变其颜色，增加页面的层次感 字体加粗 【1】常用值 font-weight: normal(正常，默认) font-weight: bold(加粗) 【2】所有值normal(正常)/bold(粗体)/bolder(更粗)/lighter(更细)100/200/300/400/500/600/700/800/900 (100为最细，900为最粗) 字体大小 【1】绝对字体大小：xx-small/x-small/small/medium/large/x-large/xx-large 【2】相对字体大小：smaller/larger 【3】em/%：1em = 100% 【4】默认字体大小：chrome/firefox/opera/IE/safari:16px 【5】最小字体大小：chrome:12px opera:9px safari/IE/firefox:无 font-size font-size字体大小设置的是字体中字符em框的高度，实际的字符字形通常比字符em框要矮，与字体类型有关 值: xx-small | x-small | small | medium | large | x-large | xx-large | smaller | larger | | | inherit 初始值: medium 应用于: 所有元素 继承性: 有 百分数: 相对于父元素的字体大小font-size 效果展示： 字体风格 font-style: normal(默认) font-style: italic(斜体) font-style: oblique(倾斜) 字体 font: [[ || || ]? [/?] [注意]对于font-size，百分数相对于父元素来计算；对于line-height，百分数相对于元素的font-size来计算 关键字 CSS标准定义了6个系统字体关键字： caption: 由标题控件使用的字体样式，如按钮和下拉控件 icon: 系统图标所用的字体样式，如文件夹和文件图标 menu: 下拉菜单和菜单列表中文本使用的字体样式 message-box: 对话框中文本使用的字体样式 small-caption: 由标题小控件的标签使用的字体样式 status-bar: 窗口状态条中文本使用的字体样式 font-face @font-face { font-family: 自定义名称; src: url(../font/test.eot); src: url(../font/test.eot?#iefix) format(\"embedded-opentype\"), url(../font/test.woff) format(\"woff\"), url(../font/test.ttf) format(\"truetype\"), url(../font/test.svg#jq) format(\"svg\"); } EOT:IE专用 WOFF:标准 TTF:最常见(safari/android/ios) SVG:图形格式(IE和firefox不支持) 两种调用字体的方法 【1】html(&#x + 小图标对应的unicode编码) div{ font-family: 自定义名称; -webkit-font-smoothing:antialiased;//字体抗锯齿、光滑度属性 -mox-osx-font-smoothing: grayscale;//字体抗锯齿、光滑度属性 } &#xf048 【2】css(\\ + 小图标对应的unicode编码)(不兼容IE7-浏览器) div{ font-family: 自定义名称; -webkit-font-smoothing:antialiased;//字体抗锯齿、光滑度属性 -mox-osx-font-smoothing: grayscale;//字体抗锯齿、光滑度属性 } div:before{ content: \"\\f048\"; } 具体实例：有一篇专门的文章讲解iconfont网站字体使用的过程，点击查看：iconfont实战 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:19:44 "},"CSSiconfont阿里巴巴矢量图库在开发中实战使用.html":{"url":"CSSiconfont阿里巴巴矢量图库在开发中实战使用.html","title":"CSS iconfont阿里巴巴矢量图库在开发中实战使用","keywords":"","body":"前言 项目开发中，是避免不了使用小图标的，那么国内比较好用的图标网站当属iconfont了，下面我们将详细介绍如何使用。 iconfont选择所需图标 1、iconfont官网 2、把所需要的添加进入购物车 3、添加所需图标完毕后，点击右上角的购物车图标 4、下载代码 5、下载的代码解压后 图片上圈起来的都是字体文件 6、项目中新建一个font文件夹用来放置字体文件 7、取出iconfont.css文件放入css文件夹 8、打开iconfont.css文件，配置正确的字体文件路径 // 这里要根据自己的项目配置正确的字体路径：../font/iconfont.eot @font-face {font-family: \"iconfont\"; src: url('../font/iconfont.eot?t=1554343058030'); /* IE9 */ src: url('../font/iconfont.eot?t=1554343058030#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('这里省略的base64字符...') format('woff2'), url('../font/iconfont.woff?t=1554343058030') format('woff'), url('../font/iconfont.ttf?t=1554343058030') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('../font/iconfont.svg?t=1554343058030#iconfont') format('svg'); /* iOS 4.1- */ } // 这个文件是下载字体时系统自带的 .iconfont { font-family: \"iconfont\" !important; // 这里的iconfont 和上面定义的font-family一定要是一样的 font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } // 下面是自动生成的图标类，可以直接引用 .icon-icon_add:before { content: \"\\eb8f\"; } .icon-icon_addmessage:before { content: \"\\eb90\"; } .icon-icon_addresslist:before { content: \"\\eb91\"; } .icon-icon_affiliations_li:before { content: \"\\eb92\"; } 9、项目中使用 /* 正确使用一个icon */ 这样我们就可以愉快的使用icon了 效果展示： 【font-class】我们引用icon的方式是通过class的方式引入的。具有以下特点： 兼容性良好，支持 IE8+，及所有现代浏览器。 相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 [注意] 之所以兼容IE8+是因为使用了before伪元素 【Symbol 引用】这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。这种用法其实是做了一个 SVG 的集合，与class引入相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过 font-size, color 来调整样式。 兼容性较差，支持 IE9+，及现代浏览器。 浏览器渲染 SVG 的性能一般，还不如 png。 【使用方式】引入下载下来的iconfont.js到相应文件夹 HTML文件中引入iconfont.js HTML中使用svg font /* 添加svg样式 */ .icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } 现在页面上也可以正确渲染图标了。 小结 目前来说，常用的方法就是上面两种了，我们团队目前使用的是class方式引用。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:25:21 "},"布局.html":{"url":"布局.html","title":"布局","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 16:25:35 "},"CSSGrid基于网格的二维布局系统详细教程.html":{"url":"CSSGrid基于网格的二维布局系统详细教程.html","title":"CSS Grid基于网格的二维布局系统(详细教程)","keywords":"","body":"前言 Grid布局方式借鉴了平面装帧设计中的格线系统，将格线运用在屏幕上，而不再是单一的静态页面，可以称之为真正的栅格。本文将详细介绍grid布局 布局历史 对于Web开发者来说，网页布局一直是个比较重要的问题。但实际上，在网页开发很长的一段时间当中，我们甚至没有一个比较完整的布局模块。总的来说 Web 布局经历了以下四个阶段：1、table表格布局，通过 Dreamweaver拖拽表格或者手写 table 标签布局2、float浮动及position定位布局，借助元素元素盒模型本身的特性以及 float position 等属性等进行布局3、flex弹性盒模型布局，革命性的突破，解决传统布局方案上的三大痛点 排列方向、对齐方式，自适应尺寸。是目前最为成熟和强大的布局方案4、grid栅格布局，二维布局模块，具有强大的内容尺寸和定位能力，适合需要在两个维度上对齐内容的布局 Grid Layout 是一种基于二维网格的布局系统，旨在完全改变我们设计基于网格的用户界面的方式，弥补网页开发在二维布局能力上的缺陷与flex分为伸缩容器和伸缩项目类似，grid也分为网格容器和网格项目 gird 网格布局（Grid）是最强大的 CSS 布局方案。 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 基本概念 容器和项目 采用网格布局的区域，称为\"容器\"（container）。容器内部采用网格定位的子元素，称为\"项目\"（item）。 item1 item2 item3 grid-main : grid 容器grid-item : 项目 目前已经越来越多浏览器开始兼容grid布局了。 点击查看兼容 行和列 容器里面的水平区域称为\"行\"（row），垂直区域称为\"列\"（column）。 单元格 行和列的交叉区域，称为\"单元格\"（cell）。 正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。 网格线 划分网格的线，称为\"网格线\"（grid line）。水平网格线划分出行，垂直网格线划分出列。 正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。 网格容器 Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。 display 属性 通过display属性设置属性值为grid或inline-grid可以创建一个网格容器。网格容器中的所有子元素就会自动变成网格项目（grid item） display: grid display: inline-grid 效果展示： grid-template-columns && grid-template-rows 属性 grid-template-columns 属性定义每一列的列宽；grid-template-rows 属性定义每一行的行高 // item1和item2具有固定的高，分别为60px和40px。因为只定义了两个行的高度值，所以item3和item4的高度是根据其自身的内容来定义。 grid-template-rows: 60px 40px // 因为grid-template-columns只定义了三列的大小，它们也分别放置在列1、列2和列3；其中列1、列2和列3的尺寸大小等于item1、item2和item3宽度。 grid-template-columns: 40px 50px 60px 效果展示 fr fr单位可以帮助我们创建一个弹列的网格轨道。它代表了网格容器中可用的空间（就像Flexbox中无单位的值） // 网格容器分成了4等份（1 + 1 + 2 = 4），每一份（1fr）是网格容器宽度的四分之一。所以item1和item2的宽度是网格容器的四分之一宽，item3是网格容器宽度的四分之二（2fr） grid-template-columns: 1fr 1fr 2fr // 当fr和其它长度单位的值结合在一起的时候，fr是基于网格容器可用空间来计算。 // 网格容器可用空间是网格宽度减去3rem和25%剩下的宽度，而fr就是基于这个尺寸计算： grid-template-columns: 3rem 25% 1fr 2fr // 1fr = (网格宽度 - 3rem - 网格宽度 * 25%) / 3 效果展示 minmax() 可以通过minmax()函数来创建网格轨道的最小或最大尺寸。minmax()函数接受两个参数：第一个参数定义网格轨道的最小值，第二个参数定义网格轨道的最大值。可以接受任何长度值，也接受auto值。auto值允许网格轨道基于内容的尺寸拉伸或挤压 grid-template-rows: minmax(100px, auto); // 第一行的高度最小值是100px，但其最大值为auto，允许行的高度可以变大超过100px。 grid-template-columns: minmax(auto, 50%) 1fr 3em; // 第一列设置了最小值为auto，但它的最大值是50%，也就是列的最大宽度不会超过网格容器宽度的50% 效果演示 repeat() 使用repeat()可以创建重复的网格轨道。这个适用于创建相等尺寸的网格项目和多个网格项目。repeat()接受两个参数：第一个参数定义网格轨道应该重复的次数，第二个参数定义每个轨道的尺寸。 grid-template-rows: repeat(3, 1fr); // 第一列和最后一列的宽度都是30px，并且它们之间有另列三列，这三列是通过repeat()来创建的，而且每列的列宽是1fr（1fr = (网格宽度 - 30px - 30px) / 3） grid-template-columns: 30px repeat(3, 1fr) 30px; 效果演示 间距 【grid-column-gap】创建列与列之间的间距 【grid-row-gap】创建行与行之间的间距 【grid-gap】默认值为0 grid-gap是grid-row-gap和grid-column-gap两个属性的缩写，如果它指定了两个值，那么第一个值是设置grid-row-gap的值，第二个值设置grid-column-gap的值。如果只设置了一个值，表示行和列的间距相等，也就是说grid-row-gap和grid-column-gap的值相同 [注意]grid-gap只能创建列与列或行与行之间的间距，但不能创建列和行与网格容器边缘的间距间距(Gap)可以设置任何非负值，长度值可以是px、%、em等单位值 效果演示 以上是设置在容器上的属性和值，下面介绍设置在项目上的属性和值 网格项目 item 网格线 项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 【grid-row-start】上边框所在的水平网格线 【grid-row-end】下边框所在的水平网格线 【grid-column-start】左边框所在的垂直网格线 【grid-column-end】右边框所在的垂直网格线 默认值为 auto 通俗来讲就是“一个网格”其实位置和结束位置 .item1 { grid-column-start: 2; grid-column-end: 4; } 上面代码指定，item1项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 效果演示： 【grid-column】grid-column是grid-column-start和grid-column-end的简写。 【grid-row】grid-row是grid-row-start和grid-row-end的简写。 默认值为auto 如果只提供一个值，则指定了grid-row-start(grid-column-start)值；如果提供两个值，第一个值是grid-row-start(grid-column-start)的值，第二个值是grid-row-end(grid-column-end)的值，两者之间必须要用/隔开 【span】关键词span后面紧随数字，表示合并多少个列或行 效果展示 【grid-area】如果指定四个值，第一个值对应grid-row-start，第二个值对应grid-column-start，第三个值对应grid-row-end，第四个值对应grid-column-end 网格线命名 grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 .container { display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4]; } 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格区域命名 【grid-template-areas】像网格线名称一样，网格区域的名称可以使用grid-template-areas属性来命名。引用网格区域名称也可以设置网格项目位置 grid-template-areas: \"header header\" \"content sidebar\" \"footer footer\"; grid-template-rows: 150px 1fr 100px; grid-template-columns: 1fr 200px; 设置网格区域的名称应该放置在单引号或双引号内，每个名称由一个空格符分开。网格区域的名称，每组（单引号或双引号内的网格区域名称）定义了网格的一行，每个网格区域名称定义网格的一列 [注意]grid-template-areas: \"header header\" \"content sidebar\" \"footer footer\";不可以简写为grid-template-areas: \"header\" \"content sidebar\" \"footer\"; 效果展示 隐式网格 【grid-auto-flow】网格默认流方向是row，可以通过grid-auto-flow属性把网格流的方向改变成column 效果展示 【grid-auto-rows】【grid-auto-columns】 有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行。所以grid-auto-rows会作用于item8，请手动操作下 网格项目层级 网格项目可以具有层级和堆栈，必要时可能通过z-index属性来指定 .item-1,.item-2 { grid-row-start: 1; grid-column-end: span 2; } .item-1 { grid-column-start: 1; z-index: 1; } .item-2 { grid-column-start: 2 } 在这个例子中，item1和item2的开始行都是1，item1列的开始是1，item2列的开始是2，并且它们都跨越两列。两个网格项目都是由网格线数字定位，结果这两个网格项目重叠了。 默认情况下，item2在item1上面，但是，我们在item1中设置了z-index:1;，导致item1在item2之上 效果展示：通过控制z-index的值，可以看得出item1 和 item2的层级关系 对齐 【justify-items】【justify-self】【align-items】【align-self】 justify-items和justify-self指定网格项目沿着行轴对齐方式；align-items和align-self指定网格项目沿着列轴对齐方式。 justify-items和align-items应用在网格容器上 align-self和justify-self属性用于网格项目自身对齐方式 这四个属性主要接受以下属性值：auto | normal | start | end | center | stretch | baseline | first baseline | last baseline 效果展示 综合效果来看，都是在网格线内进行移动的对齐的。 【align-content】属性是整个内容区域的垂直位置（上中下）【justify-content】属性是整个内容区域在容器里面的水平位置（左中右） 支持的属性值 normal | start | end | center | stretch | space-around | space-between | space-evenly | baseline | first baseline | last baseline 效果演示 小结 grid的属性和值是非常的多，初看一遍感觉很难懂，但是仔细按照例子操作下会发现grid是非常强大的布局系统的。赶快用起来把！ Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 17:50:10 "},"CSS布局flex布局.html":{"url":"CSS布局flex布局.html","title":"CSS布局-flex布局","keywords":"","body":"前言 2009年，W3C 提出了一种新的方案----Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 查询兼容 Flex 布局是什么 Flex 是 Flexible Box 的缩写，意为\"弹性布局\"，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .flexBox{ display: flex; display: inline-flex; display: -webkit-flex; } [兼容]Webkit 内核的浏览器，必须加上-webkit前缀。[注意]设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 效果展示： 基本概念 【容器】【项目】采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"容器\"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"项目\"。 【水平的主轴】【垂直的交叉轴】主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性 以下6个属性设置在容器上 flex-direction flex-wrap flex-flow justify-content align-items align-content 【flex-direction】 direction属性决定主轴的方向（即项目的排列方向）。 属性值 .flexBox { flex-direction: row | row-reverse | column | column-reverse; } row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 效果展示： 【flex-wrap】默认情况下，项目都排在一条线（又称\"轴线\"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } nowrap(默认)：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 效果展示： 【flex-flow】flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: || ; } 效果展示： 【justify-content】 justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 效果展示： 【align-items】 align-items属性定义项目在交叉轴上如何对齐 .box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 效果展示： 【align-content】 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 效果展示： 项目的属性 以下6个属性设置在项目上 order flex-grow flex-shrink flex-basis flex align-self 【order】order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: ; } 效果展示： 设置item1的order为1时 其它item都是0 所以item1跑到最后面去了 【flex-grow】 flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 .item { flex-grow: ; /* default 0 */ } 效果展示： 【flex-shrink】 flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: 1; } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 【flex-basis】 flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 效果展示： 【flex属性】 flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ ? || ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 效果展示参考上一个。 【align-self】 align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 效果展示： 小结 本文大部分都是参考阮大神的文章，只不过自己制作了点小例子供学习参考 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 17:54:41 "},"CSS水平垂直居中的几种实现方法.html":{"url":"CSS水平垂直居中的几种实现方法.html","title":"CSS 水平垂直居中的几种实现方法","keywords":"","body":"前言 项目中经常碰到需要实现水平垂直居中的样式。下面就总结几种常用的方法 水平对齐+行高 【思路一】text-align + line-height实现单行文本水平垂直居中 .f10 .test{ text-align: center; line-height: 100px; } 测试文字 效果展示： 水平+垂直对齐 【思路二】text-align + vertical-align【1】在父元素设置text-align和vertical-align，并将父元素设置为table-cell元素，子元素设置为inline-block元素[注意]若兼容IE7-浏览器，将结构改为\\结构来实现table-cell的效果；用display:inline;zoom:1;来实现inline-block的效果 .f11 .parent{ display: table-cell; text-align: center; vertical-align: middle; } .f11 .child{ width: 80px; display: inline-block; } 测试文字 效果展示： 【2】若子元素是图像，可不使用table-cell，而是其父元素用行高替代高度，且字体大小设为0。子元素本身设置vertical-align:middle .f12 .parent{ line-height: 200px; text-align: center; font-size:0; } .f12 .child{ vertical-align: middle; } 效果展示： 相关资料 margin + vertical-align 要想在父元素中设置vertical-align，须设置为table-cell元素；要想让margin:0 auto实现水平居中的块元素内容撑开宽度，须设置为table元素。而table元素是可以嵌套在tabel-cell元素里面的，就像一个单元格里可以嵌套一个表格 [注意]若兼容IE7-浏览器，需将结构改为\\结构 .f13 .parent{ display:table-cell; vertical-align: middle; } .f13 .child{ display: table; margin: 0 auto; } 测试文字 效果展示： 绝对定位 【1】利用绝对定位元素的盒模型特性，在偏移属性为确定值的基础上，设置margin:auto .f14 .parent{ position: relative; } .f14 .child{ position: absolute; top: 0; left: 0; right: 0; bottom: 0; height: 50px; width: 80px; margin: auto; } 测试文字 效果展示： 【2】利用绝对定位元素的偏移属性和translate()函数的自身偏移达到水平垂直居中的效果[注意]IE9-浏览器不支持 .f15 .parent{ position: relative; } .f15 .child{ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); } 测试文字 效果展示： flex [注意]IE9-浏览器不支持 【1】在伸缩项目上使用margin:auto .f16 .parent{ display: flex; } .f16 .child{ margin: auto; } 测试文字 效果展示： 【2】在伸缩容器上使用主轴对齐justify-content和侧轴对齐align-items .f17 .parent{ display: flex; justify-content: center; align-items: center; } 测试文字 效果展示： grid [注意]IE10-浏览器不支持【1】在网格项目中设置justify-self、align-self或者margin: auto .f18 .parent{ display: grid; } .f18 .child{ align-self: center; justify-self: center; } 测试文字 效果展示： 【2】在网格容器上设置justify-items、align-items或justify-content、align-content .f19 .parent{ display: grid; /*align-items: center;*/ /*justify-items: center;*/ align-content: center; justify-content: center; } 测试文字 效果展示： Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 17:57:59 "},"CSS布局两列布局之单列定宽,单列自适应布局思路.html":{"url":"CSS布局两列布局之单列定宽,单列自适应布局思路.html","title":"CSS布局 两列布局之单列定宽,单列自适应布局思路","keywords":"","body":"前言 说起自适应布局方式，单列定宽单列自适应布局是最基本的布局形式。比如斗鱼的直播间，后台管理系统都是常用的 我们将从 float, inline-block, table, absolute, flex, grid 这几个布局方式来实现这种效果 float 【float + margin】 将定宽的一列使用float，而自适应的一列使用计算后的margin .f1 .parent{overflow: hidden;zoom: 1;} // 触发bfc和haslayout来闭合浮动 .f1 .left{position: relative;float: left;width: 100px;} // width: 100% 以免浮动后内容撑开宽度。 margin-left: -100px; 由于宽度设置100%这会挤到下一行去了，利用margin 负值特性来规避 .f1 .rightWrap{float: left;width: 100%;margin-left: -100px;} .f1 .right{margin-left: 120px;} left right right 效果展示： 【float + margin + calc】[注意]IE8-、android4.3-、IOS5.1-不支持，android4.4+只支持加减运算 .f2 .parent{overflow: hidden;zoom: 1;} .f2 .left{float: left;width: 100px;margin-right: 20px;} .f2 .right{float: left;width: calc(100% - 120px);} // 利用calc可以不同长度单位进行动态计算的特性 left right right 效果展示: 【float + overflow】还可以使用overflow属性来触发bfc，来阻止浮动造成的文字环绕效果。由于使用overflow不会改变元素的宽度属性，所以不需要重新设置宽度。由于设置overflow:hidden并不会触发IE6-浏览器的haslayout属性，所以需要设置zoom:1来兼容IE6-浏览器 .f3 .parent{overflow: hidden;zoom: 1;} .f3 .left{float: left;width: 100px;margin-right: 20px;} .f3 .right{overflow:hidden;zom:1;} // 触发bfc和haslayout left right right 效果展示: inline-block inline-block内联块布局的主要缺点是需要设置垂直对齐方式vertical-align，则需要处理换行符解析成空格的间隙问题。IE7-浏览器不支持给块级元素设置inline-block属性，兼容代码是display:inline;zoom:1; 【inline-block + margin + calc】一般来说，要解决inline-block元素之间的间隙问题，要在父级设置font-size为0，然后在子元素中将font-size设置为默认大小 [注意]IE8-、android4.3-、IOS5.1-不支持，android4.4+只支持加减运算 .f4 .parent{font-size:0;} .f4 .left{ display: inline-block; vertical-align: top; width: 100px; margin-right: 20px; font-size: 16px; } .f4 .right{ display: inline-block; vertical-align: top; width: calc(100% - 120px); font-size: 16px; } left right right 效果展示: 【inline-block + margin + margin负值】 .f5 .parent{ font-size: 0; } .f5 .left{ position: relative; display: inline-block; vertical-align: top; width: 100px; font-size:16px; } .f5 .rightWrap{ display: inline-block; vertical-align: top; width: 100%; margin-left: -100px; font-size: 16px; } .f5 .right{margin-left: 120px;} left right right 效果展示: table 使用table布局的缺点是元素被设置为table后，内容撑开宽度，所以需要设置width:100%。若要兼容IE7-浏览器，需要改为\\结构。由于table-cell元素无法设置margin，若需要在元素间设置间距，需要增加结构 .f6 .parent{display:table;width: 100%;table-layout: fixed;} .f6 .left,.f6 .rightWrap{display:table-cell;} .f6 .left{width: 100px;} .f6 .right{margin-left: 20px;} left right right 效果展示: absolute absolute布局的缺点是由于父元素需要设置为relative，且子元素设置为absolute，所以父元素的高度并不是由子元素撑开的，需要单独设置。 .f7 .parent{ position: relative; width: 100%; height:40px; } .f7 .left{ position: absolute; left:0; width:100px; } .f7 .right{ position: absolute; left:120px; right:0; } left right right 效果展示: flex flex弹性盒模型是非常强大的布局方式。但由于其性能消耗较大，适合于局部小范围的布局 [注意]IE9-浏览器不支持 flex布局教程 .f8 .parent{ display: flex; } .f8 .left{ width:100px; margin-right: 20px; } .f8 .right{ flex:1 1 auto; } left right right 效果展示: grid 使用栅格布局grid实现[注意]IE10-浏览器不支持 grid布局详细教程 .f9 .parent{ display: grid; /* 子项目分别按照 100px固定宽度 以及1fr的栅格宽度分配 */ grid-template-columns: 100px 1fr; /* 子项目间隙 */ grid-gap:20px } left right right 效果展示: Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:01:08 "},"css编程.html":{"url":"css编程.html","title":"css编程","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:01:29 "},"sass和scss.html":{"url":"sass和scss.html","title":"sass 和 scss","keywords":"","body":"什么是sass Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 CSS 语法。 Sass 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 Compass 样式库一同使用时 【特点】 完全兼容 CSS3 在 CSS 语言的基础上增加变量(variables)、嵌套 (nesting)、混合 (mixins) 等功能 通过函数进行颜色值与属性值的运算 提供控制指令等高级功能 自定义输出格式 scss && sass Sass 有两种语法。 第一种被称为 SCSS (Sassy CSS)，是一个 CSS3 语法的扩充版本。 也就是说，所有符合 CSS3 语法的样式表也都是具有相同语法意义的 SCSS 文件。 另外，SCSS 理解大多数 CSS hacks 以及浏览器专属语法，例如IE古老的 filter 语法。 这种语种语法的样式表文件需要以 .scss 扩展名。 第二种比较老的语法成为缩排语法（或者就称为 \"Sass\"）， 提供了一种更简洁的 CSS 书写方式。 任一语法都可以导入另一种语法撰写的文件中。 只要使用 sass-convert 命令行工具 [注意]本文使用scss语法 缓存 默认情况下，Sass 会自动缓存编译后的模板（template）与 partials，这样做能够显著提升重新编译的速度，在处理 Sass 模板被切割为多个文件并通过 @import 导入，形成一个大文件时效果尤其显著。 基础规则 【注释】 /* This comment is * several lines long. * since it uses the CSS comment syntax, * it will appear in the CSS output. */ body { color: black; } // These comments are only one line long each. // They won't appear in the CSS output, // since they use the single-line comment syntax. a { color: green; } 使用插值语句的注释 $version: \"1.2.3\"; /* This CSS is generated by My Snazzy Framework version #{$version}. */ 编译后： /* This CSS is generated by My Snazzy Framework version 1.2.3. */ 【嵌套规则】 Sass 允许将一个 CSS 样式嵌套进另一个样式中，内层样式仅适用于外层样式的选择器范围内 #main{ color: #00ff00; width: 97%; .redbox { background-color: #ff0000; color: #000000; } } 等同于 #main .redbox{} 【引用父选择器 &】 a { font-weight: bold; text-decoration: none; &:hover { text-decoration: underline; } body.firefox & { font-weight: normal; } } [注意] & 等于 a 即父元素 【属性嵌套】 CSS中有一些属性遵循相同的“命名空间”；比如，font-family, font-size, 和 font-weight 都在 font 命名空间中。在CSS中，如果你想在同一个命名空间中设置一串属性，你必须每次都输出来。Sass为此提供了一个快捷方式：只需要输入一次命名空间，然后在其内部嵌套子属性。 .funky { font: { family: fantasy; size: 30em; weight: bold; } } 编译为： .funky { font-family: fantasy; font-size: 30em; font-weight: bold; } 带属性的命名空间 .funky { font: 20px/24px fantasy { weight: bold; } } 编译后 .funky { font: 20px/24px fantasy; font-weight: bold; } SassScript 除了普通的CSS属性的语法，Sass 支持一些扩展，名为SassScript。SassScript允许属性使用变量，算术和额外功能。SassScript可以在任何属性值被使用。 SassScript也可以用来生成选择器和属性名称，当编写mixins时非常有用。这是通过 interpolation（插值）完成。 【变量】 使用SassScript最直截了当的方法是使用变量。变量以美元符号开始，赋值像设置CSS属性那样： $width: 5em; #main { width: $width; } 编译为： #main { width: 5em; } 数据类型 SassScript 支持 7 种主要的数据类型： 数字 (例如： 1.2, 13, 10px) 文本字符串，带引号字符串和不带引号字符串(例如：\"foo\", 'bar', baz) 颜色 (例如：blue, #04a3f9, rgba(255, 0, 0, 0.5)) 布尔值 (例如：true, false) 空值 (例如：null) 值列表 (list)，用空格或逗号分隔 (例如： 1.5em 1em 0 2em, Helvetica, Arial, sans-serif) maps，从一个值映射到另一个 (例如 (key1: value1, key2: value2)) 【字符串】 CSS指定两种字符串类型：带引号的字符串（\"Lucida Grande\"），还有不带引号的字符串（sans-serif）SassScript 识别这两种类型，并且一般来说，在编译输出的CSS文件中不会改变Sass文档中使用的字符串类型。 [例外]当使用 #{} 时，带引号的字符串将被编译为不带引号的字符串 @mixin firefox-message($selector) { body.firefox #{$selector}:before { content: \"Hi, Firefox users!\"; } } @include firefox-message(\".header\"); 编译后： body.firefox .header:before { content: \"Hi, Firefox users!\"; } \".header\" 最终被编译为 .header 【列表】列表(lists) 是指 Sass 如何表示在CSS声明的，类似margin: 10px 15px 0 0 或 font-face: Helvetica, Arial, sans-serif这样的值，列表只是一串其他值，无论是用空格还是用逗号隔开。事实上，独立的值也被视为列表：只包含一个值的列表。 列表本身没有太多的功能，但是 SassScript list functions 使它们非常有用。nth 函数可以直接访问列表中的某一项；join 函数可以将多个列表拼接在一起；append 函数可以将某项添加到列表中；@each 指令可以将添加样式到列表中的每一项。 【Maps】Maps代表一个键和值对集合，其中键用于查找值。他们可以很容易地将值收集到命名组中，并且可以动态地访问这些组。在CSS中你找不到和他们类似的值，虽然他们的语法类似于媒体查询表达式： $map: (key1: value1, key2: value2, key3: value3); 和列表（Lists）不同，Maps必须始终使用括号括起来，并且必须用逗号分隔。Maps中的键和值可以是任意的SassScript对象。一个Maps可能只有一个值与给定的键关联（尽管该值可以是一个列表）。一个给定的值可能与许多键关联。 Maps的主要操作使用的是 SassScript 函数。map-get函数用于查找map中的值，map-merge函数用于添加值到map中的值， @each 指令可以用来为 map 中的每个键值对添加样式。map中键值对的顺序和map创建时始终相同。 [注意]需要注意的是 map 的建（keys）可以是任何 Sass 数据类型（甚至是另一个map），并且声明map的语法允许是任意的SassScript表达式，这个表达式将被评估为一个值以确定建（keys）。 运算 所有数据类型的支持相等运算(== 和 !=)。此外，每种类型都有其自己特殊的运算方式。 【数字运算】SassScript 支持对数字标准的算术运算（加法+，减法 - ，乘法*，除法/和取模%）。Sass 数学函数在算术运算期间会保留单位。这意味着，就像在现实生活中，你不能用不相同的单位数字进行算术运算（比如数字后面添加了px和em单位） 【除法和 /】CSS允许 / 出现在属性值之间作为分隔数字的方式，如下代码 p.ex2{font:italic bold 12px/20px arial,sans-serif;}) 12px/20px 是 font-size/line-height的简写形式 SassScript在以下几种情况下会进行除法运算 使用了变量 使用了函数 使用了括号p { font: 10px/8px; // 原生的CSS，不作为除法 $width: 1000px; width: $width/2; // 使用了变量, 作为除法 width: round(1.5)/2; // 使用了函数, 作为除法 height: (500px/2); // 使用了括号, 作为除法 margin-left: 5px + 8px/2px; // 使用了 +, 作为除法 font: (italic bold 10px/8px); // 在一个列表（list）中，括号可以被忽略。 } 如果你想纯CSS 的/ 和变量一起使用（即/不作为除法使用），你可以使用#{}插入他们。例如： p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } 编译后： p { font: 12px/30px; } 【减法，负数，和 -】在CSS和在Sass中 - 有许多不同的意义。它可以是一个减法运算符（比如在5px - 3px中）也可以表示一个负数（比如在-3px中）还可以是一个一元负运算符（比如在-$var中）或是标识符的一部分（比如在font-weight中） 那么如何使用 - 呢？ 减法的时候，你总是在 - 两侧保留空格。 当表示一个负数或一元负运算时候，在-前面包含一个空格，后面不加空格。 如果在一个空格隔开的list（列表）中，你可以将一元负运算使用括号括起来，比如在10px (-$var)中。 【颜色运算】所有算术运算都支持的颜色值，颜色值的运算是分段进行计算的，也就是，依次计算红（red），绿（green），以及蓝（blue）的成分值。例如： p { color: #010203 + #040506; // 计算 01 + 04 = 05, 02 + 05 = 07, 和 03 + 06 = 09，并且编译为： } 编译后 p { color: #050709; } 【opacify和transparentize函数】调整颜色的alpha通道可以使用 $translucent-red: rgba(255, 0, 0, 0.5); p { color: opacify($translucent-red, 0.3); background-color: transparentize($translucent-red, 0.25); } 编译后： p { color: rgba(255, 0, 0, 0.8); // 0.5 + 0.3 background-color: rgba(255, 0, 0, 0.25);// 直接使用0.25替代了0.5 } 【字符串运算】 运算可用于连接字符串 p { cursor: e + -resize; } 编译后： p { cursor: e-resize; } 带引号和不带引号字符串加运算 p:before { content: \"Foo \" + Bar; font-family: sans- + \"serif\"; } 编译后 p:before { content: \"Foo Bar\"; font-family: sans-serif; } 【圆括号】圆括号可以用来影响运算的顺序(注：优先级)： p { width: 1em + (2em * 3); } 编译后： p { width: 7em; } 插值 $name: foo; $attr: border; p.#{$name} { #{$attr}-color: blue; } 编译后： p.foo { border-color: blue; } 使用插值来避免运算 p { $font-size: 12px; $line-height: 30px; font: #{$font-size}/#{$line-height}; } 编译后： p { font: 12px/30px; } SassScript中的 & 就像当它在选择器中使用一样，SassScript中的&指向当前父选择器。 .foo{ &:hover{ color:red; } } 编译后： .foo:hover { color: red; } 变量默认 如果分配给变量的值后面添加了!default标志 ，这意味着该变量如果已经赋值，那么它不会被重新赋值，但是，如果它尚未赋值，那么它会被赋予新的给定值。 $content: \"First content\"; $content: \"Second content?\" !default; $new_content: \"First time reference\" !default; #main { content: $content; new-content: $new_content; } 编译后： #main { content: \"First content\"; // 使用了之前定义的 new-content: \"First time reference\"; } 规则 Sass 支持所有CSS3的 @ 规则，以及一些已知的其他特定的Sass \"指令\"。 【@import】 Sass 扩展了 CSS @import规则，允许其导入 SCSS 或 Sass 文件。被导入的全部SCSS 或 Sass文件将一起合并到同一个 CSS 文件中。此外，被导入文件中所定义的任何变量或混入（mixins）都可以在主文件 可以正确导入scss或sass文件 @import \"foo.scss\"; @import \"foo\"; 不能正确导入的形式 @import \"foo.css\"; @import \"foo\" screen; @import \"http://foo.com/bar\"; @import url(foo); @import支持导入多个文件语句 @import \"rounded-corners\", \"text-shadow\"; @import用在嵌套 example.scss 包含 .example { color: red; } 如此引入： #main { @import \"example\"; } 等同于 #main { .example { color: red; } } 编译后 #main .example { color: red; } [注意1]该指令只允许出现在文档顶层（注：最外层，不在嵌套规则内）[注意2]不允许在 mixin)或控制指令 (control directives) 中嵌套 @import 【@media】Sass 中 @media 指令的行为和纯 CSS 中一样，只是增加了一点额外的功能：它们可以嵌套在CSS规则。如果一个@media 指令出现在CSS规则中，它将被冒泡到样式表的顶层，并且包含规则内所有的选择器。这使得很容易地添加特定media样式，而不需要重复使用选择器，或打乱样式表书写流。例如： .sidebar { width: 300px; @media screen and (orientation: landscape) { width: 500px; } } 编译后： .sidebar { width: 300px; } @media screen and (orientation: landscape) { .sidebar { width: 500px; } } @extend 继承另一个样式 .error { border: 1px #f00; background-color: #fdd; } .seriousError { @extend .error; border-width: 3px; } 编译后： .error, .seriousError { border: 1px #f00; background-color: #fdd; } .seriousError { border-width: 3px; } 这意味着.error说定义的所有样式也适用于.seriousError，除了.seriousError的特定样式。相当于，每个带有.seriousError类的元素也带有.error类。 类（class）选择，并不是唯一可以扩展。她可以扩展任何定义给单个元素的选择器，如.special.cool, a:hover, 或 a.user[href^=\"http://\"]。 例如： .hoverlink { @extend a:hover; } a:hover { text-decoration: underline; } 编译后： a:hover, .hoverlink { text-decoration: underline; } 警告指令 【@debug】 @debug指令打印SassScript表达式的值到标准的错误输出流。这对于调试具有复杂SassScript 表达式的Sass文件非常有用的。 @debug 10em + 12em; 输出：Line 1 DEBUG: 22em 【@warn】 @warn指令打印SassScript表达式的值到标准的错误输出流。这对于警告用户弃用库 或 修复 mixin 轻微的错误是非常有用的。 使用示例 @mixin adjust-location($x, $y) { @if unitless($x) { @warn \"Assuming #{$x} to be in pixels\"; $x: 1px * $x; } @if unitless($y) { @warn \"Assuming #{$y} to be in pixels\"; $y: 1px * $y; } position: relative; left: $x; top: $y; } 【@error】 @error指令抛出一个SassScript表达式的值作为一个致命的错误，其中包括一个不错的堆栈跟踪。这对于验证混入（mixin）和函数的参数很有用。例如： @mixin adjust-location($x, $y) { @if unitless($x) { @error \"$x may not be unitless, was #{$x}.\"; } @if unitless($y) { @error \"$y may not be unitless, was #{$y}.\"; } position: relative; left: $x; top: $y; } 控制指令和表达式 SassScript支持一些基本控制指令和表达式，比如仅在在某些条件下包含样式，或者包括相同的样式几次变化。 [注意]控制指令是一项高级功能，日常编写过程中并不常用到，主要在 mixins（混合）指令中使用，尤其是像Compass这样的库。 【@if】@if 指令需要一个SassScript表达和嵌套在它下面要使用的样式，如果表达式返回值不为 false 或者 null ，那么后面花括号中的内容就会返回： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 @if 语句后面可以跟多个@else if语句和一个 @else 语句。 如果@if语句失败，Sass 将逐条尝试@else if 语句，直到有一个成功，或如果全部失败，那么会执行@else语句。 例如： $type: monster; p { @if $type == ocean { color: blue; } @else if $type == matador { color: red; } @else if $type == monster { color: green; } @else { color: black; } } 编译后： p { color: green; } 【@for】@for指令重复输出一组样式。对于每次重复，计数器变量用于调整输出结果。该指令有两种形式：@for $var from through @for $var from to @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } 编译后： .item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } 【@each】@each指令通常格式是@each $var in 。$var可以是任何变量名，像$length 或者 $name，和是一个返回列表（list）或 map 的 SassScript 表达式。 @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); } } 编译后： .puma-icon { background-image: url('/images/puma.png'); } .sea-slug-icon { background-image: url('/images/sea-slug.png'); } .egret-icon { background-image: url('/images/egret.png'); } .salamander-icon { background-image: url('/images/salamander.png'); } 【遍历Map】 @each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; } } 编译后： h1 { font-size: 2em; } h2 { font-size: 1.5em; } h3 { font-size: 1.2em; } Mixin 混入(mixin)允许您定义可以在整个样式表中重复使用的样式，而避免了使用无语意的类（class），比如 .float-left。混入(mixin)还可以包含所有的CSS规则，以及任何其他在Sass文档中被允许使用的东西。他们甚至可以带arguments，引入变量，只需少量的混入(mixin)代码就能输出多样化的样式。 【定义一个Mixin】 @mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000; } @mixin clearfix { display: inline-block; &:after { content: \".\"; display: block; height: 0; clear: both; visibility: hidden; } * html & { height: 1px } } 【引用混合指令@include】 .page-title { @include large-text; padding: 4px; margin-top: 10px; } 编译后： .page-title { font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px; } 【mixin参数】 @mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue, 100px); } 编译后： p { border-color: blue; border-width: 1in; border-style: dashed; } 【参数设置默认值】 @mixin sexy-border($color, $width: 1in) { border: { color: $color; width: $width; style: dashed; } } p { @include sexy-border(blue); } h1 { @include sexy-border(blue, 2in); } 编译后： p { border-color: blue; border-width: 1in; border-style: dashed; } h1 { border-color: blue; border-width: 2in; border-style: dashed; } 【可变参数】有时，不能确定一个混入（mixin）或者一个函数（function）使用多少个参数。例如，用于创建盒子阴影（box-shadow）的一个混入（mixin）可以采取任何数量的box-shadow作为参数。 @mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows; } .shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999); } 编译后： .shadows { -moz-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; -webkit-box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; box-shadow: 0px 4px 5px #666, 2px 6px 10px #999; } 【参数结合list map 使用】 @mixin colors($text, $background, $border) { color: $text; background-color: $background; border-color: $border; } $values: #ff0000, #00ff00, #0000ff; .primary { @include colors($values...); } $value-map: (text: #00ff00, background: #0000ff, border: #ff0000); .secondary { @include colors($value-map...); } 编译后： .primary { color: #ff0000; background-color: #00ff00; border-color: #0000ff; } .secondary { color: #00ff00; background-color: #0000ff; border-color: #ff0000; } 【mixin传递内容块】 @mixin apply-to-ie6-only { * html { @content; } } @include apply-to-ie6-only { #logo { background-image: url(/logo.gif); } } 编译后： * html #logo { background-image: url(/logo.gif); } 【变量的作用域】 传递给混入（mixin）的内容块在其被定义的作用域中进行运算，而不是混入（mixin）的作用域。 $color: white; @mixin colors($color: blue) { background-color: $color; @content; border-color: $color; } .colors { @include colors { color: $color; } } 编译后： .colors { background-color: blue; // 引用的mixin的变量值 color: white; // 这里引用的是全局的变量 border-color: blue;// 引用的mixin的变量值 } 函数指令 Sass 支持自定义函数，并能在任何值或脚本上下文中使用 $grid-width: 40px; $gutter-width: 10px; @function grid-width($n) { @return $n * $grid-width + ($n - 1) * $gutter-width; } #sidebar { width: grid-width(5); } 编译后： #sidebar { width: 240px; } 调用方式 #sidebar { width: grid-width($n: 5); } 输出格式 虽然Sass 默认的 CSS 输出格式非常好，并且能反映文档的结构，但是由于每个人的喜好和需求各不相同，因此Sass 支持其他几种格式。Sass 允许您通过设置:style 选项 或使用 --style 命令行标志，在四种不同的输出格式之间进行选择。 【:nested】 nested（嵌套）格式是 Sass 默认的输出格式，因为它的格式反映CSS样式与HTML文档结构。每个属性都独占用一行，但缩排不是固定的。每个规则是基于它的何嵌套深度缩进。 #main { color: #fff; background-color: #000; } #main p { width: 10em; } 【:expanded】 expanded（扩展）格式更像是手写的CSS样式，每个属性和规则都独占用一行。在规则之内的属性缩进的，但规则没有任何特殊的缩进。例如： #main { color: #fff; background-color: #000; } #main p { width: 10em; } 【:compact】 compact（紧凑）格式比起nested（嵌套）或expanded（扩展）格式占据更小的空间。这种格式重点聚焦在选择器上，不是它们的属性。 #main { color: #fff; background-color: #000; } #main p { width: 10em; } 【:compressed】 compressed（压缩）格式占用尽可能小的空间，在该文件的末尾会有一个换行，并且除了必要的分隔选择器之外，基本没有多余空格，它还包括其他一些小的压缩，比如选择颜色最小的表示方式。 #main{color:#fff;background-color:#000}#main p{width:10em} 小结 本文内容全部来自sass文档，通过查阅一遍文档，基本上能掌握sass的一些常用用法。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:06:59 "},"动画.html":{"url":"动画.html","title":"动画","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:07:10 "},"规范.html":{"url":"规范.html","title":"规范","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:07:27 "},"重难.html":{"url":"重难.html","title":"重难","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:07:40 "},"CSSBFC（格式化上下文）深入理解.html":{"url":"CSSBFC（格式化上下文）深入理解.html","title":"CSS BFC（格式化上下文）深入理解","keywords":"","body":"什么是BFC 在解释BFC之前，先说一下文档流。我们常说的文档流其实分为定位流、浮动流和普通流三种。而普通流其实就是指BFC中的FC。FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用。常见的FC有BFC、IFC，还有GFC和FFC。BFC是block formatting context，也就是块级格式化上下文，是用于布局块级盒子的一块渲染区域 触发条件 满足下列条件之一就可触发BFC 1、根元素，即HTML元素2、float的值不为none3、overflow的值不为visible4、display的值为inline-block、table-cell、table-caption5、position的值为absolute或fixed 作用 BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。它与“普通的块框”类似，但不同之处在于: 1、可以阻止元素被浮动元素覆盖2、可以包含浮动元素3、属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠 【1】可以阻止元素被浮动元素覆盖 效果展示：通过改变内容为BFC，背景为浅绿色的盒子的属性，使其成为BFC，以此阻止被深绿色的浮动盒子覆盖 【2】可以包含浮动元素 效果展示：操作天蓝色区域的属性，使其成为BFC。就可以包含住浮动元素 【3】属于同一个BFC的两个相邻块级子元素的上下margin会发生重叠，(设置writing-mode:tb-rl时，水平margin会发生重叠)。所以当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠 效果展示：深红色背景的块级盒子二的外面包一个div，通过改变此div的属性使红色盒子与绿色盒子分属于两个不同的BFC，以此来阻止margin重叠 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:09:16 "},"css中font-size为0的妙用（消除内联元素间的间隔）.html":{"url":"css中font-size为0的妙用（消除内联元素间的间隔）.html","title":"css中font-size为0的妙用（消除内联元素间的间隔）","keywords":"","body":"前言 看不片我们不难发现为什么会多出一个间隙出来呢。我们该如何消除呢？ inline && inline-block元素间隙 元素间留白间距出现的原因就是标签段之间的空格 因此去除的方法之一就是把标签的间隙去除掉 果然就没有间隙了，但是这样代码的可读性太差了。解决方法还有一些，例如：margin负值 , letter-spacing, word-spacing,浮动等但是最佳的解决方案还是font-size:0 font-size = 0 小结 之所以会想着把这个问题记录下来也是，当碰到一些精细的设计图时，距离的调整很重要。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:14:37 "},"css-modules.html":{"url":"css-modules.html","title":"css-modules","keywords":"","body":"前言 CSS Modules 它不是将 CSS 改造成编程语言，而是功能很单纯，只加入了局部作用域和模块依赖，这恰恰是网页组件最急需的功能。 因此，CSS Modules 很容易学，因为它的规则少，同时又非常有用，可以保证某个组件的样式，不会影响到其他组件。 本文所有代码示例： ruanyf 局部作用域 CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。 产生局部作用域的唯一方法，就是使用一个独一无二的class的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。 下面是一个React组件App.js。 import React from 'react'; import style from './App.css'; export default () => { return ( Hello World ); }; 上面代码中，我们将样式文件App.css输入到style对象，然后引用style.title代表一个class。 .title { color: red; } 构建工具会将类名style.title编译成一个哈希字符串。 Hello World ._3zyde4l1yATCOkgn-DBWEL { color: red; } 这样一来，这个类名就变成独一无二了，只对App组件有效。 CSS Modules 提供各种插件，支持不同的构建工具。本文使用的是 Webpack 的css-loader插件，因为它对 CSS Modules 的支持最好，而且很容易使用 webpack.config.js配置清单 module.exports = { entry: __dirname + '/index.js', output: { publicPath: '/', filename: './bundle.js' }, module: { loaders: [ { test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'stage-0', 'react'] } }, { test: /\\.css$/, loader: \"style-loader!css-loader?modules\" }, ] } }; 上面代码中，关键的一行是style-loader!css-loader?modules，它在css-loader后面加了一个查询参数modules，表示打开 CSS Modules 功能。 全局作用域 CSS Modules 允许使用:global(.className)的语法，声明一个全局规则。凡是这样声明的class，都不会被编译成哈希字符串。 App.css加入一个全局class。 .title { color: red; } :global(.title) { color: green; } App.js使用普通的class的写法，就会引用全局class。 import React from 'react'; import styles from './App.css'; export default () => { return ( Hello World ); }; CSS Modules 还提供一种显式的局部作用域语法:local(.className)，等同于.className，所以上面的App.css也可以写成下面这样。 :local(.title) { color: red; } :global(.title) { color: green; } 定制哈希类名 css-loader默认的哈希算法是[hash:base64]，这会将.title编译成._3zyde4l1yATCOkgn-DBWEL这样的字符串。 webpack.config.js里面可以定制哈希字符串的格式。 module: { loaders: [ // ... { test: /\\.css$/, loader: \"style-loader!css-loader?modules&localIdentName=[path][name]---[local]---[hash:base64:5]\" }, ] } 你会发现.title被编译成了demo03-components-App---title---GpMto。 Class 的组合 在 CSS Modules 中，一个选择器可以继承另一个选择器的规则，这称为\"组合\"（\"composition\"）。 在App.css中，让.title继承.className 。 .className { background-color: blue; } .title { composes: className; color: red; } App.js不用修改。 import React from 'react'; import style from './App.css'; export default () => { return ( Hello World ); }; App.css编译成下面的代码。 ._2DHwuiHWMnKTOYG45T0x34 { color: red; } ._10B-buq6_BEOTOl9urIjf8 { background-color: blue; } 相应地， h1的class也会编译成 输入变量 CSS Modules 支持使用变量，不过需要安装 PostCSS 和 postcss-modules-values。 npm install --save postcss-loader postcss-modules-values 把postcss-loader加入webpack.config.js var values = require('postcss-modules-values'); module.exports = { entry: __dirname + '/index.js', output: { publicPath: '/', filename: './bundle.js' }, module: { loaders: [ { test: /\\.jsx?$/, exclude: /node_modules/, loader: 'babel', query: { presets: ['es2015', 'stage-0', 'react'] } }, { test: /\\.css$/, loader: \"style-loader!css-loader?modules!postcss-loader\" }, ] }, postcss: [ values ] }; 接着，在colors.css里面定义变量。 @value blue: #0c77f8; @value red: #ff0000; @value green: #aaf200; App.css可以引用这些变量。 @value colors: \"./colors.css\"; @value blue, red, green from colors; .title { color: red; background-color: blue; } 如何配合less或sass使用 详细介绍了配合css-modules配合sass的使用 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:16:21 "},"css中的数学表达式calc.html":{"url":"css中的数学表达式calc.html","title":"css中的数学表达式calc()","keywords":"","body":"前言 数学表达式calc()是CSS中的函数，主要用于数学运算。使用calc()为页面元素布局提供了便利和新的思路。 概念 数学表达式calc()是calculate计算的缩写，它允许使用+、-、*、/这四种运算符，可以混合使用%、px、em、rem等单位进行计算 [兼容性] IE8-、safari5.1-、ios5.1-、android4.3-不支持，android4.4-4.4.4只支持加法和减法。IE9不支持用于backround-position [注意]+和-运算符两边一定要有空白符(只有留了空白符后css才会判断出是进行运算) .test1{ border: calc( 1px + 1px ) solid black; /* calc里面的运算遵循*、/优先于+、-的顺序 */ width: calc(100%/3 - 2*1em - 2*1px); background-color: pink; font-style: toggle(italic, normal); } .test2{ /* 由于运算符+的左右两侧没有空白符，所以失效 */ border: calc(1px+1px) solid black; /* 对于，不能小于0的属性值，当运算结果小于0时，按0处理 */ width: calc(10px - 20px); padding-left: 10px; background-color: lightblue; } 测试文字一 测试文字二 .test1{ border: calc( 1px + 1px ) solid black; /* calc里面的运算遵循*、/优先于+、-的顺序 */ width: calc(100%/3 - 2*1em - 2*1px); background-color: pink; font-style: toggle(italic, normal); } .test2{ /* 由于运算符+的左右两侧没有空白符，所以失效 */ border: calc(1px+1px) solid black; /* 对于，不能小于0的属性值，当运算结果小于0时，按0处理 */ width: calc(10px - 20px); padding-left: 10px; background-color: lightblue; } #vh_box{width:100%; height: 100%;} #vh_t0{width:100%;height:200px; background:blue; } #vh_t1{width:100%; height:calc( 100vh - 200px ); background:red;} 测试文字一 测试文字二 [重点] 数学表达式calc()常用于布局中的不同单位的数字运算 #vh_box{width:100%; height: 100%;} .vh_t0{width:100%;height:200px; background:blue; } .right{width:100%; height:calc( 100vh - 200px ); background:red;} // 浏览器会计算出 100vh 减去 200px 的值。这样对于不同单位的运算是非常便利的。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:28:50 "},"CSS难点为什么height设置100会失效，分栏目等高布局高度自适用布局的实现方案.html":{"url":"CSS难点为什么height设置100会失效，分栏目等高布局高度自适用布局的实现方案.html","title":"CSS难点 为什么height设置100%会失效，分栏目等高布局(高度自适用布局)的实现方案","keywords":"","body":"前言 相信在平时写CSS的时候大家都或多或少遇见过设置了height为百分比的时候发现不起作用。今天我们就来一探究竟 原因：父元素未设置具体高度，子元素设置height:100%是无效的。 现象以及方案 [1] 设置高度为100%时，无法实现全屏 .case-box{ height: 100%; background:red; } 这样写，你会发现一点效果都没有。 【解决方案】增加如下代码： html,body{ height: 100%; } [2] 一个父元素中包含2个子元素，其中一个子元素非常高，撑开了父元素，另外1个子元素设置高度为100%失效。 .case-box{ overflow: hidden; } .height-max{ width: 200px; height:400px; background: #167be0; float:left; } .height-percent{ margin-right:20px; background: hotpink; width: 200px; height: 100%; padding:20px; float:left; } height-max 设置了高度是400px撑开了父级使得父级case-box高度也是400px，height-percent设置了高度为100%，本来我们期望会跟父级的高速一样都是400px，可是它还是没有高度(背景色是padding撑起来的)。 平时的布局经常可以碰到这样的情况，需要根据一个块的高度进行高度自适应布局，但是好像单纯的设置高度为100%是无法实现的。 【方案一】父元素case-box设置一个定高(视乎这样压根就满足不了我们的需求) 【方案二】使用position .case-box{ overflow: hidden; position: relative; } .height-max{ width: 200px; height:400px; background: #167be0; float:left; margin-left: 220px; } .height-percent{ margin-right:20px; background: hotpink; width: 200px; height: 100%; padding:20px; float:left; position: absolute; } [缺点]这样使用会破坏原本的布局顺序 【方案三】使用flex .case-box{ position: relative; display: flex; } .height-max{ width: 200px; height:400px; background: #167be0; } .height-percent{ margin-right:20px; background: hotpink; width: 200px; padding:20px; } 不可否认flex布局还是非常方便的 [缺点]兼容性稍差 【方案四】display: table .case-box{ position: relative; display: table; } .height-max{ width: 200px; height:400px; background: #167be0; } .height-percent{ background: hotpink; width: 200px; display: table-cell; } [缺点]margin失效 【最佳方案】padding-bottom:3000px;margin-bottom:-3000px; .case-box{ overflow: hidden; zoom:1; } .height-max{ width: 200px; height:400px; background: #167be0; margin-left: 220px; } // 需要自使用的块设置好padding和margin .height-percent{ background: hotpink; width: 200px; float:left; padding-bottom: 3000px; margin-bottom: -3000px; } 3000像素是个可变值，如果您的分栏高度不可能高度超过2000像素，您就可以设为2000像素，如果会超过3000像素，那么您要修改值为4000像素或是更高。父标签的overflow:hidden属性是必须的，否则会显示溢出的内容 小结 通过本文学习了:为什么height设置百分比无效(因为父元素没有设置固定高度的原因)以及如何实现高度自适用的布局方法 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:33:15 "},"Babel.html":{"url":"Babel.html","title":"Babel","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 15:44:05 "},"Babel入门学习.html":{"url":"Babel入门学习.html","title":"Babel 入门学习","keywords":"","body":"Babel 是什么？ 大家都知道js作为宿主语言，很依赖执行的环境（浏览器、node等），不同环境对js语法的支持不尽相同，特别是ES6之后，ECMAScrip对版本的更新已经到了一年一次的节奏，虽然每年更新的幅度不大，但是每年的提案可不少。babel的出现就是为了解决这个问题，把那些使用新标准编写的代码转译为当前环境可运行的代码，简单点说就是把ES6代码转译（转码+编译）到ES5。 ES6 正文之前先谈谈ES6，ES即ECMAScript，6表示第六个版本(也被称为是ES2015，因为是2015年发布的)，它是javascript的实现标准。 被纳入到ES标准的语法必须要经过如下五个阶段: Stage 0: strawman Stage 1: proposal Stage 2: draft - 必须包含2个实验性的具体实现，其中一个可以是用转译器实现的，例如Babel。 Stage 3: candidate - 至少要有2个符合规范的具体实现。 Stage 4: finished 可以看到提案在进入stage3阶段时就已经在一些环境被实现，在stage2阶段有babel的实现。所以被纳入到ES标准的语法其实在大部分环境都已经是有了实现的，那么为什么还要用babel来进行转译，因为不能确保每个运行代码的环境都是最新版本并已经实现了规范。 babel6 移除babel全家桶安装，拆分为单独模块，例如：babel-core、babel-cli、babel-node、babel-polyfill等； 可以在babel的github仓库看到babel现在有哪些模块。 新增 .babelrc 配置文件，基本上所有的babel转译都会来读取这个配置； 新增 plugin 配置，所有的东西都插件化，什么代码要转译都能在插件中自由配置； 新增 preset 配置，babel5会默认转译ES6和jsx语法，babel6转译的语法都要在preset中配置，preset简单说就是一系列plugin包的使用。 具体模块介绍 babel6将babel全家桶拆分成了许多不同的模块，只有知道这些模块怎么用才能更好的理解babel。 安装 #通过npm安装 npm install babel-core babel-cli babel-node babel-core babel-core是作为babel的核心存在，babel的核心api都在这个模块里面，比如：transform。 介绍几个babel-core中的api babel.transform：用于字符串转码得到AST /* * @param {string} code 要转译的代码字符串 * @param {object} options 可选，配置项 * @return {object} */ babel.transform(code: string, options?: Object) //返回一个对象(主要包括三个部分)： { generated code, //生成码 sources map, //源映射 AST //即abstract syntax tree，抽象语法树 } 一些使用babel插件的打包或构建工具都有使用到这个方法，下面是一些引入babel插件中的源码： //gulp-babel const babel = require('babel-core'); /* some codes... */ module.exports = function (opts) { opts = opts || {}; return through.obj(function (file, enc, cb) { try { const fileOpts = Object.assign({}, opts, { filename: file.path, filenameRelative: file.relative, sourceMap: Boolean(file.sourceMap), sourceFileName: file.relative, sourceMapTarget: file.relative }); const res = babel.transform(file.contents.toString(), fileOpts); if (res !== null) { //some codes } } catch (err) { //some codes } } } 上面是一些打包工具引入babel插件时的一些源码，可以看到基本都是先通过调用transform方法进行代码转码。 babel-cli babel-cli是一个通过命令行对js文件进行换码的工具。 使用方法： babel script.js babel script.js --out-file build.js // 指定输出文件 babel src --out-dir dist // 指定输入文件夹和输出文件夹 babel-polyfill polyfill这个单词翻译成中文是垫片的意思，详细点解释就是桌子的桌脚有一边矮一点，拿一个东西把桌子垫平。polyfill在代码中的作用主要是用已经存在的语法和api实现一些浏览器还没有实现的api，对浏览器的一些缺陷做一些修补。例如Array新增了includes方法，我想使用，但是低版本的浏览器上没有，就得做兼容处理： if (!Array.prototype.includes) { Object.defineProperty(Array.prototype, 'includes', { value: function(searchElement, fromIndex) { if (this == null) { throw new TypeError('\"this\" is null or not defined'); } var o = Object(this); var len = o.length >>> 0; if (len === 0) { return false; } var n = fromIndex | 0; var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0); while (k 理解polyfill的意思之后，再来说说babel为什么存在polyfill。因为babel的转译只是语法层次的转译，例如箭头函数、解构赋值、class，对一些新增api以及全局函数（例如：Promise）无法进行转译，这个时候就需要在代码中引入babel-polyfill .babelrc 配置文件 前面已经介绍了babel常用的一些模块，接下来看看babel的配置文件 .babelrc。 后面的后缀rc来自linux中，使用过linux就知道linux中很多rc结尾的文件，比如.bashrc，rc是run command的缩写，翻译成中文就是运行时的命令，表示程序执行时就会来调用这个文件。 babel所有的操作基本都会来读取这个配置文件，除了一些在回调函数中设置options参数的，如果没有这个配置文件，会从package.json文件的babel属性中读取配置。 配置文件内容： { \"presets\": [ [\"env\", { \"modules\": false }], \"stage-0\" ], \"plugins\": [ \"transform-runtime\", // transform-runtime只会对es6的语法进行转换，而不会对新api进行转换，如果需要转换新api，就要引入babel-polyfill [\"transform-react-jsx\", { // 解析jsx \"pragma\": \"vd\" } ] ] } plugins babel中的插件，通过配置不同的插件才能告诉babel，我们的代码中有哪些是需要转译的。 { \"plugins\": [ \"transform-es2015-arrow-functions\", //转译箭头函数 \"transform-es2015-classes\", //转译class语法 \"transform-es2015-spread\", //转译数组解构 \"transform-es2015-for-of\" //转译for-of ] } //如果要为某个插件添加配置项，按如下写法： { \"plugins\":[ //改为数组，第二个元素为配置项 [\"transform-es2015-arrow-functions\", { \"spec\": true }] ] } presets 显然这样一个一个配置插件会非常的麻烦，为了方便，babel为我们提供了一个配置项叫做presets（预设）。 预设就是一系列插件的集合，就好像修图一样，把上次修图的一些参数保存为一个预设，下次就能直接使用。 如果要转译ES6语法，只要按如下方式配置即可： //先安装ES6相关preset： cnpm install -D babel-preset-es2015 { \"presets\": [\"es2015\"] } //如果要转译的语法不止ES6，还有各个提案阶段的语法也想体验，可以按如下方式。 //安装需要的preset： cnpm install -D babel-preset-stage-0 babel-preset-stage-1 babel-preset-stage-2 babel-preset-stage-3 { \"presets\": [ \"es2015\", \"stage-0\", \"stage-1\", \"stage-2\", \"stage-3\", ] } //同样babel也能直接转译jsx语法，通过引入react的预设 //cnpm install -D babel-preset-react { \"presets\": [ \"es2015\", \"react\" ] } 不过上面这些preset官方现在都已经不推荐了，官方唯一推荐preset：babel-preset-env。 这款preset能灵活决定加载哪些插件和polyfill，不过还是得开发者手动进行一些配置。 // cnpm install -D babel-preset -env { \"presets\": [ [\"env\", { \"targets\": { //指定要转译到哪个环境 //浏览器环境 \"browsers\": [\"last 2 versions\", \"safari >= 7\"], //node环境 \"node\": \"6.10\", //\"current\" 使用当前版本的node }, //是否将ES6的模块化语法转译成其他类型 //参数：\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | false，默认为'commonjs' \"modules\": 'commonjs', //是否进行debug操作，会在控制台打印出所有插件中的log，已经插件的版本 \"debug\": false, //强制开启某些模块，默认为[] \"include\": [\"transform-es2015-arrow-functions\"], //禁用某些模块，默认为[] \"exclude\": [\"transform-es2015-for-of\"], //是否自动引入polyfill，开启此选项必须保证已经安装了babel-polyfill //参数：Boolean，默认为false. \"useBuiltIns\": false }] ] } 简单的搭建ES6转换环境(非webpack) mkdir es6-env cd es6-env npm init -y npm install -D babel-cli babel-plugin-transform-runtime babel-polyfill babel-preset-env babel-preset-stage-0 .babelrc配置 { \"presets\": [ [\"env\", { \"modules\": false }], \"stage-0\" ], \"plugins\": [\"transform-runtime\"] } packages.json文件添加script \"scripts\": { \"compile\": \"babel src --out-dir dist\" } 现在执行 npm run compile 命令就会把src文件夹中的ES6文件转换为ES5文件并且输出到dist目录 小结 本文对babel进行入门学习，并且搭建了一个简单的babel编译环境。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 18:00:10 "},"ES6.html":{"url":"ES6.html","title":"ES6","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:34:39 "},"【基础】ES6Class语法学习.html":{"url":"【基础】ES6Class语法学习.html","title":"【基础】 ES6 Class语法学习","keywords":"","body":"前言 大多数面向对象的编程语言都支持类和类继承的特性，而JS却不支持这些特性，只能通过其他方法定义并关联多个相似的对象，这种状态一直延续到了ES5。由于类似的库层出不穷，最终还是在ECMAScript 6中引入了类的特性。本文将详细介绍ES6中的类 类的定义 【ES5的类】 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return '(' + this.x + ', ' + this.y + ')'; }; var p = new Point(1, 2); 【ES6的类】 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } [注意]this关键字则代表实例对象 [注意]类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。 [注意]类不存在变量提升，这点与ES5完全不同 typeof Point // 'function' Point === Point.prototype.constructor // true 类的数据类型就是函数，类本身就指向构造函数。 属性的另一种定义方式 class IncreasingCounter { _count = 0; // 可以直接这样定义，而不定义在constructor中 increment() { this._count++; } } 这种写法比较简洁，比较推荐的写法 是否可枚举 ES5中类的方法可以枚举 var Point = function (x, y) { // ... }; Point.prototype.toString = function() { // ... }; Object.keys(Point.prototype) // [\"toString\"] Object.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"] ES6中类的方法不可枚举 class Point { constructor(x, y) { // ... } toString() { // ... } } Object.keys(Point.prototype) // [] Object.getOwnPropertyNames(Point.prototype) // [\"constructor\",\"toString\"] constructor构造函数 1、constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。2、一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 类的调用 通过 new 关键字调用，如果忘记加 new 则会报错 const point = new Point(); 类的属性表达式 let methodName = 'getArea'; class Square { constructor(length) { // ... } [methodName]() { // ... } } 立即执行类 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); } }('张三'); person.sayName(); // \"张三\" 静态方法 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { static classMethod() { return 'hello'; } } Foo.classMethod() // 'hello' var foo = new Foo(); foo.classMethod() // TypeError: foo.classMethod is not a function [注意]如果静态方法包含this关键字，这个this指的是类，而不是实例。 [注意]静态方法可继承 静态属性 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。 class Foo { } Foo.prop = 1; Foo.prop // 1 new.target 属性 new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error('必须使用 new 命令生成实例'); } } // 另一种写法 function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error('必须使用 new 命令生成实例'); } } var person = new Person('张三'); // 正确 var notAPerson = Person.call(person, '张三'); // 报错 Class 内部调用new.target，返回当前 Class。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; } } var obj = new Rectangle(3, 4); // 输出 true 【new.target子类继承会返回子类的名称】 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error('本类不能实例化'); } } } class Rectangle extends Shape { constructor(length, width) { super(); // ... } } var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确 extends 继承 class Point { } class ColorPoint extends Point { } 【父类的静态方法，也会被子类继承】 class A { static hello() { console.log('hello world'); } } class B extends A { } B.hello() // hello world super 关键字 1、super作为函数调用时，代表父类的构造函数。2、super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。3、在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。4、super在静态方法之中指向父类，在普通方法之中指向父类的原型对象。 【1】 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString() } } [注意]子类必须在constructor方法中调用super方法，否则新建实例时会报错。 【2】 class A { p() { return 2; } } class B extends A { constructor() { super(); console.log(super.p()); // 2 } } let b = new B(); 子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。 【3】 class A { constructor() { this.x = 1; } print() { console.log(this.x); } } class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); } } let b = new B(); b.m() // 2 【4】 class Parent { static myMethod(msg) { console.log('static', msg); } myMethod(msg) { console.log('instance', msg); } } class Child extends Parent { static myMethod(msg) { super.myMethod(msg); } myMethod(msg) { super.myMethod(msg); } } Child.myMethod(1); // static 1 var child = new Child(); child.myMethod(2); // instance 2 Object.getPrototypeOf() Object.getPrototypeOf方法可以用来从子类上获取父类。 Object.getPrototypeOf(ColorPoint) === Point // true 类的 prototype 属性和proto属性 大多数浏览器的 ES5 实现之中，每一个对象都有proto属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和proto属性，因此同时存在两条继承链。 （1）子类的proto属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的proto属性，表示方法的继承，总是指向父类的prototype属性。 class A { } class B extends A { } B.__proto__ === A // true B.prototype.__proto__ === A.prototype // true 【非继承时__proto , prototype】 class A { } A.__proto__ === Function.prototype // true A.prototype.__proto__ === Object.prototype // true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Function.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.proto指向构造函数（Object）的prototype属性。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:37:22 "},"【重难】ES6数组遍历方法的实战用法总结（forEach，every，some，map，filter）.html":{"url":"【重难】ES6数组遍历方法的实战用法总结（forEach，every，some，map，filter）.html","title":"【重难】 ES6数组遍历方法的实战用法总结（forEach，every，some，map，filter）","keywords":"","body":"前言 ES6原生语法中提供了非常多好用的数组'遍历'方法给我们，让我们可以实现更多更强大的功能，下面让我们通过这篇文章好好学习下，该如何使用它们 代码线上测试地址：babel test forEach 对数组的每个元素执行一次提供的函数。跳过空位元素 没有办法中止或者跳出 forEach() 循环，除了抛出一个异常。如果你需要这样，使用 forEach() 方法是错误的。 语法解析 arr.forEach((currentValue,index,array)=>{}); // currentValue 数组中正在处理的当前元素 // index 当前索引值 // array 正在处理的数组 // 返回值是undefined 例子则是非常简单的应用了 [1,2,3].forEach((currentValue,index,array)=>{ console.log(currentValue,index,array); }); every 回调函数中，所有的都返回真，则返回真，有一个返回假，则返回假。简而言之：“一假则假” 语法解析 arr.every((currentValue,index,array)=>{ // currentValue = 当前执行元素 // index = 当前索引值 // array = 执行的数组 }) 返回值是true或者false 可别小看这个方法，我自己平时工作当中两个方面经常使用到 全选中使用 多个关系的搜索中使用 先看一个简单的例子 [12, 5, 8, 130, 44].every((item)=>{ return item >= 10 }) 上面的意思：当数组中所有的元素的值都大于10的时候则返回true，否则返回false 全选伪代码示例 let allChecked = false; const arr = [ { id:\"a\", name:\"a\", checked:false }, { id:\"b\", name:\"b\", checked:false } ] allChecked = arr.every((item)=>{ return item.checked === true }) // 实现起来就是这么简单，当所有的都选中了，allChecked 全选的变量就赋值true // 这如果硬是用es5的语法去实现的话，还是比较麻烦的 some 回调函数中有一个返回真，则返回真简言之：“一真则真” 语法解析 arr.some((currentValue,index,array)=>{ // currentValue = 当前执行元素 // index = 当前索引值 // array = 执行的数组 }) 返回值是true或者false 代码展示 let bok = [2, 5, 8, 1, 4].some((item)=>{ return item>5 }) // bok = true // 只要有一个数组大于5 则整体返回true map 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法 arr.map((currentValue,index,array)=>{ // currentValue = 当前执行元素 // index = 当前索引值 // array = 执行的数组 }) // 返回一个新的数组 实例 let arr = [1,2,3,4]; const map = arr.map(x=>x*2); //返回每一个处理过后的新数组 [2,4,6,8] filter 返回一个新数组，其结果是改数组中的每个元素符合条件的结果 语法 arr.filter((currentValue,index,array)=>{ // currentValue = 当前执行元素 // index = 当前索引值 // array = 执行的数组 }) // 返回一个新的数组 顾名思义这个应该肯定是各类查询，筛选上面 实例 let arr = [{name:\"abc\"},{name:\"bcd\"},{name:\"afc\"}]; arr.filter((item)=>{ return item.name.includes('b'); }); // 筛选出名字字段中带有b的项 reduce && reduceRight reduce()方法在数组的每个成员上执行一个reducer函数(您提供的)，生成一个输出值。 reduceRight是从右到左的相加(其它的同reduce是一样的，所以这里只讲reduce) 语法 无参数 arr.reduce((accumulator, currentValue,currentIndex,array)=>{ // accumulator第一项的值或者上一次叠加的结果值 // currentValue 当前项 // currentIndex 当前项索引 // array 数组本身 }); 有参数 arr.reduce((accumulator, currentValue,currentIndex,array)=>{},参数); 参数 = accumulator 第一次运行时的初始值 实例1：计算数据总和 const arr = [1,2,3]; const num = arr.reduce((acc,cur,index)=>{ return acc + cur }); // num = 6 const num1 = arr.reduce((acc,cur,index)=>{ return acc+cur },10) // num = 16 实例2：计算一个字符串中字母出现的次数 const str = 'aaabbcccdd'; str.split('').reduce((acc,cur)=>{ acc[cur] ? acc[cur]++ : acc[cur] = 1 },{}); 解析：初始化的值是一个空对象 运行的时候，判断对象里面是不是有当前的字母， 如果没有的话则添加到对象中，并赋值为1 如果已经存在的话在++，这样就计算出一个字符串中字母出现的次数 同样可以利用这点进行数组去重 const arr = ['a','a','b','c']; const obj = arr.reduce((acc,cur)=>{ return acc[cur] ? acc[cur]++ : acc[cur] = 1 },{}) 最后通过obj.keys() 的方法获取到的数组就是去重之后的。 indexOf indexOf()方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回-1。 var beasts = ['ant', 'bison', 'camel', 'duck', 'bison']; console.log(beasts.indexOf('bison')); // expected output: 1 // start from index 2 console.log(beasts.indexOf('bison', 2)); // expected output: 4 console.log(beasts.indexOf('giraffe')); // expected output: -1 lastIndexOf lastIndexOf()方法返回给定元素在数组中找到的最后一个索引，如果该元素不存在，则返回-1。数组从fromIndex开始向后搜索。 var animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo']; console.log(animals.lastIndexOf('Dodo')); // expected output: 3 console.log(animals.lastIndexOf('Tiger')); // expected output: 1 小结 本篇文章主要讲述了ES6中数组新增的一些方法，以及如何使用。其实这些方法的实战场景还是非常多的，需要在实战中才能有更加深刻的体会 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 18:40:26 "},"JavaScript.html":{"url":"JavaScript.html","title":"JavaScript","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:34:59 "},"基础语法.html":{"url":"基础语法.html","title":"基础语法","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:44:34 "},"JavaScript基础基础语法、关键字和保留字、变量.html":{"url":"JavaScript基础基础语法、关键字和保留字、变量.html","title":"JavaScript 基础(基础语法、关键字和保留字、变量)","keywords":"","body":"前言 任何语言的核心都必然会描述这门语言最基本的工作原理。而描述的内容通常都要涉及这门语言的语法、操作符、数据类型、内置功能等用于构建复杂解决方案的基本概念。如前所述，ECMA-262通过叫做ECMAScript的“伪语言”为我们描述了JavaScript的所有这些基本概念。 由于基础概念较多如果放在一篇文章会使得篇幅特别长，所以本文主要讲解：基础语法，关键字和保留字，变量等内容 语法 ECMAScript的语法大量借鉴了C及其他类C语言（如Java和Perl）的语法。因此，熟悉这些语言的开发人员在接受ECMAScript更加宽松的语法时，一定会有一种轻松自在的感觉。 【区分大小写】要理解的第一个概念就是ECMAScript中的一切（变量、函数名和操作符）都区分大小写。 var test = 1; var Test = 2; 这是完全不同的两个变量 【标识符】所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。 标识符规则 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）； 其他字符可以是字母、下划线、美元符号或数字。 一般采用驼峰格式，即第一个字母小写，剩下的每个单词的首字母大写 [注意]标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如À和Æ），但我们不推荐这样做。 正确的标识符 var _a = 1; var $a = 1; var a = 1; firstSecond myCar doSomethingImportant 错误的标识符 var 1bar = 1;// 报错：Uncaught SyntaxError: Unexpected number var %11aa = 2; // 报错：Uncaught SyntaxError: Unexpected token % [注意]不能把关键字、保留字、true、false和null用作标识符。 【注释】 // 单行注释 /* * 这是一个多行 * （块级）注释 */ 【语句】ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示： var sum = a + b // 即使没有分号也是有效的语句——不推荐 var diff = a - b; // 有效的语句——推荐 虽然语句结尾的分号不是必需的，但我们建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩ECMAScript代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。 可以使用C风格的语法把多条语句组合到一个代码块中，即代码块以左花括号（{）开头，以右花括号（}）结尾： if (test) alert(test); // 有效但容易出错，不要使用 if (test){ // 推荐使用 alert(test); } 在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率。 关键字和保留字 ECMA-262描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。以下就是ECMAScript的全部关键字（带*号上标的是第5版新增的关键字）： break do instanceof typeof case else new var catch finally return void continue for switch while debugger* function this with default if throw delete in try ECMA-262还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。以下是ECMA-262第3版定义的全部保留字： abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public 第5版把在非严格模式下运行时的保留字缩减为下列这些： class enum extends super const export import 在严格模式下，第5版还对以下保留字施加了限制： implements package public interface private static let protected yield 注意，let和yield是第5版新增的保留字；其他保留字都是第3版定义的。为了最大程度地保证兼容性，建议读者将第3版定义的保留字外加let和yield作为编程时的参考。 除了上面列出的保留字和关键字，ECMA-262第5版对eval和arguments还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。 变量 ECMAScript的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。 var message ; let message ; 这行代码定义了一个名为message的变量，该变量可以用来保存任何值（像这样未经过初始化的变量，会保存一个特殊的值——undefined） 有一点必须注意，即用var操作符定义的变量将成为定义该变量的作用域中的局部变量。 function test(){ var message = \"hi\"; // 局部变量 } test(); alert(message); // 错误！ 不过，可以像下面这样省略var操作符，从而创建一个全局变量： function test(){ message = \"hi\"; // 全局变量 } test(); alert(message); // \"hi\" [注意]非常不推荐这么做 【一条语句定义多个变量】 var message = \"hi\", found = false, age = 29; 在严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。 声明提升(hoisting) 块级作用域　　块级作用域是指花括号内的每一段代码都具有各自的作用域，而javascript没有块级作用域。javascript只有函数作用域：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的 　　这意味着，变量在声明之前甚至已经可用。javascript这个特性被非正式地称为声明提升(hoisting)，javascript函数里声明的所有变量(不涉及赋值)都被提前到函数体的顶部 　　[注意]其实除了变量提升，函数也被提升，到函数部分会有详细介绍 var scope = 'global'; function f(){ console.log(scope);//undefined var scope = 'local'; console.log(scope);//'local' } //变量声明提升之后，相当于下面代码 var scope = 'global'; function f(){ var scope; console.log(scope);//undefined scope = 'local'; console.log(scope);//'local' } javascript中没有块级作用域，所以一些程序员特意将变量声明放在函数体顶部，这种源代码非常清晰地反映了真实的变量作用域 属性变量 　　当声明一个javascript全局变量时，实际上是定义了全局对象window的一个属性 　　当使用var声明一个变量时，创建的这个变量是不可配置的，也就是说这个变量无法通过delete运算符删除 var truevar = 1; console.log(truevar,window.truevar);//1 1 delete truevar;//false console.log(truevar,window.truevar);//1 1 　　如果没有使用严格模式并给一个未声明的变量赋值的话，javascript会自动创建一个全局变量，以这种方式创建的变量是全局对象的正常的可配置属性，并可以删除它们 　　[注意]IE8-浏览器下，如果删除window属性时，不论该属性是如何创建的，都会报错 window.fakevar1 = 10; this.fakevar2 = 20; var fakevar3 = 30; fakevar4 = 40; console.log(delete fakevar1);//IE8-浏览器报错，其他浏览器返回true console.log(delete fakevar2);//IE8-浏览器报错，其他浏览器返回true console.log(delete fakevar3);//所有浏览器都返回false console.log(delete fakevar4);//所有浏览器都返回true 　　javascript全局变量是全局对象的属性，这是在ECMAScript中强制规定的。局部变量当做跟函数调用相关的某个对象的属性。ECMAScript3称为调用对象(call object)，ECMAScript5称为声明上下文对象(declarative environment record)。javascript允许使用this关键字来引用全局对象，却没有办法可以引用局部变量中存放的对象。这种存放局部变量对象的特有性质，是一种对我们不可见的内部实现 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:47:04 "},"JavaScript基础表达式.html":{"url":"JavaScript基础表达式.html","title":"JavaScript 基础(表达式)","keywords":"","body":"前言 一般地，关于javascript基础语法，人们听得比较多的术语是操作符和语句。但是，其实还有一个术语经常使用，却很少被提到，这就是javascript表达式(expression)。本文将详细介绍javascript表达式，表达式分为原始表达式和复杂表达式 原始表达式(primary exression) 　　原始表达式是表达式的最小单位——它不再包含其他表达式 　　原始表达式分为字面量、关键字和变量；详细来说包括this关键字、标识符引用、字面量引用、数组初始化、对象初始化和分组表达式 PrimaryExpression : this Identifier Literal ArrayLiteral ObjectLiteral ( Expression ) this关键字和标识符 this;//返回当前对象 i;//返回变量i的值 sum;//返回变量sum的值 字面量 　　字面量(literal)，又翻译成直接量，就是程序中直接使用的数据值 Literal :: NullLiteral BooleanLiteral NumericLiteral StringLiteral RegularExpressionLiteral null; undefined; true; false; 1; 'abc'; /pattern/; 数组和对象初始化 　　数组初始化和对象初始化实际上是一个以字面量的方式描述的初始化的过程。这两个初始化表达式有时称做\"对象字面量\"和\"数组字面量\" []; [1,2,3]; {}; {a:1}; 分组表达式 　　分组表达式实际上就是括号，用于重写运算符的优先级 复杂表达式(MemberExpression) 　　复杂表达式由原始表达式和操作符(operator)组合而成，包括属性访问表达式、对象创建表达式和函数表达式 【属性访问表达式】 　　属性访问表达式运算可以得到一个对象属性或一个数组元素的值，javascript为属性访问定义了两种语法 MemberExpression . IdentifierName MemberExpression [ Expression ] 　　第一种写法是一个表达式后跟随一个句点和标识符。表达式指定对象，标识符则指定需要访问的属性的名称 　　第二种写法是使用方括号，方括号内是另外一个表达式(这种方法适用于对象和数组)。第二个表达式指定要访问的属性的名称或代表要访问数组元素的索引 var o = {x:1,y:{z:3}}; //对象字面量 var a = [o,4,[5,6]]; // 包含对象的数组字面量 o.x;//表达式o的x属性 o.y.z;//表达式o.y的z属性 o['x'];//对象o的x属性 a[1];//表达式a中索引为1的元素 　　不管使用哪种形式的属性访问表达式，在'.'和'['之前的表达式总是会首先计算 　　如果计算结果是null或undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性 　　如果计算结果不是对象，javascript会将其转换为对象 　　如果对象表达式后跟随句点和标识符，则会查找由这个标识符指定的属性值，并将其作为整个表达式的值返回 　　如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将其转换为字符串 　　不论哪种情况，如果命名的属性不存在，那么整个属性访问表达式的值就是undefined 【对象创建表达式】　　对象创建表达式创建一个对象并调用一个函数初始化新对象的属性 new Object(); new Point(2,3); 　　如果一个对象创建表达式不需要传入任何参数给构造函数的话，那么这对空圆括号是可以省略的 new Object; 【函数表达式】　　函数表达式分为函数定义表达式和函数调用表达式 　　函数定义表达式定义一个javascript函数，表达式的值是这个新定义的函数 　　一个典型的函数定义表达式包含关键字function，跟随其后的是一对圆括号，括号内是一个以逗号分割的列表，列表含有0个或多个标识符(参数名)，然后再跟随一个由花括号包裹的javascript代码段(函数体) function square(x){ return x*x; } 　　函数定义表达式同样可以包含函数的名字，函数也可以通过函数语句来定义，而不是函数表达式 var square = function(x){return x*x;} 　　函数调用表达式是一种调用或执行函数或方法的语法表示。如果这个表达式是一个属性访问表达式，那么这个调用称做方法调用 f(0); Math.max(x,y,z); a.sort(); Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:48:12 "},"JavaScript基础usestrict严格模式下的规则.html":{"url":"JavaScript基础usestrict严格模式下的规则.html","title":"JavaScript 基础 'use strict'严格模式下的规则","keywords":"","body":"why 严格模式 [1] 消除js语法的一些不合理、不严谨、不安全问题，减少怪异行为并保证代码运行安全[2] 提高编译器效率，增加运行速度 使用 [1]整个脚本启用严格模式，在顶部执行：\"use strict\";[2]在指定函数中执行严格模式，在函数体第一行：\"use strict\"[3]不支持strict模式的浏览器把\"use strict\"当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式[4]支持严格模式的浏览器包括IE10+、Firefox4+、safari12+、opera12+、chrome 规则 【1】变量 [a]不允许意外创建全局变量 \"use strict\"; message = 'hello world!'; [b]不能对变量调用delete操作符 \"use strict\"; var color = 'red'; delete color; 【2】对象 \"use strict\"; var person = { name:'cook' }; [a]不能为只读属性赋值 Object.defineProperty(person,'name',{ writable: false }); person.name = 'Nicholas'; [b]不能为不可配置的属性使用delete操作 Object.defineProperty(person,'name',{ configurable: false }); delete person.name; 【3】函数 [a]参数必须唯一 \"use strict\"; function sun(num,num){ //TODO } [b]修改形参不会反映到arguments中 function showValue(value){ value = \"Foo\"; alert(arguments[0]); //非严格模式:\"Foo\" //严格模式:\"Hi\" } showValue(\"Hi\"); [c]不允许使用arguments.callee和arguments.caller // callee是arguments对象的一个属性、用来指向当前执行的函数。 // caller是function对象的一个属性用于返回一个function引用、它返回调用它的function对象 \"use strict\"; function fn(num){ return arguments.callee(num); } fn(2); // 报错 function outer(){ inner(); } function inner(){ alert(inner.caller()); } outer(); // 报错 【4】不允许eval()在包含上下文中创建变量或函数 \"use strict\"; function fn(){ eval(\"var x=10\"); alert(x); } fn(); // 报错 但是允许下面这样做 //允许以下操作 var result = eval(\"var x = 10, y = 11; x+y\"); alert(result);//21 【5】不允许使用eval和arguments作为标识符，也不允许读写他们的值 \"use strict\"; var eval = 10; var arguments = 20; 【6】不允许this值为null或undefined \"use strict\"; var color = \"red\"; function fn(){ alert(this.color); } fn(); // 这样调用的话 this指向undefined 因此报错 new fn() // 这样调用的话 this指向实例对象 因此不会报错 【7】不允许使用with语句 \"use strict\"; with(location){ alert(href); } 【8】不允许使用八进制字面量 \"use strict\"; var value = 010; Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:49:08 "},"变量作用域.html":{"url":"变量作用域.html","title":"变量、作用域和内存","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:49:18 "},"JavaScript基本类型和引用类型.html":{"url":"JavaScript基本类型和引用类型.html","title":"JavaScript 基本类型和引用类型","keywords":"","body":"前言 ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。 基本类型 Undefined、Null、Boolean、Number和String 引用类型 除了上诉基础类型以外的都是引用类型，例如Object，Array等 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。 [注意]当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。 【操作属性】引用类型可操作属性 var person = new Object(); person.name = \"Nicholas\"; alert(person.name); //\"Nicholas\" [注意] 基本类型是不能操作属性的 【复制变量值】基本类型 var num1 = 5; var num2 = num1; num1中保存的值是5。当使用num1的值来初始化num2时，num2中也保存了值5。但num2中的5与num1中的5是完全独立的。这两个变量可以参与任何操作而不会相互影响。 引用类型 当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量，如下面的例子所示： var obj1 = new Object(); var obj2 = obj1; obj1.name = \"Nicholas\"; alert(obj2.name); //\"Nicholas\" 【传递参数】ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。 在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部 基本类型 function addTen(num) { num += 10; return num; } var count = 20; var result = addTen(count); alert(count); //20，没有变化 alert(result); //30 引用类型 function setName(obj) { obj.name = \"Nicholas\"; } var person = new Object(); setName(person); alert(person.name); //\"Nicholas\" 以上代码中创建一个对象，并将其保存在了变量person中。然后，这个变量被传递到setName()函数中之后就被复制给了obj。在这个函数内部，obj和person引用的是同一个对象。 [关键词]可以把ECMAScript函数的参数想象成局部变量。 【检测类型】1、检测基本类型（除null）使用typeof var s = \"Nicholas\"; var b = true; var i = 22; var u; var n = null; var o = new Object(); alert(typeof s); //string alert(typeof i); //number alert(typeof b); //boolean alert(typeof u); //undefined alert(typeof n); //object alert(typeof o); //object 2、检测引用类型的值使用 instanceof instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 var str = \"This is a simple string\"; var num = 1111; var boolean = true; var und = undefined; var nl = null; var sb = Symbol('1111'); var obj = {}; // 非原始类型数据字面量定义 console.log(str instanceof String); // false console.log(num instanceof Number); // false console.log(boolean instanceof Boolean); // false console.log(nl instanceof Object); // false console.log(sb instanceof Symbol); // false console.log(obj instanceof Object); // true var strN = new String(\"This is a simple string\"); var numN = new Number(1111); var booleanN = new Boolean(true); var objN = new Object(); console.log(strN instanceof String); // true console.log(numN instanceof Number); // true console.log(booleanN instanceof Boolean); // true console.log(objN instanceof Object); // true 那么还没有其它检测数据类型的方式呢？可以看另外一篇文章 JavaScript 有效检测数据类型 小结 本文主要介绍基本类型和引用类型的一些区别，如“属性操作”，“变量值复制”，“参数传递方式”，“类型检测” 等几个方面的不同表现。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:52:52 "},"JavaScript执行环境、作用域、内存管理及垃圾回收机制.html":{"url":"JavaScript执行环境、作用域、内存管理及垃圾回收机制.html","title":"JavaScript 执行环境、作用域、内存管理及垃圾回收机制","keywords":"","body":"前言 JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 [原理]找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。 在学习垃圾回收机制之前让我们先来学习下执行环境及作用域 执行环境 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 【类型】全局和局部（函数） 【全局执行环境】 [1]最外围的一个执行环境[2]根据宿主环境不同表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是window对象[3]全局变量和函数都是作为window对象的属性和方法创建的[4] 某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁） 【环境栈】每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着。 作用域链(scope chain) 作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 1、作用域链的前端，始终都是当前执行的代码所在环境的变量对象。 2、全局执行环境的变量对象始终都是作用域链中的最后一个对象。 3、标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。 4、内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。（但是闭包可以解决这个问题） [注意]函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同 【活动对象（activation object）】作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。 延长作用域链 1、try-catch语句的catch块2、with语句 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。 function buildUrl() { var qs = \"?debug=true\"; with(location){ var url = href + qs; } return url; } 在此，with语句接收的是location对象，因此其变量对象中就包含了location对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端。buildUrl()函数中定义了一个变量qs。当在with语句中引用变量href时（实际引用的是location.href），可以在当前执行环境的变量对象中找到。当引用变量qs时，引用的则是在buildUrl()中定义的那个变量，而该变量位于函数环境的变量对象中。至于with语句内部，则定义了一个名为url的变量，因而url就成了函数执行环境的一部分，所以可以作为函数的值被返回。 [注意]在IE8及之前版本的JavaScript实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。 没有块级作用域 if (true) { var color = \"blue\"; } alert(color); //\"blue\" 这里是在一个if语句中定义了变量color。如果是在C、C++或Java中，color会在if语句执行完毕后被销毁。但在JavaScript中，if语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）中。 for (var i=0; i 对于有块级作用域的语言来说，for语句初始化变量的表达式所定义的变量，只会存在于循环的环境之中。而对于JavaScript来说，由for语句创建的变量i即使在for循环执行结束后，也依旧会存在于循环外部的执行环境中。 【声明变量】使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。 function add(num1, num2) { sum = num1 + num2; return sum; } var result = add(10, 20); //30 alert(sum); //30 这个例子中的变量sum在被初始化赋值时没有使用var关键字。于是，当调用完add()之后，添加到全局环境中的变量sum将继续存在；即使函数已经执行完毕，后面的代码依旧可以访问它。 【查询标识符】当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。 var color = \"blue\"; function getColor(){ return color; } alert(getColor()); //\"blue\" [注意]变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。JavaScript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。 垃圾收集 JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。 局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。 标记清除 JavaScript中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 [注意]实际的实现过程远比这个复杂，这里只是简述一个工作流程，让我们能更清晰的理解这个过程 [注意]到2008年为止，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同 引用计数 另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。 [注意]由于未能很好解决循环引用的问题，很快引用计数的方式被淘汰了。 但是为什么还要提及它呢。因为IE( var element = document.getElementById(\"some_element\"); var myObject = new Object(); myObject.element = element; element.someObject = myObject; 这个例子在一个DOM元素（element）与一个原生JavaScript对象（myObject）之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象；而变量element也有一个属性名叫someObject回指myObject。由于存在这个循环引用，即使将例子中的DOM从页面中移除，它也永远不会被回收。 所以碰到这种情况，我们只能手动来解除这种关系 myObject.element = null; element.someObject = null; 将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 性能问题 IE6垃圾回收触发条件:256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。 如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。 IE7垃圾回收机制：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了IE在运行包含大量JavaScript的页面时的性能。 在IE中，调用window.CollectGarbage()方法会立即执行垃圾收集。在Opera 7及更高版本中，调用window.opera.collect()也会启动垃圾收集例程。 小结 通过本文，我们学习了JavaScript执行环境，作用域链，垃圾回收机制的两种方式：标记清楚，应用计数。以及最后了解了下IE中的垃圾回收的性能问题。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:56:07 "},"数据类型.html":{"url":"数据类型.html","title":"数据类型","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:56:32 "},"JavaScript基本包装类型,包装对象.html":{"url":"JavaScript基本包装类型,包装对象.html","title":"JavaScript 基本包装类型,包装对象","keywords":"","body":"前言 javascript对象是一种复合值，它是属性或已命名值的集合。通过'.'符号来引用属性值。当属性值是一个函数时，称其为方法。通过o.m()来调用对象o中的方法。我们发现，字符串也同样具有属性和方法 var s = 'hello world'; console.log(s.length);//11 字符串既然不是对象，为什么它会有属性呢？这就引出了今天介绍的内容——包装对象 定义 在javascript中，“一切皆对象”，就连三种原始类型的值(数值、字符串、布尔值)，在一定条件下，也会自动转为对象，也就是原始类型的“包装对象” 包装对象是特殊的引用类型。每当读取字符串、数字或布尔值的属性或方法时，创建的临时对象称做包装对象 为了便于引用字符串的属性和方法，javascript将字符串值通过调用new String()的方式转换成对象，这个对象继承了字符串的属性和方法，并被用来处理属性和方法的引用。一旦属性或方法引用结束，这个新创建的对象就会销毁。数字或布尔值也类似 实际的过程可以理解为下面： var s1 = 'some text'; var s2 = s1.substring(2); //上述过程看起来发生了三个步骤 var s1 = new String('some text'); //(1)创建String类型的一个实例 var s2 = s1.substring(2); //(2)在实例上调用指定的方法 s1 = null; //(3)销毁这个实例 生存期 引用类型和基本包装类型的主要区别是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着不能在运行时为基本类型值添加属性和方法 var s1 = 'some text'; s1.color = 'red'; alert(s1.color);//undefined var s2 = new Boolean('some text'); s2.color = 'red'; alert(s2.color);//'red' 显式创建 可以通过new操作符显式创建包装对象，但应该在绝对必要的情况下再这样做。因为这种做法，很容易让人分不清是在处理基本类型还是引用类型的值 有两种方式显式创建包装类型的方式: // Object方式 var s = new Object('abc'); var b = new Object(true); var n = new Object(123); // 构造函数方式 var s = new String('abc'); var b = new Boolean(true); var n = new Number(123); 转型函数 直接调用转型函数与使用new调用基本包装类型的构造函数是不一样的，使用转型函数返回的是基本类型值 var s = 'abc'; // typeof s === string var s1 = String(s); // typeof s1 === string var s2 = new String(s); // typeof s2 === object var s3 = new Object(s); // typeof s3 === object 比较运算 【1】等于运算符'=='将原始值和其包装对象视为相等，因为其中一个操作数是对象，需要调用对象的valueOf()方法，Number对象、Boolean对象和String对象的valueOf()方法都返回其对应的原始值 var s1 = new String('abc'); var s2 = 'abc'; var n1 = new Number(123); var n2 = 123; var b1 = new Boolean(true); var b2 = true; console.log(s1 == s2, n1 == n2, b1 == b2);//true true true 【2】全等运算符'==='将原始值和其包装对象视为不相等。因为全等运算符要比较类型和值，原始值和其包装对象的类型不同 var s1 = new String('abc'); var s2 = 'abc'; var n1 = new Number(123); var n2 = 123; var b1 = new Boolean(true); var b2 = true; console.log(s1 === s2, n1 === n2, b1 === b2);//false false false 小结 通过本文，我们学习了什么是包装类型，包装类型就是原始类型的对象表示，这样使得原始类型也可以有自己的属性和方法了。 包装对象和原始值的区别基本上就是“基本类型”和“引用类型”的区别了。譬如：能否定义属性和方法，typeof 值不一样。 使用String()等转型函数和使用new String() 是不一样的。前者返回基本类型，后者返回对象类型。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:57:29 "},"JavaScriptnull和undefined的区别.html":{"url":"JavaScriptnull和undefined的区别.html","title":"JavaScript null和undefined的区别","keywords":"","body":"前言 1995年javascript诞生时，最初像Java一样，只设置了null作为表示”无”的值。根据C语言的传统，null被设计成可以自动转为0 但是，javascript的设计者Brendan Eich，觉得这样做还不够，有两个原因。首先，null像在Java里一样，被当成一个对象。但是，javascript的值分成原始类型和对象类型两大类，Brendan Eich觉得表示”无”的值最好不是对象。其次，javascript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误 因此，Brendan Eich又设计了一个undefined。他是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN 但是，目前null和undefined基本是同义的，都是原始类型，且只有一些细微的差别 Undefined Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined，例如： var msg; msg === undefined // true 等同于： var msg = undefined; // 使用undefined值显式初始化了变量message。但我们没有必要这么做，因为未经初始化的值默认就会取得undefined值。 【undefined 出现场景】 1、已声明未赋值的变量 var i ;// undefined 2、获取对象不存在的属性 var o = {}; o.i // undefined 3、无返回值的函数的执行结果 function f(){} f() // undefined 4、函数的参数没有传入 function f(x){return x;} f() // undefined 5、void(expression) void(0) // undefined 【类型转换】 Boolean(undefined):　 false Number(undefined):　 NaN String(undefined):　　'undefined' 【类型鉴别】 鉴别undefined类型，使用typeof运算符即可 typeof undefined ; // undefined [注意]由于undefined并不是一个关键字，其在IE8-浏览器中会被重写，在高版本函数作用域中也会被重写；所以可以用void 0 来替换undefined var undefined = 10; console.log(undefined);//IE8-浏览器下为10，高版本浏览器下为undefined function t(){ var undefined = 10; console.log(undefined); } console.log(t());//所有浏览器下都是10 Null Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null值时会返回\"object\"的原因，如下面的例子所示： var car = null; alert(typeof car); // \"object\" // 不同的对象在底层都表示为二进制，在javascript中二进制前三位都为0会被判断为object类型，null的二进制表示是全0，所以执行typeof时返回'object' 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子所示： if (car != null){ // 对car对象执行某些操作 } 实际上，undefined值是派生自null值的，因此ECMA-262规定对它们的相等性测试要返回true： null == undefined // true 【类型转换】 Boolean(null): 　　false Number(null):　　 0 String(null): 　　 'null' 【类型鉴别】鉴别null类型，使用typeof运算符不可行，因为该运算符会返回'object'，null被认为是空对象指针判断一个值是否为null类型的最佳方法是直接和null进行恒等比较 console.log(typeof null);//'object' console.log(null === null);//true console.log(undefined === null);//false console.log('null' === null);//false undefined 和 null 的区别 最后总结下二者的区别： 1、null表示空对象指针而undefined表示未经初始化的变量2、数字类型转换时 Number(undefined) 是 NaN；而 Number(null) 是 03、做类型判断的时候 undefined 使用typeof即可；而 null则不能使用typeof 而需要和自身进行比较 null === null Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:58:32 "},"JavaScript数据类型Boolean布尔类型.html":{"url":"JavaScript数据类型Boolean布尔类型.html","title":"JavaScript数据类型 Boolean布尔类型","keywords":"","body":"前言 布尔值Boolean类型可能是三种包装对象Number、String和Boolean中最简单的一种。Number和String对象拥有大量的实例属性和方法，Boolean却很少。从某种意义上说，为计算机设计程序就是与布尔值打交道，作为最基本的事实，所有的电子电路只能识别和使用布尔数据。本文将介绍布尔Boolean类型 定义 布尔Boolean类型表示逻辑实体，它只有两个值，保留字true和false，分别代表真和假这两个状态 Boolean包装类型是与布尔值对应的引用类型，在布尔表达式中使用Boolean对象容易造成误解 var b1 = true; var b2 = new Boolean(true); console.log(b1,typeof b1);//true 'boolean' console.log(b2,typeof b2);//Boolean{[[PrimitiveValue]]: true} 'object' console.log(b1.valueOf(), typeof b1.valueOf());//true 'boolean' console.log(b2.valueOf(), typeof b2.valueOf());//true 'boolean' 应用场景 布尔类型主要应用于如下场景： 【1】条件和循环语句 布尔值主要应用于条件和循环语句的条件部分。比如，if语句中，如果布尔值为true执行第一段逻辑，如果为false执行另一段逻辑。通常将一个创建布尔值的比较直接与使用这个比较的语句结合在一起 if(a > 1){ //条件为true时，执行此处 }else{ //条件为false时，执行此处 } 【2】逻辑运算符逻辑运算符又叫布尔运算符。逻辑非运算符总是返回布尔值，而逻辑或和逻辑与操作并非如此 同时使用两个逻辑非操作符，可以将类型转换为布尔型 console.log(!!1);//true console.log(!!0);//false console.log(!!' ');//true console.log(!!'');//false 【3】关系运算符关系运算符用于测试两个值之间的关系，根据关系是否存在而返回true或false，关系表达式总是返回一个布尔值，通常在if、while或for语句中使用关系表达式，用以控制程序的执行流程 console.log( 1 > 2);//false console.log( 1 转为布尔 将一个值转为布尔值可使用Boolean()转型函数 假值 转换成false的值称为假值(falsy value)，这7个值包括undefined、null、+0、-0、NaN、false、\"\"(空字符串) console.log(Boolean(undefined));//false console.log(Boolean(null));//false console.log(Boolean(0));//false console.log(Boolean(-0));//false console.log(Boolean(NaN));//false console.log(Boolean(''));//false console.log(Boolean(false));//false [注意]在Number()方法中空字符串和空白字符串都转换为0，而在Boolean方法中，空字符串\"\"转换为false，而空白字符串\" \"转换为true console.log(Number(''));//0 console.log(Number(' '));//0 console.log(Boolean(''));//false console.log(Boolean(' '));//true 除了这7个假值外，其他的值转换为布尔值都是true，也称为真值(truthy value) [注意]所有对象(包括空对象)的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true console.log(Boolean({}));//true console.log(Boolean([]));//true console.log(Boolean(new Boolean(false)));//true console.log(Boolean(false));//false console.log(Boolean(new Boolean(null)));//true console.log(Boolean(null));//false 实例方法 Boolean对象是与布尔值对应的包装类型，继承了Object对象的通用方法toString()、toLocaleString()、valueOf()这三个方法 【toString()】 　　toString()方法返回Boolean的字符串值('true'或'false') 【toLocaleString()】 　　toLocaleString()方法返回Boolean的字符串值('true'或'false') 【valueOf()】 　　valueOf()方法返回Boolean的原始布尔值(true或false) console.log(true.valueOf());//true console.log(true.toString());//'true' console.log(true.toLocaleString());//'true' console.log((new Boolean(false)).valueOf());//false console.log((new Boolean(false)).toString());//'false' console.log((new Boolean(false)).toLocaleString());//'false' Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 19:59:33 "},"JavaScript数据类型Math对象详解.html":{"url":"JavaScript数据类型Math对象详解.html","title":"JavaScript数据类型 Math对象详解","keywords":"","body":"前言 javascript使用算术运算符实现基本的算术运算，如果要实现更加复杂的算术运算，需要通过Math对象定义的常量和函数来实现。和其他对象不同，Math只是一个静态对象，并没有Math()构造函数。实际上，Math只是一个由javascript设置的对象命名空间，用于存储数学常量和函数。 new Math();//Uncaught TypeError: Math is not a constructor 常量 Math对象一共有8个常量，主要包括对数、派值和平方根三类 【对数】 Math.E 自然对数的底数，即常量e的值(约等于2.71828) Math.LN2 2的自然对数(约等于0.693) Math.LN10 10的自然对数(约等于2.303) Math.LOG2E 以2为底e的对数(约等于1.443) Math.LOG10E 以10为底e的对数(约等于0.434) console.log(Math.E);//2.718281828459045 console.log(Math.LN2);//0.6931471805599453 console.log(Math.LN10);//2.302585092994046 console.log(Math.LOG2E);//1.4426950408889634 console.log(Math.LOG10E);//0.4342944819032518 【派值】 Math.PI 派的值(约等于3.14) console.log(Math.PI);//3.141592653589793 【平方根】 Math.SQRT2 2的平方根(约等于1.414) Math.SQRT1_2 1/2的平方根，即2的平方根的倒数(约等于0.707) console.log(Math.SQRT2);//1.4142135623730951 console.log(Math.SQRT1_2);//0.7071067811865476 函数 Math对象一共有18个静态函数，主要包括最值、舍入、随机数、绝对值、三角函数及乘方开方6类 [注意]这些函数都涉及到Number()隐式类型转换。若超出范围，将返回NaN 最值 Math对象的min()和max()方法用于确定一组数值中的最小和最大值，这两个方法都可以接收任意个数值参数 【Math.max()】返回参数中最大值。如果没有参数则返回-Infinity。如果任意一个参数是NaN或不可转换为数字，则返回NaN 【Math.min()】返回参数中最小值。如果没有参数则返回Infinity。如果任意一个参数是NaN或不可转换为数字，则返回NaN console.log(Math.min(1,2,3));//1 console.log(Math.max(1,2,3));//3 console.log(Math.min());//Infinity console.log(Math.max());//-Infinity console.log(Math.min(1,2,'3px'));//NaN console.log(Math.max(1,2,'3px'));//NaN 【tips】找到数组中的最大或最小值 var values = [1,2,3,4,5,6,7,8]; var maxValue = Math.max.apply(Math,values);//8 var minValue = Math.min.apply(Math,values);//1 当我们在一个表单中需要一个合法的月份值时，可以使用下列代码 Math.min(Math.max(1,input),12); 舍入 Math对象一共有三种小数舍入为整数的方法，它们是：Math.ceil()、Math.floor()和Math.round() 【Math.ceil()】执行向上取整运算，也就是说，它返回大于等于函数参数的最接近的整数[注意]Math.ceil()不会将负数变成绝对值更大的负数，而是将它们向0的方向取整 【Math.floor() 】执行向下取整运算，也就是说，它返回小于等于函数参数的最接近的整数[注意]Math.floor()对负数也向下取整，即数字将更小 【Math.round()】执行四舍五入取整运算[注意]Math.round(x) + Math.round(-x) == 0;//true，当x为数字时 console.log(Math.ceil(12.6));//13 console.log(Math.floor(12.6));//12 console.log(Math.round(12.6));//13 console.log(Math.ceil(-12.6));//-12 console.log(Math.floor(-12.6));//-13 console.log(Math.round(-12.6));//-13 随机数 【Math.random()】该方法返回大于等于0小于1的一个随机数 console.log(Math.random());//0.590752829178167 套用下面的公式可以利用Math.random()从某个整数范围内随机选择一个值 值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) //返回一个1-10之间的整数值 var num = Math.floor(Math.random() * 10 + 1) //从数组中随机取出一项 var colors = [1,2,3,4,5,6]; var color = colors[Math.floor(Math.random()*colors.length)]; 绝对值 【Math.abs()】该方法返回任意数值的绝对值 console.log(Math.abs(-1));//1 console.log(Math.abs('1px'));//NaN console.log(Math.abs(1,2,3));//1 三角函数 Math对象共有7个涉及到三角函数的函数，分别是正弦、余弦、正切、反正弦、反余弦、反正切及y/x的反正切值 【Math.sin(x)】返回x的正弦值，返回值介于-1到1之间 【Math.cos(x)】返回x的余弦值，返回值介于-1到1之间 【Math.tan(x)】返回x的正切值[注意]x是一个以弧度制度量的角度，如果想将角度制转为弧度制，可以将角度制的值乘以0.017(2派/360) 【Math.asin(x)】返回x的反正弦值，返回值介于-派/2到派/2弧度之间(x必须是-1到1之间的数) 【Math.acos(x)】返回x的反余弦值，返回值介于0到派弧度之间(x必须是-1到1之间的数) 【Math.atan(x)】返回x的反正切值，返回值介于-派/2到派/2弧度之间 【Math.atan2(y,x)】返回y/x的反正切值，返回值介于-派到派可以将y看做一个点的y坐标，x看做点的x坐标[注意]y坐标在x坐标前面 console.log(Math.sin(30*Math.PI/180));//0.49999999999999994 console.log(Math.cos(60*Math.PI/180));//0.5000000000000001 console.log(Math.tan(45*Math.PI/180));//0.9999999999999999 console.log(Math.asin(1)*180/Math.PI);//90 console.log(Math.acos(1)*180/Math.PI);//0 console.log(Math.atan(1)*180/Math.PI);//45 console.log(Math.atan2(1,1)*180/Math.PI);//45 乘方开方 Math对象涉及到乘方开方的函数共有4个 【Math.exp(num)】返回Math.E的num次幂 console.log(Math.exp(0));//1 console.log(Math.exp(1));//2.718281828459045 【Math.log(num)】返回num的自然对数，logenum(num必须是大于等于0的数) log10x = 1og10e * logex log2x = log2e * logex function log10(x){ return Math.LOG10E * Math.log(x); } function log2(x){ return Math.LOG2E * Math.log(X); } console.log(Math.log(1));//0 console.log(Math.log(Math.E));//1 【Math.sqrt(num)】返回num的平方根(x必须是大于等于0的数) console.log(Math.sqrt(100));//10 console.log(Math.sqrt(1));//1 【Math.pow(num,power)】返回num的power次幂 console.log(Math.pow(10,2));//100 console.log(Math.pow(100,1/2));//10 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:01:11 "},"JavaScript数据类型String字符串类型.html":{"url":"JavaScript数据类型String字符串类型.html","title":"JavaScript数据类型 String字符串类型","keywords":"","body":"前言 javascript没有表示单个字符的字符型，只有字符串String类型，字符型相当于仅包含一个字符的字符串 字符串String是javascript基本数据类型，同时javascript也支持String对象，它是一个原始值的包装对象。在需要时，javascript会自动在原始形式和对象形式之间转换。本文将介绍字符串String原始类型及String包装对象 定义 字符串String类型是由引号括起来的一组由16位Unicode字符组成的字符序列 字符串类型常被用于表示文本数据，此时字符串中的每个元素都被视为一个代码点。每个元素都被认为占有此序列中的一个位置，用非负数值索引这些位置。首字符从位置0开始，第二个字符在位置1，依次类推 字符串的长度即其中元素的个数。空字符串长度为零，因而不包含任何元素 Unicode编码 javascript采用UTF-16编码的Unicode字符集，javascript字符串是由一组无符号的16位值组成的序列。最常用的Unicode字符都是通过16位的内码表示，并代表字符串中的单个字符 [注意]最常用的Unicode字符属于“基本多语种平面”(Basic Multilingual Plane BMP)，也称为“零断面”(plan 0)， 是Unicode中的一个编码区段，编码介于U+0000——U+FFFF之间 所有字符都可以写成'\\uxxxx'的形式，其中xxxx代表该字符的Unicode编码。比如，\\u00A9代表版权符号 var s = '\\u00A9'; s // \"©\" 那些不能表示为16位的Unicode字符(U+10000到U+10FFFF之间的字符，长度为32位(即4个字节)，而且前两个字节在0xD800到0xDBFF之间，后两个字节在0xDC00到0xDFFF之间)，则遵循UTF-16编码规则——用两个16位值组成的一个序列(亦称做“代理项对”)表示。这意味着一个长度为2的javascript字符串(两个16位值)有可能表示一个Unicode字符 举例来说，U+1D306对应的字符\"𝌆\"，写成UTF-16就是0xD834 0xDF06。浏览器会正确将这四个字节识别为一个字符，但是javascript内部的字符长度总是固定为16位，会把这四个字节视为两个字符 var s = '\\uD834\\uDF06'; s // \"𝌆\" s.length // 2 引号 字符串String是由双引号(\")或单引号(')声明的。而Java则是用双引号声明字符串，用单引号声明字符。由于ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种，但左右引号必须匹配 //正确 var sColor1 = \"red\"; var sColor2 = 'red'; //错误 var sColor1 = \"red'; var sColor2 = 'red\"; 由单引号定界的字符串中可以包含双引号，由双引号定界的字符串也可以包含单引号 'key = \"value\"' \"It's a long journey\" javascript代码可能会夹杂HTML代码的字符串，HTML代码也会夹杂javascript代码。因此，最好在javascript和HTML代码中各自使用独自的引号风格 javascript中使用单引号表示字符串，在HTML事件处理程序中使用双引号表示字符串 click me 反斜线 如果想在单引号定界的字符串中使用单引号，或在双引号定界的字符串中使用双引号，则需要使用反斜线() 常见情况是英文缩写和所有格写法的撇号和单引号是同一个字符，所以这时必须使用反斜线()来转义撇号 'Wouldn\\'t you prefer this book?' //\"Wouldn't you prefer this book?\" 'Did she say \\'Hello\\'?' //\"Did she say 'Hello'?\" \"Did she say \\\"Hello\\\"?\" //\"Did she say \"Hello\"?\" 【多行字符】字符串默认只能写在一行内，分成多行将会报错 //报错 Uncaught SyntaxError: Invalid or unexpected token 'a b c'; 在ECMAScript3中，字符串必须写在一行中 在ECMAScript5中，字符串可以拆分成数行，每行必须以反斜线()结束 如果希望在字符串直接量中另起一行，可以使用转义字符\\n //\"onelongline\" 'one\\ long\\ line' /*\"two lines\"*/ 'two\\nlines' 【转义字符】在javascript字符串，反斜线()有着特殊的用途，反斜线符号后加一个字符，就不表示它们的字面含义，用来表示一些特殊字符，称为转义字符 \\0 空字节 \\n 换行 \\t 制表 \\b 空格 \\r 回车 \\f 进纸 \\\\ 斜杠 \\' 单引号 \\\" 双引号 \\xnn 以十六进制nn表示一个字符(n为0-f)，如\\x41表示'A' \\unnnn 以十六进制nnnn表示一个Unicode字符(n为0-f)，如\\u03a3表示希腊字符ε 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略 '\\a' // \"a\" 如果字符串需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义 \"Prev \\\\ Next\" // \"Prev \\ Next\" 特点 javascript中的字符串是不可变的。一旦字符串被创建，就永远无法改变它。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量 可以通过+运算符连接其他字符串来创建一个新字符串 var lang = \"java\"; lang = lang + \"script\"; //'javascript' 以上代码的实际过程是：首先创建一个能够容纳10个字符的新字符串，然后在这个字符串中填充'java'和'script'，最后一步是销毁原来的字符串'java'和'script'，因为这两个字符串已经没用了 这个过程在后台发生，也是在某些旧版本浏览器(IE6)拼接字符串速度慢的原因，但浏览器后面版本已经解决了这个低效率问题 转字符串 把一个值转换为字符串有两种方式，toString()和String() [注意]可以使用空字符串\"\" + 某个值，将该值转换为字符串 【toString()】第一种是使用几乎每个值都有的toString()方法，这个方法返回相应值的字符串表现 [注意]undefined和null没有该方法 undefined.toString();//错误 null.toString();//错误 true.toString();//'true' false.toString();//'false' 'abc'.toString();//'abc' 1.23.toString();//'1.23' ({}).toString();//[object Object] [1,2,3,4].toString();//'1,2,3,4' (new Date()).toString();//\"Sun Jun 05 2016 10:04:53 GMT+0800 (中国标准时间)\" /ab/i.toString();//'/ab/i' 【String()】在不知道要转换的值是不是undefined或null时，可以使用转型函数String() 转型函数String()遵循下列规则： 【1】如果值是null，则返回'null'；如果值是undefined，则返回'undefined' 【2】如果值不是null或undefined，则调用toString()方法并返回原始类型值 【3】若使用toString()方法返回的是对象，则再调用valueOf()方法返回原始类型值，若使用valueOf()方法返回的是对象，会报错 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:02:58 "},"JavaScript数据类型String字符串类型的属性和方法.html":{"url":"JavaScript数据类型String字符串类型的属性和方法.html","title":"JavaScript数据类型 String字符串类型的属性和方法","keywords":"","body":"属性 字符串String类型的每个实例都有一个length属性，表示字符串中的字符个数。由于字符串是不可变的，所以字符串的长度也不可变 字符串的length属性不会在for/in循环中枚举，也不能通过delete操作符删除 [注意]对于字符串s来说，最后一个字符的索引是s.length - 1 var str = \"test\"; console.log(str.length);//4 str.length = 6; console.log(str,str.length);//\"test\",4 实例方法 字符串String对象有多达20多个实例方法，包括toString()、toLocaleString()、valueOf()从Object对象继承的3种对象通用方法，chartAt()、中括号[]、charCodeAt()和fromCharCode()4种访问字符方法，concat()和加号+这2种字符串拼接方法，slice()、substr()和substring()3种创建子字符串方法，toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase()这4种大小写转换方法，indexOf()和lastIndexOf()这2种查找字符串位置的方法，match()、search()、replace()、split()这4种正则匹配方法以及去除首尾空格的trim()方法 对象通用方法 String类型是与字符串对应的包装类型，继承了Object对象的通用方法toString()、toLocaleString()、valueOf()这三个方法 【toString()】toString()方法返回string的原始字符串值 【toLocaleString()】toLocaleString()方法返回string的原始字符串值 【valueOf()】valueOf()方法返回string的原始字符串值 console.log(\"test\".valueOf());//\"test\" console.log(\"test\".toString());//\"test\" console.log(\"test\".toLocaleString());//\"test\" 访问字符方法 字符串的访问字符方法总共有chartAt()、中括号[]、charCodeAt()和fromCharCode()四种 【chartAt()】charAt()方法接收一个基于0的字符位置的参数，返回指定位置的字符。当参数为空或NaN时，默认参数为0；当参数超出范围时，则返回一个空字符串　 var str = \"hello\"; console.log(str.charAt(1));//e console.log(str.charAt(-1));//'' console.log(str.charAt(10));//'' console.log(str.charAt());//h console.log(str.charAt(NaN));//h charAt()方法涉及到Number()函数的隐式类型转换，如果转换为数值，则按照上述规则输出字符串；如果转换为NaN，则输出第0个字符 var str = \"hello\"; console.log(str.charAt(true));//'e' console.log(str.charAt(false));//'h' console.log(str.charAt('abc'));//'h' console.log(str.charAt({}));//'h' console.log(str.charAt([2]));//'l' 【中括号】 ECMAScript5定义了另一个访问字符的方法，使用方括号加数字索引来访问字符串中的特定字符。如果参数超出范围或是NaN时，则输出undefined；没有参数时，会报错；该方法没有Number()转型函数的隐式类型转换，但参数为单数值数组时可转换为数值 [注意]IE7-浏览器不支持 var str = \"hello\"; console.log(str[0]);//h console.log(str[[1]]);//e console.log(str[false]);//undefined console.log(str[-1]);//undefined console.log(str[NaN]);//undefined console.log(str[]);//报错 【charCodeAt()】charCodeAt()方法类似于charAt()方法，接收一个基于0的字符位置的参数，但返回的是指定位置的字符16位Unicode编码。返回值是一个16位的整数，在0-65535之间，即0x0000-0xffff之间 参数为空或NaN时，默认参数为0；当参数超出范围时，则返回NaN var str = \"hello\"; console.log(str.charCodeAt());//104 console.log(str.charCodeAt(0));//104 console.log(str.charCodeAt(1));//101 console.log(str.charCodeAt(-1));//NaN console.log(str.charCodeAt(10));//NaN console.log(str.charCodeAt(NaN));//104 同样地，charCodeAt()方法涉及到Number()函数的隐式类型转换，如果转换为数值，则按照上述规则输出相应值；如果转换为NaN，则输出第0个字符的字符编码 var str = \"hello\"; console.log(str.charCodeAt(true));//101 console.log(str.charCodeAt(false));//104 console.log(str.charCodeAt('abc'));//104 console.log(str.charCodeAt({}));//104 console.log(str.charCodeAt([2]));//l08 【fromCharCode()】String构造函数本身有一个静态方法:fromCharCode()。这个方法的任务是接收一个或多个字符编码，然后把它们转换成一个字符串。从本质上看，这个方法与实例方法charCodeAt()执行的是相反的操作。若参数为空或NaN时，则返回空字符串；若参数超出0-65535的范围，则输出字符不可控 console.log(String.fromCharCode(104,101,108,108,111));//'hello' console.log(String.fromCharCode());//'' console.log(String.fromCharCode(NaN));//'' console.log(String.fromCharCode(-1)); console.log(String.fromCharCode(65560)); 如果一个字符占用四字节，则需要拆成两个字符表示 console.log(String.fromCharCode(0xD842, 0xDFB7)); // \"𠮷\" 字符串拼接 关于字符串拼接共有concat()和加号+两种方法 【concat()】concat()方法用于将一个或多个字符串拼接起来，返回拼接得到的新字符串，而原字符串不发生改变。若参数(第一个参数除外)不是字符串，则通过String()方法隐式转换为字符串，再进行字符串拼接 var stringValue = 'hello '; var result = stringValue.concat('world','!'); console.log(result);//'hello world!' console.log(stringValue);//'hello' [注意]第一个参数只能是字符串，如果是其他类型(数组除外)则报错 (1).concat('2');//报错 (true).concat('false');//报错 ({}).concat('abc');//报错 [注意]由于数组也存在concat()方法，参数会按照首先出现的参数是数组还是字符串来决定如何转换 '1,2,3,'.concat([4,5]);//'1,2,3,4,5' [1,2,3].concat(',4,5');//[1, 2, 3, \",4,5\"] 【加号运算符(+)】虽然concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号运算符(+)。使用加号运算符在许多时候都比concat()简单方便 var stringValue = 'hello '; console.log(stringValue.concat('world','!'));//'hello world!' console.log(stringValue + 'world' + '!');//'hello world!' [注意]当操作数其中一个是字符串，或者对象转换为字符串时，才进行字符串拼接 1 + 2;//3 '1' + 2;//'12' var o = {valueOf:function(){return '1';}}; o + 2;//'12' var o = {valueOf:function(){return 1;}}; o + 2;//3 创建子字符串 创建子字符串共有slice()、substr()和substring()三种方法 【slice()】slice(start,end)方法需要两个参数start和end，返回这个字符串中从start位置的字符到(但不包含)end位置的字符的一个子字符串；如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符 如果start是负数，则start = max(length + start,0) 如果end是负数，则end = max(length + end,0) start和end无法交换位置 var stringValue = 'hello world'; console.log(stringValue.slice());//'hello world' console.log(stringValue.slice(0, 2));//'he' console.log(stringValue.slice(0, -2));//'hello wor' console.log(stringValue.slice(2));//'llo world' console.log(stringValue.slice(-2));//'ld' console.log(stringValue.slice(2,undefined));//'llo world' console.log(stringValue.slice(2,-5));//'llo ' console.log(stringValue.slice(2,-20));//'' console.log(stringValue.slice(20));//'' console.log(stringValue.slice(-2,2));//'' console.log(stringValue.slice(-2,-20));//'' console.log(stringValue.slice(-2,20));//'ld' console.log(stringValue.slice(-20,2));//'he' console.log(stringValue.slice(-20,-2));//'hello wor' slice()方法涉及到Number()转型函数的隐式类型转换，当start被转换为NaN时，相当于start = 0；当end被转换为NaN时(end为undefined除外)，则输出空字符串 var stringValue = 'hello world'; console.log(stringValue.slice(NaN));//'hello world' console.log(stringValue.slice(0,NaN));//'' console.log(stringValue.slice(true,[3]));//'el' console.log(stringValue.slice(null,undefined));//'hello world' console.log(stringValue.slice({}));//'hello world' console.log(stringValue.slice('2',[5]));//'llo' 【substring()】substring(start,end)方法需要两个参数start和end，返回这个字符串中从start位置的字符到(但不包含)end位置的字符的一个子字符串；如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符 如果任一参数是NaN或负数，则被0取代 如果任一参数大于字符串长度，则被字符串长度取代 如果start 大于 end，则交换它们的值 var stringValue = 'hello world'; console.log(stringValue.substring());//'hello world' console.log(stringValue.substring(2));//'llo world' console.log(stringValue.substring(2,undefined));//'llo world' console.log(stringValue.substring(20));//'' console.log(stringValue.substring(-2,2));//'he' console.log(stringValue.substring(NaN,2));//'he' console.log(stringValue.substring(-2,20));//'hello world' console.log(stringValue.substring(3,2));//'l' console.log(stringValue.substring(3,NaN));//'hel' console.log(stringValue.substring(-20,2));//'he' console.log(stringValue.substring(-20,-2));//'' 同样地，substring()方法也涉及到Number()转型函数的隐式类型转换 var stringValue = 'hello world'; console.log(stringValue.substring(true,[3]));//'el' console.log(stringValue.substring(null,undefined));//'hello world' console.log(stringValue.substring({}));//'hello world' console.log(stringValue.substring('2',[5]));//'llo' 【substr()】substr(start,end)方法需要两个参数start和end，end代表返回的子字符串的字符个数；该方法返回这个字符串中从start位置的字符开始的end个字符的一个子字符串；如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符 如果start是负数，则start = max(length + start,0) 如果start是NaN，则相当于start = 0 如果end是负数或NaN，则end = 0，因此会返回空字符串 start和end无法交换位置 [注意]该方法不是ECMAScript标准，已经被弃用 [注意]IE8-浏览器在处理向substr()传递负值的情况时存在问题，它会返回原始的字符串 大小写转换 ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()、toLocaleUpperCase() toLowerCase()和toUpperCase()是两个经典的方法，借鉴自java.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现，对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言(如土耳其语)会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换 【toUpperCase()】toUpperCase()方法将字符串转换成大写 【toLowerCase()】toLowerCase()方法将字符串转换成小写 【toLocaleUpperCase()】toLocaleUpperCase()方法将字符串转换成大写(针对地区) 【toLocaleLowerCase()】toLocaleLowerCase()方法将字符串转换成小写(针对地区) [注意]在不知道自己的代码将在哪个语言环境中运行的情况下，使用针对地区的方法更稳妥 var string = 'Hello World'; console.log(string.toLowerCase());//hello world console.log(string.toLocaleLowerCase());//hello world console.log(string.toUpperCase());//HELLO WORLD console.log(string.toLocaleUpperCase());//HELLO WORLD 这4种方法均不支持String()隐式类型转换，只支持字符串类型 (true).toLowerCase();//报错 (2).toLocaleLowerCase();//报错 ({}).toUpperCase();//报错 ([]).toLocaleUpperCase();//报错 [注意]大小写转换方法可以连续使用 var string = 'Hello World'; console.log((string.toUpperCase()).toLowerCase());//hello world 将带有分割符的字符串转换为驼峰的形式 var txt = \"border-top-left\"; var arr = txt.split('-'); for(var i = 1; i 查找子串位置 有两个从字符串中查找子字符串位置的方法：indexOf()和lastIndexOf()。查找子串位置的方法同访问字符方法charAt()和中括号[]方法有相反的地方，一个通过字符串查找位置，一个则是通过位置查找字符 【indexOf()】indexOf(searchString,start)方法接收searchString和start两个参数，返回searchString首次出现的位置，如果没有找到则返回-1 该方法会隐式调用String()转型函数，将searchString非字符串值转换为字符串；隐式调用Number()转型函数，将start非数字值(undefined除外)转换为数值 searchString表示要搜索的子字符串；start表示该搜索的开始位置，若忽略该参数或该参数为undefined、NaN或负数时，start = 0 var string = 'hello world world'; console.log(string.indexOf('ld'));//9 console.log(string.indexOf('ld',undefined));//9 console.log(string.indexOf('ld',NaN));//9 console.log(string.indexOf('ld',-1));//9 console.log(string.indexOf('ld',10));//15 console.log(string.indexOf('ld',[10]));//15 console.log(string.indexOf('true',[10]));//-1 console.log(string.indexOf(false,[10]));//-1 【lastIndexOf()】与indexOf()不同，lastIndexOf()从右向左查找 lastIndexOf(searchString,start)方法接收searchString和start两个参数，返回searchString第一次出现的位置，如果没有找到则返回-1 同样地，该方法会隐式调用String()转型函数，将searchString非字符串值转换为字符串；隐式调用Number()转型函数，将start非数字值(undefined除外)转换为数值 searchString表示要搜索的子字符串；start表示该搜索的开始位置，若忽略该参数或该参数为undefined、NaN时，start = length - 1；若start为负数，start = 0 var string = 'hello world world'; console.log(string.lastIndexOf('ld'));//15 console.log(string.lastIndexOf('ld',undefined));//15 console.log(string.lastIndexOf('ld',NaN));//15 console.log(string.lastIndexOf('ld',-1));//-1 console.log(string.lastIndexOf('h',-1));//0 console.log(string.lastIndexOf('w',undefined));//12 console.log(string.lastIndexOf('ld',10));//9 console.log(string.lastIndexOf('ld',[10]));//9 console.log(string.lastIndexOf('true',[10]));//-1 console.log(string.lastIndexOf(false,[10]));//-1 可以通过循环调用indexOf()或lastIndexOf()来找到所有匹配的子字符串 function allIndexOf(str,value){ var result = []; var pos = str.indexOf(value); while(pos > -1){ result.push(pos); pos = str.indexOf(value,pos+value.length); } return result; } console.log(allIndexOf('helllhelllhelll','ll'));//[2,7,12] lastIndexOf()方法常用于获取URL地址中的扩展名 var url = \"http://cnblogs.com/xiaohuochai.txt\"; function getFileFormat(url){ var pos = url.lastIndexOf('.'); return url.slice(pos+1); } console.log(getFileFormat(url));//'txt' 正则匹配方法 javascript中的一些正则操作如查找和测试等可以通过RegExp的方法实现，而切分和替换等另一些操作可以通过String类的方法实现 String类共有match()、search()、replace()、split()这4种正则匹配方法 【match()】match()方法只接受一个为正则或字符串的参数，并以数组的形式返回匹配的内容。这个方法类似于正则表达式RegExp的exec()方法，只是调换了RegExp和String对象的位置 若匹配失败，则match()方法返回null 'x'.match(/y/);//null 【1】若不设置全局标志，match()方法和exec()方法结果相同 var string = 'cat,bat,sat,fat'; var pattern = /.at/; var matches = string.match(pattern); console.log(matches,matches.index,matches.input);//['cat'] 0 'cat,bat,sat,fat' var string = 'cat,bat,sat,fat'; var pattern = /.at/; var exec = pattern.exec(string); console.log(exec,exec.index,exec.input);//['cat'] 0 'cat,bat,sat,fat' 【2】设置全局标志后，exec()方法依然返回单次的匹配结果，而match()方法会返回一个字符串数组，其中包括各次成功匹配的文本，但没有index和input属性 var string = 'cat,bat,sat,fat'; var pattern = /.at/g; var matches = string.match(pattern); console.log(matches,matches.index,matches.input);//[\"cat\", \"bat\", \"sat\", \"fat\"] undefined undefined var string = 'cat,bat,sat,fat'; var pattern = /.at/g; var exec = pattern.exec(string); console.log(exec,exec.index,exec.input);//['cat'] 0 'cat,bat,sat,fat' var exec = pattern.exec(string); console.log(exec,exec.index,exec.input);//['bat'] 4 'cat,bat,sat,fat' 【3】match()方法作为字符串String的方法，接受参数为字符串，结果与不设置全局标志的正则表达式为参数相同，只返回第一个匹配项，且具有index和input属性 var string = 'cat,bat,sat,fat'; var matches = string.match('at'); console.log(matches,matches.index,matches.input);//['at'] 1 'cat,bat,sat,fat' var matches = string.match('at'); console.log(matches,matches.index,matches.input);//['at'] 1 'cat,bat,sat,fat' 当不设置全局标志时，match()方法和exec()方法都包含捕获分组的信息；设置全局标志后，match()方法不包含捕获分组的信息 var string = 'cat,bat,sat,fat'; var pattern = /(.)at/g; var matches = string.match(pattern); console.log(matches);//['cat', 'bat', 'sat', 'fat'] var exec = pattern.exec(string); console.log(exec);//['cat','c'] var string = 'cat,bat,sat,fat'; var pattern = /(.)at/; var matches = string.match(pattern); console.log(matches);//['cat','c'] var exec = pattern.exec(string); console.log(exec);//['cat','c'] 【tips】两种方法找出字符串中所有的数字 【1】用charAt()方法 var str1 = 'j1h342jg24g234j 3g24j1'; var array = []; var temp = ''; for(var i = 0; i 【2】用match()方法 var str1 = 'j1h342jg24g234j 3g24j1'; array = str1.match(/\\d+/g); console.log(array);//[\"1\", \"342\", \"24\", \"234\", \"3\", \"24\", \"1\"] 【search()】search()方法接受一个正则或字符串的参数，返回匹配的内容在字符串中首次出现的位置，类似于不能设置起始位置的indexOf，找不到返回-1 [注意]search()方法不执行全局匹配，忽略全局标志g，也会忽略RegExp对象的lastIndex属性，总是从字符串的开始位置开始搜索 'x'.search(/y/);//-1 var string = 'cat,bat,sat,fat'; var pattern = /.at/; var pos = string.search(pattern); console.log(pos);//0 var string = 'cat,bat,sat,fat'; var pattern = /.at/g; var pos = string.search(pattern); console.log(pos);//0 var string = 'cat,bat,sat,fat'; var pattern = 'at'; var pos = string.search(pattern); console.log(pos);//1 【replace()】replace()方法用于替换一个或多个子字符串。它接收两个参数：第一个是正则表达式或字符串，表示待查找的内容；第二个是字符串或函数，表示替换内容。返回替换后的字符串 【1】字符串替换，只能替换第一个子字符串 var string = 'cat,bat,sat,fat'; var result = string.replace('at','ond'); console.log(result);//'cond,bat,sat,fat' 【2】不设置全局标志g，也只能替换第一个子字符串 var string = 'cat,bat,sat,fat'; var result = string.replace(/at/,'ond'); console.log(result);//'cond,bat,sat,fat' 【3】设置全局标志g，替换所有匹配的子字符串 var string = 'cat,bat,sat,fat'; var result = string.replace(/at/g,'ond'); console.log(result);//'cond,bond,sond,fond' 与match()和seartch()方法相比，replace()方法更为强大，它可以在第二个参数中通过短属性名来使用某些正则表达式的静态属性 短属性名 说明 $& 最近一次的匹配项 $` 匹配项之前的文本 $' 匹配项之后的文本 $1,$2... 表示第N个匹配捕获组 var string = 'cat-bat-sat-fat'; console.log(string.replace(/(.)(at)/g,'$&'));//'cat-bat-sat-fat' console.log(string.replace(/(.)(at)/g,'$`'));//'-cat--cat-bat--cat-bat-sat-' console.log(string.replace(/(.)(at)/g,\"$'\"));//'-bat-sat-fat--sat-fat--fat-' console.log(string.replace(/(.)(at)/g,'$1'));//'c-b-s-f' console.log(string.replace(/(.)(at)/g,'$2'));//'at-at-at-at' var string = '2016-06-24'; console.log(string.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g,'$2/$3/$1'));//'06/24/2016' replace()方法的第二个参数可以是函数，这样文本的处理更加灵活 如果在只有一个匹配项的情况下，该方法会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置、原始字符串 var string = 'cat,bat,sat,fat'; var index = 0; var matchArray = []; var posArray = []; var text = ''; var result = string.replace(/at/g,function(match,pos,originalText){ matchArray.push(match); posArray.push(pos); text = originalText; index++; if(index % 2){ return 'wow'; }else{ return '0'; } }); console.log(matchArray);//[\"at\", \"at\", \"at\", \"at\"] console.log(posArray);//[1, 5, 9, 13] console.log(text);//'cat,bat,sat,fat' console.log(result);//'cwow,b0,swow,f0' 如果正则表达式定义多个捕获组，则该方法传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……第N个捕获组的匹配项，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串，这个函数返回一个字符串 var string = 'cat,bat,sat,fat'; var index = 0; var matchArray = []; var m1Array = []; var posArray = []; var text = ''; var result = string.replace(/(.)at/g,function(match,m1,pos,originalText){ matchArray.push(match); m1Array.push(m1); posArray.push(pos); text = originalText; return m1 + 'ta'; }); console.log(matchArray);//[\"cat\", \"bat\", \"sat\", \"fat\"] console.log(m1Array);//['c','b','s','f'] console.log(posArray);//[1, 5, 9, 13] console.log(text);//'cat,bat,sat,fat' console.log(result);//'cta,bta,sta,fta' 首字母大写 var text = 'one two three'; var result = text.replace(/\\b(\\w+)\\b/g,function(match,m1,pos,originalText){ return m1.charAt(0).toUpperCase()+m1.substring(1); }) console.log(result); HTML标签转义 function htmlEscape(text){ return text.replace(/[<>\"&]/g,function(match,pos,originalText){ switch(match){ case '': return '&'; case '&': return '&amp;'; case '\\\"': return '\"'; } }); } console.log(htmlEscape('Hello world!')); //Hello world!')); //同上 日期格式化 var array = ['2015.7.28','2015-7-28','2015/7/28','2015.7-28','2015-7.28','2015/7---28']; function formatDate(date){ return date.replace(/(\\d+)\\D+(\\d+)\\D+(\\d+)/,'$1年$2月$3日') } var result = []; for(var i = 0 ; i 找出重复项最多的字符和个数 var str = 'aaaaabbbbbdddddaaaaaaaffffffffffffffffffgggggcccccce'; var pattern = /(\\w)\\1+/g; var maxLength = 0; var maxValue = ''; var result = str.replace(pattern,function(match,match1,pos,originalText){ if(match.length > maxLength){ maxLength = match.length; maxValue = match1; } }) console.log(maxLength,maxValue);//18 \"f\" 【split()】split()方法基于指定的分隔符将一个字符串分割成多个字符串，并将结果放在一个数组中，分隔符可以是字符串，也可以是一个RegExp 该方法可以接受第二个参数(可选)用于指定数组的大小，如果第二个参数为0-array.length范围内的值时按照指定参数输出，其他情况将所有结果都输出 若指定分隔符没有出现在字符串中，则以数组的形式返回原字符串的值 [注意]参数中的正则表达式是否使用全局标志g对结果没有影响 var colorText = 'red,blue,green,yellow'; console.log(colorText.split(''));//[\"r\", \"e\", \"d\", \",\", \"b\", \"l\", \"u\", \"e\", \",\", \"g\", \"r\", \"e\", \"e\", \"n\", \",\", \"y\", \"e\", \"l\", \"l\", \"o\", \"w\"] console.log(colorText.split(','));//[\"red\", \"blue\", \"green\", \"yellow\"] console.log(colorText.split(',',2));//[\"red\", \"blue\"] console.log(colorText.split(',',6));//[\"red\", \"blue\", \"green\", \"yellow\"] console.log(colorText.split('-'));//[\"red,blue,green,yellow\"] console.log(colorText.split(/\\,/));//[\"red\", \"blue\", \"green\", \"yellow\"] console.log(colorText.split(/e/));//[\"r\", \"d,blu\", \",gr\", \"\", \"n,y\", \"llow\"] console.log(colorText.split(/[^\\,]+/));//将除去逗号以外的字符串变为分隔符[\"\", \",\", \",\", \",\", \"\"],IE8-会识别为[\",\",\",\",\",\"] 去除首尾空格 【trim()】ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空白字符，然后返回结果 由于trim()方法返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变 var string = ' hello world '; console.log(string.trim());//'hello world' console.log(string);//' hello world ' 空白字符不仅仅包括空格，还包括制表符(\\t)、换行符(\\n)和回车符(\\r) var string = ' hello world '; console.log(string.trimRight());//' hello world'; 用正则表达式模拟trim() function fnTrim(str){ return str.replace(/^\\s+|\\s+$/,'') } console.log(fnTrim(' hello world '));//'hello world' Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:06:31 "},"void0与undefined.html":{"url":"void0与undefined.html","title":"(void 0) 与 undefined","keywords":"","body":"前言 underscore 源码没有出现 undefined（注意，其实有出现一处，是为 \"undefined\"，而不是 undefined），而用 void 0 代替之。为什么要这么做？ 为什么不直接用undefined undefined在JavaScript中并不属于保留字/关键字，因此在IE5.5~8中我们可以将其当作变量那样对其赋值（IE9+及其他现代浏览器中赋值给undefined将无效） var undefinedBackup = undefined; undefined = 1; // 显示\"undefined\" console.log(typeof undefinedBackup); // 在IE5.5~8中显示\"number\"，其他浏览器中则显示\"undefined\" console.log(typeof undefined); 于是采用void方式获取undefined则成了通用准则。 一元运算符void的作用 void的行为特点为： 不管void后的运算数是什么，只管返回纯正的undefined； void会对其后的运算数作取值操作，因此若属性有个getter函数，那么就会调用getter函数（因此会产生副作用） var article = { _view: 0, get view(){ console.log(this._view); return this._view++; } }; var test = void article.view; // 显示0 console.log(test); // 显示undefined console.log(article._view); // 显示1 还有啥方式可以得到纯正的undefined？ 除了通过一元运算符void获取纯正的undefined，其实我们还有如下方法来获取： 未赋值的变量 var myUndefined; console.log(typeof myUndefined); // 显示\"undefined\" 无返回值函数 var getUndefined = function(){}; 未定义的属性 var myUndefined1 = {}['']; var myUndefined2 = [][0]; Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:07:15 "},"数组.html":{"url":"数组.html","title":"数组","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:07:27 "},"JavaScript数据类型检测数组Array检测方式.html":{"url":"JavaScript数据类型检测数组Array检测方式.html","title":"JavaScript数据类型检测 数组(Array)检测方式","keywords":"","body":"前言 对于确定某个对象是不是数组，一直是数组的一个经典问题。本文专门将该问题择出来，介绍什么才是正确的javascript数组检测方式 typeof 首先，使用最常用的类型检测工具——typeof运算符 var arr = [1,2,3]; console.log(typeof arr);//'object' 数组的本质是一种特殊的对象，所以返回'object'。typeof运算符只能用来区分原始类型和对象类型，对于更具体的对象类型是无法鉴别出来的 instanceof instanceof运算符用来判断一个对象是否是特定构造函数的实例 var arr = [1,2,3]; console.log(arr instanceof Array);//true var str = '123'; console.log(str instanceof Array);//false 看上去很实用。但，这时就引出了数组检测的经典场景——网页中包含多个框架 【1】先创建一个父网页box.html和子网页in.html，其中父网页通过iframe包含子网页 //子网页为空 //父网页 【2】测试父网页和子网页的通信，注意一定要在服务器环境下测试 //子网页 var arr = [1,2,3]; //父网页 window.onload = function(){ console.log(child.window.arr);// [1,2,3] } 【3】测试成功，这时进行数组检测 //子网页 var arr = [1,2,3]; //父网页 function test(arr){ return arr instanceof Array; } window.onload = function(){ console.log(child.window.arr);// [1,2,3] console.log(test(child.window.arr));//false } 测试后发现，数组检测的结果是false。这是因为网页中包含多个框架，那实际上就存在多个不同的全局环境，从而存在不同版本的Array构造函数。如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数 toString typeof操作符在这里帮不上忙，而instanceof操作符只能用于简单的情形，这时就需要祭出大杀器——toString()，通过引用Object的toString()方法来检查对象的类属性，对数组而言该属性的值总是\"Array\" var arr = [1,2,3]; console.log(Object.prototype.toString.call(arr) === '[object Array]');//true 或者 function type(obj){ return Object.prototype.toString.call(obj).slice(8,-1).toLowerCase(); } var arr = [1,2,3]; console.log(type(arr));//'array' 在多框架环境中测试，同样返回'array' //子网页 var arr = [1,2,3]; //父网页 function test(arr){ return arr instanceof Array; } function type(obj){ return Object.prototype.toString.call(obj).slice(8,-1).toLowerCase(); } window.onload = function(){ console.log(child.window.arr);// [1,2,3] console.log(test(child.window.arr));//false console.log(type(child.window.arr));//'array' } isArray 为了让数组检测更方便，ECMAScript5新增了Array.isArray()方法。该方法的目的是最终确定某个值到底是不是数组，而不管它在哪个全局环境中创建的 var arr = [1,2,3]; console.log(Array.isArray([]));//true console.log(Array.isArray({}));//false console.log(Array.isArray(arr));//true [注意]在多框架环境中测试，同样返回true Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:08:56 "},"判断两个数组是否相等的方法.html":{"url":"判断两个数组是否相等的方法.html","title":"判断两个数组是否相等的方法","keywords":"","body":"前言 今天做项目碰到一个问题，需要判断两个这样string[]格式的数组是否相等。特此记录下 思考 判断的两个数组的格式： const arr1 = ['a','b','c'] const arr2 = ['b','a','c'] 要判断这两个数组是否相等。首先我们肯定是先排序 const arr1 = ['a','b','c'].sort(); // ['a','b','c'] const arr2 = ['b','a','c'].sort(); // ['a','b','c'] 直接判断 arr1 === arr2 吗，这样是不行的，arr1和arr2只是数组内存地址的引用，各自的地址肯定不一样的，所以一定不行的 [注意] 变量通常保存对象，都是保存的内存指针 我们仔细想想，JavaScript中我们通常回去判断 字符串是否相当，数值是否相当。同理我们把数组转换成字符串不就可以了吗。 实现 const v1 = JSON.stringify(['a','b','c'].sort()); // '['a','b','c']' const v2 = JSON.stringify(['b','a','c'].sort()); // '['a','b','c']' v1 === v2 就是true了 方法实现: import { uniq } from \"lodash\"; export const toEqualArr = (...arg) => { return ( uniq( arg.map(item => { return JSON.stringify(item.sort()); }) ).length 其实配合lodash的flatten也可以实现相同的效果，这里就不写了... Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-14 08:15:14 "},"Date.html":{"url":"Date.html","title":"Date","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:09:48 "},"JavaScript日期和时间基础知识.html":{"url":"JavaScript日期和时间基础知识.html","title":"JavaScript 日期和时间基础知识","keywords":"","body":"前言 学习Date对象之前，首先要先了解关于日期和时间的一些知识。比如，闰年、UTC等等。深入了解这些，有助于更好地理解javascript中的Date对象。 标准时间 一般而言的标准时间是指GMT和UTC，以前是GMT，现在是UTC 【GMT】格林尼治标准时间(GMT)是指位于伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线 理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时(也就是在格林尼治上空最高点时)的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能和实际的太阳时相差16分钟 地球每天的自转是有些不规则的，而且正在缓慢减速。所以，格林尼治时间已经不再被作为标准时间使用。现在的标准时间由世界协调时间(UTC)提供 【UTC】世界协调时间(UTC)又称世界统一时间，世界标准时间，国际协调时间，全称Coordinated Universal Time，是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统 这套时间系统被应用于许多互联网和万维网的标准中，中国大陆、中国香港、中国澳门、中国台湾、蒙古国、新加坡、马来西亚、菲律宾、西澳大利亚州的时间与UTC的时差均为+8，也就是UTC+8 在军事中，协调世界时区会使用“Z”来表示。又由于Z在无线电联络中使用“Zulu”作代称，协调世界时也会被称为\"Zulu time\" 日期时间字符串格式 ECMAScript定义了一个基于简化的ISO8601扩展格式的日期时间的字符串互换格式 日期时间完整格式为: YYYY-MM-DDTHH:mm:ss.sssZ [注意]前置0不能省略，否则在完整格式的情况下会报错 YYYY 公历中年的十进制数字，如果这个参数值在0-99之间，则向它加上1900 - 在字符串中直接以“-”(破折号)出现两次 MM 一年中的月份，从01(一月)到12(十二月) DD 月份中的日期，从01到31 T 在字符串中直接以“T”出现，用来表明时间元素的开始 HH 用两个十进制数字表示的，自午夜0点以来的小时数 : 在字符串中直接以“:”(冒号)出现两次 mm 是用两个十进制数字表示的，自小时开始以来的分钟数 ss 是用两个十进制数字表示的，自分开始以来的秒数 . 在字符串中直接以“.”(点)出现 sss 是用三个十进制数字表示的，自秒开始以来的毫秒数 Z 是时区偏移量，由（“Z”(指UTC)或“+”或“-”）和后面跟着的时间表达式hh:mm组成 [注意]所有数字必须是10进制的。如果缺少MM或DD字段，用“01”作为它们的值。如果缺少mm或ss字段，用“00”作为它们的值，对于缺少的sss用“000”作为它的值。对于缺少的时区偏移量用“Z” 闰年 年分为闰年和平年，平年有365天，闰年有366天，闰年的2月比平年多一天 闰年的定义是(可被4整除)且((不可被100整除)或(可被400整除))的年份 口诀是：四年一闰，百年不闰，四百年再闰 function IsLeapYear(year){ if(typeof year == 'number'){ if((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0){ return 'leap year' }else{ return 'common year' } } return 'please input number' } 月日 一年有12个月，其中4、6、9、11月每月有30天；如果是闰年，2月有29天，否则 ，2月有28天。1、3、5、7、8、10、12月每月有31天 在javascript中，月的计算从0开始，所以1-12月，分别用0-11来表示；而日的计算则从1开始，1就代表第1天，以此类推 if(month == 2){ //如果是闰年 if((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0){ days = 29; //如果是平年 }else{ days = 28; } //如果是第4、6、9、11月 }else if(month == 4 || month == 6 ||month == 9 ||month == 11){ days = 30; }else{ days = 31; } 在javascript中，月份的简写经常在日期字符串中使用 一月 Jan January 二月 Feb February 三月 Mar March 四月 Apr April 五月 May May 六月 Jun June 七月 Jul July 八月 Aug August 九月 Sep September 十月 Oct October 十一月 Nov November 十二月 Dec December 星期 星期是从星期日开始，到星期六结束，分别用0-6来表示 在javascript中，各星期的简写经常在日期字符串中使用 星期日 sunday Sun 星期一 monday Mon 星期二 Tuesday Tue 星期三 Wednesday Wed 星期四 Thursday Thu 星期五 Friday Fri 星期六 Saturday Sar 时分秒 1天 = 24小时 = 24*60(1440)分 = 24*60*60(86400)秒 = 86,400,000毫秒 1分= 60秒 1小时 = 3600秒 1天 = 86400秒 Date对象返回的是一个毫秒数，经常需要将其换算成时分秒的形式 date = 100000s day(天) = Math.floor(100000/86400) = 1 hour(小时) = Math.floor((100000%86400)/3600) = 3 minute(分) = Math.floor((100000%3600)/60) = 46 second(秒) = Math.floor(100000%60)=40 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:10:48 "},"JavaScriptDate日期对象以及日期格式化方法.html":{"url":"JavaScriptDate日期对象以及日期格式化方法.html","title":"JavaScript Date日期对象以及日期格式化方法","keywords":"","body":"前言 Date对象是javascript语言中内置的数据类型，用于提供日期和时间的操作接口。Date对象是在早期java中的java.util.Date类基础上创建的，为此，Date类型使用自UTC1970年1月1日0点开始经过的毫秒数来保存日期，它可以表示的时间范围是1970年1月1日0点前后的各1亿天。 静态方法 总共有3个静态方法：Date.now()、Date.parse()、Date.UTC() 【Date.now()】 ECMAScript5新增了now()方法，该方法返回当前时间距离1970年1月1日0点UTC的毫秒数。该方法不支持传递参数 Date.now() // 1554790104142 +new Date() // 会把时间隐式转换成时间戳 1554790169778 new Date().getTime() // 1554790104942 【Date.parse()】 该方法用于解析一个日期字符串，参数是一个包含待解析的日期和时间的字符串，返回从1970年1月1日0点到给定日期的毫秒数 该方法会根据日期时间字符串格式规则来解析字符串的格式，除了标准格式外，以下格式也支持。如果字符串无法识别，将返回NaN 1、'月/日/年' 如6/13/2004 2、'月 日,年' 如January 12,2004或Jan 12,2004 3、'星期 月 日 年 时:分:秒 时区' Tue May 25 2004 00:00:00 GMT-0700 Date.parse('4/9/2019') // 1554739200000 Date.parse('May 12,2019') // 1557590400000 Date.parse('Tue May 12 2019 00:00:00 GMT-0700') // 1557644400000 Date.parse('T00:00:00') // NaN Date.parse() // NaN [注意]在ECMAScript5中，如果使用标准的日期时间字符串格式规则的字符串中，数字前有前置0，则会解析为UTC时间，时间没有前置0，则会解析为本地时间。其他情况一般都会解析为本地时间 console.log(Date.parse('7/12/2016'));//1468252800000 console.log(Date.parse('2016-7-12'));//1468252800000 console.log(Date.parse('2016-07-12'));//1468281600000 【Date.UTC()】 Date.UTC()同样返回给定日期的毫秒数，但其参数并不是一个字符串，而是分别代表年、月、日、时、分、秒、毫秒的数字参数 console.log(Date.UTC(1970));//NaN console.log(Date.UTC(1970,0));//0 console.log(Date.UTC(1970,0,2));//86400000 console.log(Date.UTC(1970,0,1,1));//3600000 console.log(Date.UTC(1970,0,1,1,59));//714000 console.log(Date.UTC(1970,0,1,1,59,30));//717000 构造函数 Date()构造函数有多达5种的使用方法 【1】Date()函数可以不带new操作符，像一个函数一样调用。它将忽略所有传入的参数，并返回当前日期和时间的一个字符串表示 [注意]由于Date()函数没有使用操作符，实际上它不能被称为构造函数 console.log(Date());//Tue Apr 09 2019 15:57:50 GMT+0800 (中国标准时间) console.log(Date('2016/1/1'));//Tue Apr 09 2019 15:57:50 GMT+0800 (中国标准时间) console.log(typeof Date());//'string' 【2】Date()函数使用new操作符，且不带参数时，将根据当前时间和日期创建一个Date对象 console.log(new Date());//Tue Apr 09 2019 15:59:13 GMT+0800 (中国标准时间) console.log(new Date);//Tue Apr 09 2019 15:59:13 GMT+0800 (中国标准时间) console.log(typeof new Date());//'object' 【3】Date()函数可接受一个数字参数，该参数表示设定时间与1970年1月1日0点之间的毫秒数 console.log(new Date(0));//Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) console.log(new Date(86400000));//Fri Jan 02 1970 08:00:00 GMT+0800 (中国标准时间) console.log(typeof new Date(0));//object 【4】Date()函数可接受一个字符串参数，参数形式类似于Date.parse()方法。但parse()方法返回的是一个数字，而Date()函数返回的是一个对象 console.log(new Date('6/13/2004'));//Sun Jun 13 2004 00:00:00 GMT+0800 (中国标准时间) console.log(Date.parse('6/13/2004'));//1087056000000 console.log(typeof new Date(6/13/2004));//object console.log(typeof Date.parse(6/13/2004));//number 关于标准的日期时间字符串中前置0的处理，也类似于Date.parse()方法，若有前置0，则相当于UTC时间，若没有，则相当于本地时间。其余情况一般都为本地时间 console.log(new Date('7/12/2016'));//Tue Jul 12 2016 00:00:00 GMT+0800 (中国标准时间) console.log(new Date('2016-7-12'));//Tue Jul 12 2016 00:00:00 GMT+0800 (中国标准时间) console.log(new Date('2016-07-12'));//Tue Jul 12 2016 08:00:00 GMT+0800 (中国标准时间) 【5】Date()函数可接受参数形式类似于Date.UTC()方法的参数，但Date.UTC()方法返回是一个毫秒数，且是UTC时间，而Date()函数返回是一个对象，且是本地时间 console.log(new Date(2016,7,12));//Fri Aug 12 2016 00:00:00 GMT+0800 (中国标准时间) console.log(+new Date(2016,7,12));//1470931200000 console.log(typeof new Date(2016,7,12));//'object' console.log(Date.UTC(2016,7,12));//1470960000000 console.log(typeof Date.UTC(2016,7,12));//'number' [注意]使用参数类似于Date.parse()函数的方法时，如果日期对象超出范围，浏览器会自动将日期计算成范围内的值；使用参数类似于Date.UTC()函数的方法时，如果日期对象超出范围，浏览器会提示Invalid Date console.log(new Date(2016,7,32));//Thu Sep 01 2016 00:00:00 GMT+0800 (中国标准时间) console.log(new Date(2016,8,1));//Thu Sep 01 2016 00:00:00 GMT+0800 (中国标准时间) console.log(new Date('2016-8-32'));//Invalid Date console.log(new Date('2016-9-1'));//Thu Sep 01 2016 00:00:00 GMT+0800 (中国标准时间) 实例方法 Date对象没有可以直接读写的属性，所有对日期和时间的访问都需要通过方法。Date对象的大多数方法分为两种形式：一种是使用本地时间，一种是使用UTC时间，这些方法在下面一起列出。例如，get[UTC]Day()同时代表getDay()和getUTCDay() Date对象一共有46个实例方法，可以分为以下3类：to类、get类、set类 【to类】 to类方法从Date对象返回一个字符串，表示指定的时间 toString() 返回本地时区的日期字符串 toUTCString() 返回UTC时间的日期字符串 toISOString() 返回Date对象的标准的日期时间字符串格式的字符串 toDateString() 返回Date对象的日期部分的字符串 toTimeString() 返回Date对象的时间部分的字符串 toJSON() 返回一个符合JSON格式的日期字符串，与toISOString方法的返回结果完全相同 toLocaleString() toString()方法的本地化转换 toLocaleTimeString() toTimeString()方法的本地化转换 toLocaleDateString() toDateString()方法的本地化转换 console.log(new Date('2016-7-12').toString());//Tue Jul 12 2016 00:00:00 GMT+0800 (中国标准时间) console.log(new Date('2016-7-12').toUTCString());//Mon, 11 Jul 2016 16:00:00 GMT console.log(new Date('2016-7-12').toISOString());//2016-07-11T16:00:00.000Z console.log(new Date('2016-7-12').toDateString());//Tue Jul 12 2016 console.log(new Date('2016-7-12').toTimeString());//00:00:00 GMT+0800 (中国标准时间) console.log(new Date('2016-7-12').toJSON());//2016-07-11T16:00:00.000Z console.log(new Date('2016-7-12').toLocaleString());//2016/7/12 上午12:00:00 console.log(new Date('2016-7-12').toLocaleDateString());//2016/7/12 console.log(new Date('2016-7-12').toLocaleTimeString());//上午12:00:00 *【get类】Date对象提供了一系列get类方法，用来获取实例对象某个方面的值 getTime()返回距离1970年1月1日0点的毫秒数，同valueOf() 在ECMAScript5之前，可以使用getTime()方法实现Date.now() Date.now = function(){ return (new Date()).getTime() } getTimezoneOffset()返回当前时间与UTC的时区差异，以分钟表示(8*60=480分钟)，返回结果考虑到了夏令时因素 new Date('2016-7-12').valueOf() //1468252800000 new Date('2016-7-12').getTime() //1468252800000 new Date('2016-7-12').getTimezoneOffset() // -480 get[UTC]FullYear() 返回年份(4位数) get[UTC]Month() 返回月份(0-11) get[UTC]Date() 返回第几天(1-31) get[UTC]Day() 返回星期几(0-6) get[UTC]Hours() 返回小时值(0-23) get[UTC]Minutes() 返回分钟值(0-59) get[UTC]Seconds() 返回秒值(0-59) get[UTC]Milliseconds() 返回毫秒值(0-999) [注意]通过标准日期时间格式字符串，且有前置0的形式的参数设置，设置的是UTC时间 const d = new Date('2019-04-12 12:30:30'); d.getFullYear() // 2019 d.getUTCFullYear() // 2019 d.getMonth() // 3 d.getUTCMonth() // 3 d.getDate() // 12 d.getUTCDate() //12 d.getDay() //5 d.getUTCDay() //5 d.getHours() //12 d.getUTCHours() //4 d.getMinutes() //30 d.getSeconds() // 30 d.getMilliseconds() // 0 *【set类】Date对象提供了一系列set类方法，用来设置实例对象的各个方面 set方法基本与get方法相对应，set方法传入类似于Date.UTC()的参数，返回调整后的日期的内部毫秒数 [注意]星期只能获取，不能设置 const d = new Date('2019-04-12 12:30:30'); 1、先设置一个时间 d.setFullYear('2018') // 1523507430000 // 再去获取就改变了 d.getFullYear() // 2018 setTime() 使用毫秒的格式，设置一个Date对象的值 set[UTC]FullYear() 设置年份(4位数)，以及可选的月份值和日期值 set[UTC]Month() 设置月份(0-11)，以及可选的日期值 set[UTC]Date() 设置第几天(1-31) set[UTC]Hours() 设置小时值(0-23)，以及可选的分钟值、秒值及毫秒值 set[UTC]Minutes() 设置分钟值(0-59)，以及可选的秒值及毫秒值 set[UTC]Seconds() 设置秒值(0-59)，以及可选的毫秒值 set[UTC]Milliseconds() 设置毫秒值(0-999) 日期格式化方案 Date.prototype.format = function(fmt) { var o = { \"M+\" : this.getMonth()+1, //月份 \"d+\" : this.getDate(), //日 \"h+\" : this.getHours(), //小时 \"m+\" : this.getMinutes(), //分 \"s+\" : this.getSeconds(), //秒 \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \"S\" : this.getMilliseconds() //毫秒 }; // 正则匹配y if(/(y+)/.test(fmt)) { // RegExp.$1 = yyyy fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); } // 分别取用正则去匹配和替换月日时分秒 for(var k in o) { if(new RegExp(\"(\"+ k +\")\").test(fmt)){ fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length))); } } return fmt; }; // 使用 const time = new Date().format(\"yyyy-MM-dd hh:mm:ss\"); [注意]这是一个简单版本的时间格式化工具，有很多情况并未完全考虑到。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:12:40 "},"RegExp.html":{"url":"RegExp.html","title":"RegExp","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:12:58 "},"JavaScript正则表达式基础语法.html":{"url":"JavaScript正则表达式基础语法.html","title":"JavaScript 正则表达式基础语法","keywords":"","body":"前言 正则表达式在人们的印象中可能是一堆无法理解的字符，但就是这些符号却实现了字符串的高效操作。通常的情况是，问题本身并不复杂，但没有正则表达式就成了大问题。javascript中的正则表达式作为相当重要的知识，本文将介绍正则表达式的基础语法 定义 正则表达式(Regular Expression)是一门简单语言的语法规范，是强大、便捷、高效的文本处理工具，它应用在一些方法中，对字符串中的信息实现查找、替换和提取操作 javascript中的正则表达式用RegExp对象表示，有两种写法：一种是字面量写法；另一种是构造函数写法 【Perl写法】正则表达式字面量写法，又叫Perl写法，因为javascript的正则表达式特性借鉴自Perl 正则表达式字面量定义为包含在一对斜杠(/)之间的字符，并且可以设置3个标志 var expression = /pattern/flags; g:表示全局(global)模式，即模式将被应用于所有字符串，而并非在发现第一个匹配项时立即停止 i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写 m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 //匹配字符串所有'at'的实例 var p = /at/g; //test()方法返回一个布尔值表示是否可以找到匹配项 console.log(p.test('ata'));//true console.log(p.test('aba'));//false 【RegExp构造函数】和普通的内置对象一样，RegExp正则表达式对象也支持new RegExp()构造函数的形式 RegExp构造函数接收两个参数：要匹配的字符串模式(pattern)和可选的标志字符串(flags)，标志字符串和字面量的三个标志含义相同：'g'、'i'、'm' RegExp构造函数的两个参数都是字符串。且使用字面量形式定义的任何表达式都可使用构造函数 //匹配字符串所有'at'的实例 var p1 = /at/g; //同上 var p2 = new RegExp('at','g'); [注意]ES3规范规定，一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ES5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。IE6-8一直是按照ECMAScript5规范的方式实现的，所以并没有兼容性问题 特点 javascript中的正则表达式最大的特点是不支持空白，必须写在一行中 //匹配ab console.log(/ab/.test('ab')); //true console.log(/ ab/.test('ab')); //false console.log(/a b/.test('ab')); //false console.log(/ab /.test('ab')); //false 元字符 大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b /dog/.test(\"old dog\") // true 但还有一些字符，它们除了字面意思外，还有着特殊的含义，这些字符就是元字符在javascript中，共有14个元字符(meta-character) () [] {} \\ ^ $ | ? * + . 元字符 名称 匹配对象 . 点号 单个任意字符(除回车\\r、换行\\n、行分隔符\\u2028和段分隔符\\u2029外) [] 字符组 列出的单个任意字符 [^] 排除型字符组 未列出的单个任意字符 ? 问号 匹配0次或1次 * 星号 匹配0次或多次 + 加号 匹配1次或多次 {min,max} 区间量词 匹配至少min次，最多max次 ^ 脱字符 行的起始位置 $ 美元符 行的结束位置 | 竖线 分隔两边的任意一个表达式 () 括号 限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本 \\1,\\2... 反向引用 匹配之前的第一、第二...组括号内的表达式匹配的文本 转义字符 转义字符(escape)表示为反斜线(\\)+字符的形式，共有以下3种情况 【1】因为元字符有特殊的含义，所以无法直接匹配。如果要匹配它们本身，则需要在它们前面加上反斜杠() onsole.log(/1+1/.test('1+1')); //false console.log(/1\\+1/.test('1+1')); //true console.log(/\\*/.test('*')); //true console.log(/*/.test('*')); //报错 但实际上，并非14个元字符都需要转义，右方括号]和右花括号}不需要转义 console.log(/]/.test(']')); //true console.log(/\\]/.test(']')); //true console.log(/\\}/.test('}')); //true console.log(/}/.test('}')); //true 【2】'\\'加非元字符，表示一些不能打印的特殊字符 \\0 NUL字符\\u0000 [\\b] 匹配退格符\\u0008，不要与\\b混淆 \\t 制表符\\u0009 \\n 换行符\\u000A \\v 垂直制表符\\u000B \\f 换页符\\u000C \\r 回车符\\u000D \\xnn 由十六进制数nn指定的拉丁字符 \\uxxxx 由十六进制数xxxx指定的Unicode字符(\\u4e00-\\u9fa5代表中文) \\cX 控制字符^X，表示ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符 【3】'\\'加任意其他字符，默认情况就是匹配此字符，也就是说，反斜线(\\)被忽略了 console.log(/\\x/.test('x')); //true console.log(/\\y/.test('y')); //true console.log(/\\z/.test('z')); //true 双重转义 由于RegExp构造函数的参数是字符串，所以某些情况下，需要对字符进行双重转义 字符\\在正则表达式字符串中通常被转义为\\ var p1 = /\\.at/; //等价于 var p2 = new RegExp('\\\\.at'); var p1 = /name\\/age/; //等价于 var p2 = new RegExp('name\\\\/age'); var p1 = /\\w\\\\hello\\\\123/; //等价于 var p2 = new RegExp('\\\\w\\\\\\\\hello\\\\\\\\123'); 字符组 字符组(Character Class)，有的编译成字符类或字符集。简单而言，就是指用方括号表示的一组字符，它匹配若干字符之一 //匹配0-9这10个数字之一 var p = /[0123456789]/; p.test('1');//true p.test('a');//false [注意]字符组中的字符排列顺序并不影响字符组的功能，出现重复字符也不会影响 /[0123456789]/ //等价于 /[9876543210]/ //等价于 /[1234567890123456789]/ 【范围】正则表达式通过连字符(-)提供了范围表示法，可以简化字符组 /[0123456789]/ //等价于 /[0-9]/ /[abcdefghijklmnopqrstuvwxyz]/ //等价于 /[a-z]/ 连字符(-)表示的范围是根据ASCII编码的码值来确定的，码值小的在前，码值大的在后 所以[0-9]是合法的，而[9-0]会报错 //匹配0-9这10个数字之一 var p1 = /[0-9]/; p1.test('1');//true var p2 = /[9-0]/;//报错 p2.test('1'); 在字符组中可以同时并列多个'-'范围 /[0-9a-zA-Z]/;//匹配数字、大写字母和小写字母 /[0-9a-fA-F]/;//匹配数字，大、小写形式的a-f，用来验证十六进制字符 console.log(/[0-9a-fA-F]/.test('d'));//true console.log(/[0-9a-fA-F]/.test('x'));//false 只有在字符组内部，连字符'-'才是元字符，表示一个范围，否则它就只能匹配普通的连字符号 [注意]如果连字符出现在字符组的开头或末尾，它表示的也是普通的连字符号，而不是一个范围 /匹配中划线 console.log(/-/.test('-'));//true console.log(/[-]/.test('-'));//true //匹配0-9的数字或中划线 console.log(/[0-9]/.test('-'));//false console.log(/[0-9-]/.test('-'));//true console.log(/[0-9\\-]/.test('-'));//true console.log(/[-0-9]/.test('-'));//true console.log(/[\\-0-9]/.test('-'));//true 【排除】字符组的另一个类型是排除型字符组，在左方括号后紧跟一个脱字符'^'表示，表示在当前位置匹配一个没有列出的字符 所以[^0-9]表示0-9以外的字符 //匹配第一个是数字字符，第二个不是数字字符的字符串 console.log(/[0-9][^0-9]/.test('1e'));//true console.log(/[0-9][^0-9]/.test('q2'));//false [注意]在字符组内部，脱字符'^'表示排除，而在字符组外部，脱字符'^'表示一个行锚点 ^符号是元字符，在字符组中只要^符号不挨着左方括号就可以表示其本身含义，不转义也可以 //匹配abc和^符号 console.log(/[a-c^]/.test('^'));//true console.log(/[a-c\\^]/.test('^'));//true console.log(/[\\^a-c]/.test('^'));//true 在字符组中，只有^、-、[、]这4个字符可能被当做元字符，其他有元字符功能的字符都只表示其本身 console.log(/[[1]]/.test('['));//false console.log(/[[1]]/.test(']'));//false console.log(/[\\1]/.test('\\\\'));//false console.log(/[^^]/.test('^'));//false console.log(/[1-2]/.test('-'));//false console.log(/[\\[1\\]]/.test('['));//true console.log(/[\\[1\\]]/.test(']'));//true console.log(/[\\\\]/.test('\\\\'));//true console.log(/[^]/.test('^'));//true console.log(/[1-2\\-]/.test('-'));//true console.log(/[(1)]/.test('('));//true console.log(/[(1)]/.test(')'));//true console.log(/[{1}]/.test('{'));//true console.log(/[{1}]/.test('}'));//true console.log(/[1$]/.test('$'));//true console.log(/[1|2]/.test('|'));//true console.log(/[1?]/.test('?'));//true console.log(/[1*]/.test('*'));//true console.log(/[1+]/.test('+'));//true console.log(/[1.]/.test('.'));//true 【简记】 用[0-9]、[a-z]等字符组，可以很方便地表示数字字符和小写字母字符。对于这类常用字符组，正则表达式提供了更简单的记法，这就是字符组简记(shorthands) 常见的字符组简记有\\d、\\w、\\s。其中d表示(digit)数字，w表示(word)单词，s表示(space)空白 正则表达式也提供了对应排除型字符组的简记法：\\D、\\W、\\S。字母完全相同，只是改为大写，这些简记法匹配的字符互补 \\d 数字，等同于[0-9] \\D 非数字，等同于[^0-9] \\s 空白字符，等同于[\\f\\n\\r\\t\\u000B\\u0020\\u00A0\\u2028\\u2029] \\S 非空白字符，等同于[^\\f\\n\\r\\t\\u000B\\u0020\\u00A0\\u2028\\u2029] \\w 字母、数字、下划线，等同于[0-9A-Za-z_](汉字不属于\\w) \\W 非字母、数字、下划线，等同于[^0-9A-Za-z_] [注意]\\w不仅包括字母、数字，还包括下划线。在进行数字验证时，只允许输入字母和数字时，不可以使用\\w，而应该使用[0-9a-zA-Z] 任意字符 人们一般认为点号可以代表任意字符，其实并不是 .点号代表除回车(\\r)、换行(\\n) 、行分隔符(\\u2028)和段分隔符(\\u2029)以外的任意字符 妥善的利用互补属性，可以得到一些巧妙的效果。比如，[\\s\\S]、[\\w\\W]、[\\d\\D]都可以表示任意字符 //匹配任意字符 console.log(/./.test('\\r'));//false console.log(/[\\s\\S]/.test('\\r'));//true 量词 根据字符组的介绍，可以用字符组[0-9]或\\d来匹配单个数字字符，如果用正则表达式表示更复杂的字符串，则不太方便 //表示邮政编码6位数字 /[0-9][0-9][0-9][0-9][0-9][0-9]/; //等价于 /\\d\\d\\d\\d\\d\\d/; 正则表达式提供了量词，用来设定某个模式出现的次数 {n} 匹配n次 {n,m} 匹配至少n次，最多m次 {n,} 匹配至少n次 ? 相当于{0,1} * 相当于{0,} + 相当于{1,} //表示邮政编码6位数字 /\\d{6}/; 美国英语和英国英语有些词的写法不一样，如果traveler和traveller，favor和favour，color和colour //同时匹配美国英语和英国英语单词 /travell?er/; /favou?r/; /colou?r/; 协议名有http和https两种 /https?/; 量词广泛应用于解析HTML代码。HTML是一种标签语言，它包含各种各样的标签，比如、、。它们都是从结束，而标签名的长度不同 console.log(/]+>/.test(''));//true console.log(/]+>/.test(''));//true console.log(/]+>/.test('<>'));//false HTML标签不能为空标签，而引号字符串的两个引号之间可以为0个字符 console.log(/'[^']*'/.test(\"''\"));//true console.log(/'[^']*'/.test(\"'abc'\"));//true 【贪婪模式】默认情况下，量词都是贪婪模式(greedy quantifier)，即匹配到下一个字符不满足匹配规则为止 //exec()方法以数组的形式返回匹配结果 /a+/.exec('aaa'); // ['aaa'] 【懒惰模式】懒惰模式(lazy quantifier)和贪婪模式相对应，在量词后加问号'?'表示，表示尽可能少的匹配，一旦条件满足就再不往下匹配 {n}? 匹配n次 {n,m}? 匹配至少n次，最多m次 {n,}? 匹配至少n次 ?? 相当于{0,1} *? 相当于{0,} +? 相当于{1,} /a+?/.exec('aaa'); // ['a'] 括号 括号有两个功能，分别是分组和引用。具体而言，用于限定量词或选择项的作用范围，也可以用于捕获文本并进行引用或反向引用 【分组】量词控制之前元素的出现次数，而这个元素可能是一个字符，也可能是一个字符组，也可以是一个表达式 如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为子表达式 如果希望字符串'ab'重复出现2次，应该写为(ab){2}，而如果写为ab{2}，则{2}只限定b console.log(/(ab){2}/.test('abab'));//true console.log(/(ab){2}/.test('abb'));//false console.log(/ab{2}/.test('abab'));//false console.log(/ab{2}/.test('abb'));//true 身份证长度有15位和18位两种，如果只匹配长度，可能会想当然地写成\\d{15,18}，实际上这是错误的，因为它包括15、16、17、18这四种长度。因此，正确的写法应该是\\d{15}(\\d{3})? email地址以@分隔成两段，之前的部分是用户名，之后的部分是主机名 用户名允许出现数字、字母和下划线，长度一般在1-64个字符之间，则正则可表示为/\\w{1,64}/ 主机名一般表现为a.b.···.c，其中c为主域名，其他为级数不定的子域名，则正则可表示为/([-a-zA-z0-9]{1,63}.)+[-a-zA-Z0-9]{1,63}/ 所以email地址的正则表达式如下： var p =/\\w{1,64}@([-a-zA-z0-9]{1,63}\\.)+[-a-zA-Z0-9]{1,63}/; console.log(p.test('q@qq.com'));//true console.log(p.test('q@qq'));//false console.log(p.test('q@a.qq.com'));//true 【捕获】括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫捕获分组 比如，要匹配诸如2016-06-23这样的日期字符串 /(\\d{4})-(\\d{2})-(\\d{2})/ 与以往不同的是，年、月、日这三个数值被括号括起来了，从左到右为第1个括号、第2个括号和第3个括号，分别代表第1、2、3个捕获组 javascript有9个用于存储捕获组的构造函数属性 RegExp.$1\\RegExp.$2\\RegExp.$3……到RegExp.$9分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充 console.log(/(\\d{4})-(\\d{2})-(\\d{2})/.test('2016-06-23'));//true console.log(RegExp.$1);//'2016' console.log(RegExp.$2);//'06' console.log(RegExp.$3);//'23' console.log(RegExp.$4);//'' 而exec()方法是专门为捕获组而设计的，返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串 console.log(/(\\d{4})-(\\d{2})-(\\d{2})/.exec('2016-06-23'));//[\"2016-06-23\", \"2016\", \"06\", \"23\"] 捕获分组捕获的文本，不仅可以用于数据提取，也可以用于替换 replace()方法就是用于进行数据替换的，该方法接收两个参数，第一个参数为待查找的内容，而第二个参数为替换的内容 console.log('2000-01-01'.replace(/-/g,'.'));//2000.01.01 在replace()方法中也可以引用分组，形式是$num，num是对应分组的编号 //把2000-01-01的形式变成01-01-2000的形式 console.log('2000-01-01'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g,'$3-$2-$1'));//'01-01-2000' 【反向引用】英文中不少单词都有重叠出现的字母，如shoot或beep。若想检查某个单词是否包含重叠出现的字母，则需要引入反向引用(back-reference) 反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是\\num，num表示所引用分组的编号 //重复字母 /([a-z])\\1/ console.log(/([a-z])\\1/.test('aa'));//true console.log(/([a-z])\\1/.test('ab'));//false 反向引用可以用于建立前后联系。HTML标签的开始标签和结束标签是对应的 //开始标签 ]+)> //标签内容 [\\s\\S]*? //匹配成对的标签 /]+)>[\\s\\S]*?/ console.log(/]+)>[\\s\\S]*?/.test('123'));//true console.log(/]+)>[\\s\\S]*?/.test('123'));//false 【非捕获】除了捕获分组，正则表达式还提供了非捕获分组(non-capturing group)，以(?:)的形式表示，它只用于限定作用范围，而不捕获任何文本 比如，要匹配abcabc这个字符，一般地，可以写为(abc){2}，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为(?:abc){2} console.log(/(abc){2}/.test('abcabc'));//true console.log(/(?:abc){2}/.test('abcabc'));//true 由于非捕获分组不捕获文本，对应地，也就没有捕获组编号 console.log(/(abc){2}/.test('abcabc'));//true console.log(RegExp.$1);//'abc' console.log(/(?:abc){2}/.test('abcabc'));//true console.log(RegExp.$1);//'' 非捕获分组也不可以使用反向引用 /(?:123)\\1/.test('123123');//false /(123)\\1/.test('123123');//true 捕获分组和非捕获分组可以在一个正则表达式中同时出现 console.log(/(\\d)(\\d)(?:\\d)(\\d)(\\d)/.exec('12345'));//[\"12345\", \"1\", \"2\", \"4\", \"5\"] 选择 竖线'|'在正则表达式中表示或(OR)关系的选择，以竖线'|'分隔开的多个子表达式也叫选择分支或选择项。在一个选择结构中，选择分支的数目没有限制 在选择结构中，竖线|用来分隔选择项，而括号()用来规定整个选择结构的范围。如果没有出现括号，则将整个表达式视为一个选择结构 选择项的尝试匹配次序是从左到右，直到发现了匹配项，如果某个选择项匹配就忽略右侧其他选择项，如果所有子选择项都不匹配，则整个选择结构匹配失败 console.log(/12|23|34/.exec('1'));//null console.log(/12|23|34/.exec('12'));//['12'] console.log(/12|23|34/.exec('23'));//['23'] console.log(/12|23|34/.exec('2334'));//['23'] ip地址一般由3个点号和4段数字组成，每段数字都在0-255之间 (00)?\\d; //0-9 0?[1-9]\\d;//10-99 1\\d{2};//100-199 2[0-4]\\d;//200-249 25[0-5];//250-255 //数字(0-255) /(00)?\\d|0?[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5]/; //ip地址 var ip = /^(((00)?\\d|0?[1-9]\\d|1\\d{2}|2[0-4]\\d|25[0-5])\\.){3}\\2$/; console.log(ip.test('1.1.1.1'));//true console.log(ip.test('1.1.1'));//false console.log(ip.test('256.1.1.1'));//false 类似地，时间匹配也需要分段处理 //月(1-12) 0?\\d|1[0-2] //日(1-31) 0?\\d|[12]\\d|3[01] //小时(0-24) 0?\\d|1\\d|2[0-4] //分钟(0-60) 0?\\d|[1-5]\\d|60 手机号一般是11位，前3位是号段，后8位一般没有限制。而且，在手机开头很可能有0或+86 //开头 (0|\\+86)? //前3位 13\\d|14[579]|15[0-35-9]|17[0135-8]|18\\d //后8位 \\d{8} //手机号码 var phone = /(0|\\+86)?(13\\d|14[579]|15[0-35-9]|17[0135-8]|18\\d)\\d{8}/; console.log(phone.test('13453250661'));//true console.log(phone.test('1913250661'));//false console.log(phone.test('1345325061'));//false 在选择结构中，应该尽量避免选择分支中存在重复匹配，因为这样会大大增加回溯的计算量 //不良的选择结构 a|[ab] [0-9]|\\w 断言 在正则表达式中，有些结构并不真正匹配文本，而只负责判断在某个位置左/右侧是否符合要求，这种结构被称为断言(assertion)，也称为锚点(anchor)，常见的断言有3种：单词边界、行开头结尾、环视 【单词边界】在文本处理中可能会经常进行单词替换，比如把row替换成line。但是，如果直接替换，不仅所有单词row都被替换成line，单词内部的row也会被替换成line。要想解决这个问题，必须有办法确定单词row，而不是字符串row 为了解决这类问题，正则表达式提供了专用的单词边界(word boundary)，记为\\b，它匹配的是'单词边界'位置，而不是字符。\\b匹配的是一边是单词字符\\w，一边是非单词字符\\W的位置 与\\b对应的还有\\B，表示非单词边界，但实际上\\B很少使用 console.log(/\\ban\\b/.test('an apple'));//true console.log(/\\ban\\b/.test('a an'));//true console.log(/\\ban\\b/.test('an'));//true console.log(/\\ban\\b/.test('and'));//false console.log(/\\ban\\b/.test('ban'));//false 【起始结束】常见的断言还有^和$，它们分别匹配字符串的开始位置和结束位置，所以可以用来判断整个字符串能否由表达式匹配 //匹配第一个单词 console.log(/^\\w*/.exec('first word\\nsecond word\\nthird word'));//['first'] //匹配最后一个单词 console.log(/\\w*$/.exec('first word\\nsecond word\\nthird word'));//['word'] console.log(/^a$/.test('a\\n'));//false console.log(/^a$/.test('a'));//true ^和$的常用功能是删除字符串首尾多余的空白，类似于字符串String对象的trim()方法 function fnTrim(str){ return str.replace(/^\\s+|\\s+$/,'') } console.log(fnTrim(' hello world '));//'hello world' 【环视】环视(look-around)，可形象地解释为停在原地，四处张望。环视类似于单词边界，在它旁边的文本需要满足某种条件，而且本身不匹配任何字符 环视分为正序环视和逆序环视，而javascript只支持正序环视，相当于只支持向前看，不支持往回看 而正序环视又分为肯定正序环视和否定正序环视 肯定正序环视的记法是(?=n)，表示前面必须是n才匹配；否定正序环视的记忆法是(?!n)，表示前面必须不是n才匹配 console.log(/a(?=b)/.exec('abc'));//['a'] console.log(/a(?=b)/.exec('ac'));//null console.log(/a(?!b)/.exec('abc'));//null console.log(/a(?!b)/.exec('ac'));//['a'] console.log(/a(?=b)b/.exec('abc'));//['ab'] 注意：环视虽然也用到括号，却与捕获型分组编号无关；但如果环视结构出现捕获型括号，则会影响分组 console.log(/ab(?=cd)/.exec('abcd'));['ab'] console.log(/ab(?=(cd))/.exec('abcd'));['ab','cd'] 匹配模式 匹配模式(match mode)指匹配时使用的规则。设置特定的模式，可能会改变对正则表达式的识别。前面已经介绍过创建正则表达式对象时，可以设置'm'、'i'、'g'这三个标志，分别对应多行模式、不区分大小模式和全局模式三种 【i】默认地，正则表达式是区分大小写的，通过设置标志'i'，可以忽略大小写(ignore case) console.log(/ab/.test('aB'));//false console.log(/ab/i.test('aB'));//true 【m】默认地，正则表达式中的^和$匹配的是整个字符串的起始位置和结束位置，而通过设置标志'm'，开启多行模式，它们也能匹配字符串内部某一行文本的起始位置和结束位置 console.log(/world$/.test('hello world\\n')); //false console.log(/world$/m.test('hello world\\n')); //true console.log(/^b/.test('a\\nb')); //false console.log(/^b/m.test('a\\nb')); //true 【g】默认地，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配(global)，设置'g'标志后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换 console.log('1a,2a,3a'.replace(/a/,'b'));//'1b,2a,3a' console.log('1a,2a,3a'.replace(/a/g,'b'));//'1b,2b,3b' 优先级 正则表达式千变万化，都是由之前介绍过的字符组、括号、量词等基本结构组合而成的 //从上到下，优先级逐渐降低 \\ 转义符 () (?!) (?=) [] 括号、字符组、环视 * + ? {n} {n,} {n,m} 量词 ^ $ 起始结束位置 | 选择 由于括号的用途之一就是为量词限定作用范围，所以优先级比量词高 console.log(/ab{2}/.test('abab'));//false console.log(/(ab){2}/.test('abab'));//true 注意：选择符'|'的优先级最低，比起始和结束位置都要低 console.log(/^ab|cd$/.test('abc'));//true console.log(/^(ab|cd)$/.test('abc'));//false 局限性 尽管javascript中的正则表达式功能比较完备，但与其他语言相比，缺少某些特性 下面列出了javascript正则表达式不支持的特性 【1】POSIX字符组(只支持普通字符组和排除型字符组) 【2】Unicode支持(只支持单个Unicode字符) 【3】匹配字符串开始和结尾的\\A和\\Z锚(只支持^和$) 【4】逆序环视(只支持顺序环视) 【5】命名分组(只支持0-9编号的捕获组) 【6】单行模式和注释模式(只支持m、i、g) 【7】模式作用范围 【8】纯文本模式 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:17:00 "},"JavaScript数据类型正则表达式RegExp类型.html":{"url":"JavaScript数据类型正则表达式RegExp类型.html","title":"JavaScript数据类型 正则表达式RegExp类型","keywords":"","body":"前言 上一篇文章已经介绍了正则表达式的基础语法。javascript的RegExp类表示正则表达式，String和RegExp都定义了方法，使用正则表达式可以进行强大的模式匹配和文本检索与替换。本文将介绍正则表达式的RegExp对象，以及正则表达式涉及到的属性和方法 对象 javascript中的正则表达式用RegExp对象表示，有两种写法：一种是字面量写法；另一种是构造函数写法 【Perl写法】正则表达式字面量写法，又叫Perl写法，因为javascript的正则表达式特性借鉴自Perl 正则表达式字面量定义为包含在一对斜杠(/)之间的字符，并且可以设置3个标志 var expression = /pattern/flags; 正则表达式的匹配模式支持下列3个标志： g:表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止 i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写 m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项 //匹配字符串所有'at'的实例 var p = /at/g; //test()方法返回一个布尔值表示是否可以找到匹配项 console.log(p.test('ata'));//true console.log(p.test('aba'));//false 【RegExp构造函数】和普通的内置对象一样，RegExp正则表达式对象也支持new+RegExp()构造函数的形式 RegExp构造函数接收两个参数：要匹配的字符串模式(pattern)和可选的标志字符串(flags)，标志字符串和字面量的三个标志含义相同：'g'、'i'、'm' RegExp构造函数的两个参数都是字符串。且使用字面量形式定义的任何表达式都可使用构造函数 //匹配字符串所有'at'的实例 var p1 = /at/g; //同上 var p2 = new RegExp('at','g'); [注意]ECMAScript3规范规定，一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码所表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象。IE6-8一直是按照ECMAScript5规范的方式实现的，所以并没有兼容性问题 由于正则表达式字面量并不支持变量，所以如果正则表达式中出现变量只能使用RegExp构造函数以字符串拼接的形式，将变量拼接到RegExp构造函数的参数中 【tips】通过类名classname获取元素 function getByClass(obj,classname){ var elements = obj.getElementsByTagName('*'); var result = []; var pattern = new RegExp( '(^|\\\\s)'+ classname + '(\\\\s|$)'); for(var i = 0; i 实例属性 每个RegExp实例对象都包含如下5个属性 global:　　 布尔值，表示是否设置了g标志 ignoreCase: 布尔值，表示是否设置了i标志 lastIndex: 整数，表示开始搜索下一个匹配项的字符位置，从0算起 multiline: 布尔值，表示是否设置了标志m source: 　　 正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回 var pattern = new RegExp('\\\\[bc\\\\]at','i'); console.log(pattern.global);//false console.log(pattern.ignoreCase);//true console.log(pattern.multiline);//false console.log(pattern.lastIndex);//0 console.log(pattern.source);//'\\[bc\\]at' 如果使用RegExp的exec()或test()函数，并且设定了全局模式'g'，正则表达式的匹配就会从lastIndex的位置开始，并且在每次匹配成功之后重新设定lastIndex。这样，就可以在字符串中重复迭代，依次寻找各个匹配结果。但是，如果需要对不同字符串调用同一个RegExp的exec()或test()方法，这个变量也可能会带来意料之外的匹配结果，所以在更换字符串时，要显式地将RegExp的lastIndex置为0 //exec()方法以数组形式返回匹配项 var p = /\\w/g; var s = 'ab'; console.log(p.lastIndex);//0 console.log(p.exec(s));//['a'] console.log(p.lastIndex);//1 console.log(p.exec(s));//['b'] console.log(p.lastIndex);//2 console.log(p.exec(s));//null console.log(p.lastIndex);//0 var p = /\\w/g; var s1 = 'ab'; var s2 = 'ba'; console.log(p.lastIndex);//0 console.log(p.exec(s1));//['a'] console.log(p.lastIndex);//1 console.log(p.exec(s2));//['a'] console.log(p.lastIndex);//2 构造函数属性 RegExp构造函数属性被看成静态属性，这些属性基于所执行的最近一次正则表达式操作而变化 有两种方式访问它们，即长属性名和短属性名。短属性名大都不是有效的ECMAScript标识符，所以必须通过方括号语法来访问它们 长属性名 短属性名 　　　　 说明 input $_ 最近一次要匹配的字符串 lastMatch $& 最近一次的匹配项 lastParen $+ 最近一次匹配的捕获组 leftContext $` input字符串中lastMatch之前的文本 multiline $* 布尔值，表示是否所有表达式都使用多行模式 rightContext $' input字符串中lastMatch之后的文本 使用这些属性，可以从exec()方法或test()方法执行的操作中提取出更具体的信息 //test()用于测试一个字符串是否匹配某个正则表达式，并返回一个布尔值 var text = 'this has been a short summer'; var pattern = /(.)hort/g; if(pattern.test(text)){ console.log(RegExp.input);//'this has been a short summer' console.log(RegExp.leftContext);//'this has been a ' console.log(RegExp.rightContext);//' summer' console.log(RegExp.lastMatch);//'short' console.log(RegExp.lastParen);//'s' console.log(RegExp.multiline);//false console.log(RegExp['$_']);//'this has been a short summer' console.log(RegExp['$`']);//'this has been a ' console.log(RegExp[\"$'\"]);//' summer' console.log(RegExp['$&']);//'short' console.log(RegExp['$+']);//'s' console.log(RegExp['$*']);//false } javascript有9个用于存储捕获组的构造函数属性，在调用exec()或test()方法时，这些属性会被自动填充 [注意]理论上，应该保存整个表达式匹配文本的RegExp.$0并不存在，值为undefined /RegExp.$1\\RegExp.$2\\RegExp.$3……到RegExp.$9分别用于存储第一、第二……第九个匹配的捕获组 var text = 'this has been a short summer'; var pattern = /(..)or(.)/g; if(pattern.test(text)){ console.log(RegExp.$1);//sh console.log(RegExp.$2);//t } 实例方法 RegExp对象的实例方法共5个，分为两类。包括toString()、toLocalString()、valueOf()这3种对象通用方法和test()、exec()正则匹配方法 对象通用方法 RegExp对象继承了Object对象的通用方法toString()、toLocaleString()、valueOf()这三个方法 【toString()】toString()方法返回正则表达式的字面量 【toLocaleString()】toLocaleString()方法返回正则表达式的字面量 【valueOf()】valueOf()方法返回返回正则表达式对象本身 [注意]不论正则表达式的创建方式是哪种，这三个方法都只返回其字面量形式 var pattern = new RegExp('[bc]at','gi'); console.log(pattern.toString()); // '/[bc]at/gi' console.log(pattern.toLocaleString()); // '/[bc]at/gi' console.log(pattern.valueOf()); // /[bc]at/gi var pattern = /[bc]at/gi; console.log(pattern.toString()); // '/[bc]at/gi' console.log(pattern.toLocaleString()); // '[bc]at/gi' console.log(pattern.valueOf()); // /[bc]at/gi 正则匹配方法 正则表达式RegExp对象的正则匹配方法只有两个：分别是exec()和test() 【exec()】exec()方法专门为捕获组而设计，接受一个参数，即要应用模式的字符串。然后返回包含匹配项信息的数组，在没有匹配项的情况下返回null 在匹配项数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串，如果模式中没有捕获组，则该数组只包含一项 返回的数组包含两个额外的属性：index和input。index表示匹配项在字符串的位置，input表示应用正则表达式的字符串 ar text = 'mom and dad and baby and others'; var pattern = /mom( and dad( and baby)?)?/gi; var matches = pattern.exec(text); console.log(pattern,matches); //pattern.lastIndex:20 //matches[0]:'mom and dad and baby' //matches[1]:' and dad and baby' //matches[2]:' and baby' //matches.index:0 //matches.input:'mom and dad and baby and others' 对于exec()方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()，将始终返回第一个匹配项的信息；而在设置全局标志的情况下，每次调用exec()都会在字符串中继续查找新匹配项 var text = 'cat,bat,sat,fat'; var pattern1 = /.at/; var matches = pattern1.exec(text); console.log(pattern1,matches); //pattern1.lastIndex:0 //matches[0]:'cat' //matches.index:0 //matches.input:'cat,bat,sat,fat' var text = 'cat,bat,sat,fat'; matches = pattern1.exec(text); console.log(pattern1,matches); //pattern1.lastIndex:0 //matches[0]:'cat' //matches.index:0 //matches.input:'cat,bat,sat,fat' var text = 'cat,bat,sat,fat'; var pattern2 = /.at/g; var matches = pattern2.exec(text); console.log(pattern2,matches); //pattern2.lastIndex:3 //matches[0]:'cat' //matches.index:0 //matches.input:'cat,bat,sat,fat' var text = 'cat,bat,sat,fat'; matches = pattern2.exec(text); console.log(pattern2,matches); //pattern2.lastIndex:7 //matches[0]:'bat' //matches.index:4 //matches.input:'cat,bat,sat,fat' 【tips】用exec()方法找出匹配的所有位置和所有值 var string = 'j1h342jg24g234j 3g24j1'; var pattern = /\\d/g; var valueArray = [];//值 var indexArray = [];//位置 var temp; while((temp=pattern.exec(string)) != null){ valueArray.push(temp[0]); indexArray.push(temp.index); } //[\"1\", \"3\", \"4\", \"2\", \"2\", \"4\", \"2\", \"3\", \"4\", \"3\", \"2\", \"4\", \"1\"] [1, 3, 4, 5, 8, 9, 11, 12, 13, 16, 18, 19, 21] console.log(valueArray,indexArray); 【test()】test()方法用来测试正则表达式能否在字符串中找到匹配文本，接收一个字符串参数，匹配时返回true，否则返回false var text = '000-00-000'; var pattern = /\\d{3}-\\d{2}-\\d{4}/; if(pattern.test(text)){ console.log('The pattern was matched'); } 同样地，在调用test()方法时，会造成RegExp对象的lastIndex属性的变化。如果指定了全局模式，每次执行test()方法时，都会从字符串中的lastIndex偏移值开始尝试匹配，所以用同一个RegExp多次验证不同字符串，必须在每次调用之后，将lastIndex值置为0 var pattern = /^\\d{4}-\\d{2}-\\d{2}$/g; console.log(pattern.test('2016-06-23'));//true console.log(pattern.test('2016-06-23'));//false //正确的做法应该是在验证不同字符串前，先将lastIndex重置为0 var pattern = /^\\d{4}-\\d{2}-\\d{2}$/g; console.log(pattern.test('2016-06-23'));//true pattern.lastIndex = 0; console.log(pattern.test('2016-06-23'));//true 前面介绍过，javascript有9个用于存储捕获组的构造函数属性，在调用exec()或test()方法时，这些属性会被自动填充 [注意]理论上，应该保存整个表达式匹配文本的RegExp.$0并不存在，值为undefined if(/^(\\d{4})-(\\d{2})-(\\d{2})$/.test('2016-06-23')){ console.log(RegExp.$1);//'2016' console.log(RegExp.$2);//'06' console.log(RegExp.$3);//'23' console.log(RegExp.$0);//undefined } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:18:41 "},"类型转换.html":{"url":"类型转换.html","title":"类型转换","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:18:51 "},"JavaScript类型判断详解（Object.prototype.toString.call方法）.html":{"url":"JavaScript类型判断详解（Object.prototype.toString.call方法）.html","title":"JavaScript类型判断详解（Object.prototype.toString.call()方法）","keywords":"","body":"前言 在编写一些类库中，我们经常需要判断一些未知的用户的输入和配置，故而需要进行一系列的类型判断。故而总结下JS是如何进行类型判断的 typeof typeof操作符返回一个字符串，表示未经计算的操作数的类型；该运算符数据类型（返回字符串，对应列表如图） typeof undefined = undefined typeof Null = object typeof Boolean = boolean typeof Number = number typeof String = string typeof Symbol = symbol typeof 函数 = function typeof 其它对象均返回object 至此我们可以确定：Null，数组之类的对象是没有办法通过typeof来确定的。 instanceof instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置 var str = \"This is a simple string\"; var num = 1111; var boolean = true; var und = undefined; var nl = null; var sb = Symbol('1111'); var obj = {}; // 非原始类型数据字面量定义 console.log(str instanceof String); // false console.log(num instanceof Number); // false console.log(boolean instanceof Boolean); // false console.log(nl instanceof Object); // false console.log(sb instanceof Symbol); // false console.log(obj instanceof Object); // true var strN = new String(\"This is a simple string\"); var numN = new Number(1111); var booleanN = new Boolean(true); var objN = new Object(); console.log(strN instanceof String); // true console.log(numN instanceof Number); // true console.log(booleanN instanceof Boolean); // true console.log(objN instanceof Object); // true 字面量产出的原始数据类型无法使用instanceof判断 上面两种方法都有着各自的缺陷，那么我们应该如何确切有效的进行类型判断呢？ 下面介绍一个非常可靠的方法： Object.propotype.toString 返回一个表示该对象的字符串 Object.prototype.toString.call('string'); //\"[object String]\" Object.prototype.toString.call(1111); //\"[object Number]\" Object.prototype.toString.call(true); //\"[object Boolean]\" Object.prototype.toString.call(null); //\"[object Null]\" Object.prototype.toString.call(undefined); //\"[object Undefined]\" Object.prototype.toString.call(Symbol('111')); //\"[object Symbol]\" Object.prototype.toString.call({}); //\"[object Object]\" 参考文献 MDN toString Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:19:32 "},"对象.html":{"url":"对象.html","title":"对象","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:19:44 "},"JavaScript对象Object类型基础.html":{"url":"JavaScript对象Object类型基础.html","title":"JavaScript对象 Object类型基础","keywords":"","body":"前言 JavaScript 对象是整个语言学习的一个难点。本文主要带大家入门学习Object知识 对象定义 javascript的基本数据类型包括undefined、null、boolean、string、number和object。对象和其他基本类型值不同的是，对象是一种复合值：它将许多值(原始值或者其他对象)聚合在一起，可通过名字访问这些值 于是，对象也可看做是属性的无序集合，每个属性都是一个名值对。属性名是字符串，因此我们可以把对象看成是从字符串到值的映射 对象创建 有以下三种方式来创建对象，包括new构造函数、对象直接量和Object.create()函数 【1】new构造函数使用new操作符后跟Object构造函数用以初始化一个新创建的对象 var person = new Object(); //如果不给构造函数传递参数可以不加括号 var person = new Object; person.name = 'bai'; person.age = 29; // 如果该参数是一个对象，则直接返回这个对象 var o1 = {a: 1}; var o2 = new Object(o1); console.log(o1 === o2);// true var f1 = function(){}; var f2 = new Object(f1); console.log(f1 === f2);// true // 如果是一个原始类型的值，则返回该值对应的包装对象 //Number {[[PrimitiveValue]]: 1} console.log(new Object(1)); //Boolean {[[PrimitiveValue]]: true} console.log(new Object(true)); 若Object()函数不通过new而直接使用，则相当于转换方法，可以把任意值转换为对象 var uObj = Object(undefined); // {} var nObj = Object(null); // {} // 如果是一个原始类型的值，则返回该值对应的包装对象 //Number {[[PrimitiveValue]]: 1} console.log(Object(1)); //Boolean {[[PrimitiveValue]]: true} console.log(Object(true)); // 如果Object()的参数是一个对象，则直接返回原对象 var o = {a:1}; var oObj = Object(o); o === oObj // true 利用这一点，可以写一个判断变量是否为对象的函数 1、对象传入还是返回对象 2、undefined null 传入 返回空对象 3、number boolean string 传入返回包装对象 function isObject(value) { return value === Object(value); } 【2】对象字面量javascript提供了叫做字面量的快捷方式，用于创建大多数原生对象值。使用字面量只是隐藏了与使用new操作符相同的基本过程，于是也可以叫做语法糖 对象字面量是由若干名值对组成的映射表，名值对中间用冒号分隔，整个映射表用花括号括起来 不同属性之间用逗号分隔，属性名可以是任意字符串，属性值可以是任意类型表达式，表达式的值是属性值 //等价于var person = new Object(); var person = {}; var person = { name : 'bai', age : 29, 5 : true }; 使用对象字面量的方法来定义对象，属性名会自动转换成字符串 var person = { 'name' : 'bai', 'age' : 29, '5' : true }; [注意]一般地，对象字面量的最后一个属性后的逗号将忽略，但在IE7-浏览器中导致错误 【3】Object.create()ES5定义了一个名为Object.create()的方法，它创建一个新对象，第一个参数就是这个对象的原型，第二个可选参数用以对对象的属性进行进一步描述 var o1 = Object.create({x:1,y:1}); //o1继承了属性x和y console.log(o1.x);//1 可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法。比如toString()和valueOf() var o2 = Object.create(null); // o2不继承任何属性和方法 var o1 = {}; console.log(Number(o1));//NaN console.log(Number(o2));//Uncaught TypeError: Cannot convert object to primitive value 如果想创建一个普通的空对象(比如通过{}或new Object()创建的对象)，需要传入Object.prototype var o3 = Object.create(Object.prototype); // o3和{}和new Object()一样 var o1 = {}; console.log(Number(o1));//NaN console.log(Number(o3));//NaN Object.create()方法的第二个参数是属性描述符 var o1 = Object.create({z:3},{ x:{value:1,writable: false,enumerable:true,configurable:true}, y:{value:2,writable: false,enumerable:true,configurable:true} }); console.log(o1.x,o1.y,o1.z);//1 2 3 对象组成 对象是属性的无序集合，由键名和属性值组成 【键名】对象的所有键名都是字符串，所以加不加引号都可以，如果不是字符串也会自动转换成字符串 var o ={ 1: 'a', 3.2: 'b', 1e2: true, 1e-2: true, .234: true, 0xFF: true, }; //Object {1: \"a\", 100: true, 255: true, 3.2: \"b\", 0.01: true, 0.234: true} [注意]如果键名不符合标识符命名规则，则必须加上引号，否则会报错 //Uncaught SyntaxError: Unexpected identifier var o = { 1p: 123 } var o = { '1p': 123 } 【属性值】属性值可以是任何类型的表达式，最终表达式的结果就是属性值的结果 var o ={ a: 1+2 } console.log(o.a);//3 由于对象的方法就是函数，因此也有name属性。方法的name属性返回紧跟在function关键字后面的函数名。如果是匿名函数，ES5环境会返回undefined，ES6环境会返回方法名 var obj = { m1: function f() {}, m2: function () {} }; obj.m1.name // \"f\" obj.m2.name //ES5： undefined obj.m2.name //ES6： \"m2\" 引用对象 如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量如果取消某一个变量对于原对象的引用，不会影响到另一个变量 var o1 = {}; var o2 = o1; o1.a = 1; console.log(o2.a);// 1 o2.b = 2; console.log(o1.b);// 2 var o1 = {}; var o2 = o1; o1 = 1; console.log(o2);//{} 实例方法 【valueOf()】valueOf()方法返回当前对象 var o = new Object(); o.valueOf() === o // true 【toString()】返回当前对象对应的字符串形式 var o1 = new Object(); o1.toString() // \"[object Object]\" var o2 = {a:1}; o2.toString() // \"[object Object]\" 一般地，使用Object.prototype.toString()来获取对象的类属性，进行类型识别，详细情况移步至此 【toLocaleString()】toLocaleString()方法并不做任何本地化自身的操作，它仅调用toString()方法并返回对应值 var o = {a:1}; o.toLocaleString() // \"[object Object]\" 判断为空 判断对象是否为空，有以下三种方法 1、for-in语句 let isEmpty = (obj) => { for(let i in obj){ return false } return true } console.log(isEmpty({}))//true console.log(isEmpty({a:1}))//false 2、JSON.stringify方法 let isEmpty = (obj) => { return JSON.stringify(obj) === '{}' } console.log(isEmpty({}))//true console.log(isEmpty({a:1}))//false 3、Object.keys方法 let isEmpty = (obj) => { return !Object.keys(obj).length } console.log(isEmpty({}))//true console.log(isEmpty({a:1}))//false 小结 通过本文我们学习了： 1、对象创建的三种方式：new Object()，Object() 、对象字面量、Object.create() 2、对象组成：属性名+属性值 3、对象的引用 4、对象的实例方法：valueof() 、toString() 5、对象的为空判断的三种方法 for-in 、JSON.stringify、Object.keys Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:22:20 "},"函数.html":{"url":"函数.html","title":"函数","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:25:29 "},"深入学习javaScript闭包闭包的原理，闭包的作用，闭包与内存管理.html":{"url":"深入学习javaScript闭包闭包的原理，闭包的作用，闭包与内存管理.html","title":"深入学习javaScript闭包(闭包的原理，闭包的作用，闭包与内存管理)","keywords":"","body":"前言 虽然JavaScript是一门完整的面向对象的编程语言，但这门语言同时也拥有许多函数式语言的特性。 函数式语言的鼻祖是LISP，JavaScript在设计之初参考了LISP两大方言之一的Scheme，引入了Lambda表达式、闭包、高阶函数等特性。使用这些特性，我们经常可以用一些灵活而巧妙的方式来编写JavaScript代码。 闭包 闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数 一个最常见的闭包案例 var closure = function(){ var count = 0; return function(){ count ++; } } closure(); // 1 closure(); // 2 closure(); // 3 对于JavaScript程序员来说，闭包（closure）是一个难懂又必须征服的概念。闭包的形成与变量的作用域以及变量的生存周期密切相关。 变量的作用域 变量的作用域，就是指变量的有效范围。我们最常谈到的是在函数中声明的变量作用域。 当在函数中声明一个变量的时候，如果该变量前面没有带上关键字var，这个变量就会成为全局变量，这当然是一种容易造成命名冲突的做法。 另外一种情况是用var关键字在函数中声明变量，这时候的变量即是局部变量，只有在该函数内部才能访问到这个变量，在函数外面是访问不到的。代码如下： var func = function(){ var a = 1; alert ( a ); // 输出: 1 }; func(); alert ( a ); // 输出：Uncaught ReferenceError: a is not defined [重点]在JavaScript中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。这是因为当在函数中搜索一个变量的时候，如果该函数内并没有声明这个变量，那么此次搜索的过程会随着代码执行环境创建的作用域链往外层逐层搜索，一直搜索到全局对象为止。变量的搜索是从内到外而非从外到内的。 变量的生存周期 除了变量的作用域之外，另外一个跟闭包有关的概念是变量的生存周期。 对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。 而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁： var func = function(){ var a = 1; // 退出函数后局部变量a将被销毁 alert ( a ); }; func(); 看闭包的形式 var func = function(){ var a = 1; return function(){ a++; alert ( a ); } }; var f = func(); f(); // 输出：2 f(); // 输出：3 f(); // 输出：4 f(); // 输出：5 当退出函数后，局部变量a并没有消失，而是似乎一直在某个地方存活着。这是因为当执行var f = func();时，f返回了一个匿名函数的引用，它可以访问到func()被调用时产生的环境，而局部变量a一直处在这个环境里。既然局部变量所在的环境还能被外界访问，这个局部变量就有了不被销毁的理由。在这里产生了一个闭包结构，局部变量的生命看起来被延续了。 【闭包经典经典案例】 function createFunctions(){ var result = new Array(); for (var i=0; i 这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值，即位置0的函数返回0，位置1的函数返回1，以此类推。但实际上，每个函数都返回10。因为每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以它们引用的都是同一个变量i。当createFunctions()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是10。但是，我们可以通过创建另一个匿名函数强制让闭包的行为符合预期，如下所示。 function createFunctions(){ var result = new Array(); for (var i=0; i [重点]在重写了前面的createFunctions()函数后，每个函数就会返回各自不同的索引值了。在这个版本中，我们没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量i。由于函数参数是按值传递的，所以就会将变量i的当前值复制给参数num。而在这个匿名函数内部，又创建并返回了一个访问num的闭包。这样一来，result数组中的每个函数都有自己num变量的一个副本，因此就可以返回各自不同的数值了。 闭包的作用 【封装变量】闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。假设有一个计算乘积的简单函数： var mult = function(){ var a = 1; for ( var i = 0, l = arguments.length; i mult函数接受一些number类型的参数，并返回这些参数的乘积。现在我们觉得对于那些相同的参数来说，每次都进行计算是一种浪费，我们可以加入缓存机制来提高这个函数的性能： var cache = {}; var mult = function(){ var args = Array.prototype.join.call( arguments, ',' ); // 通过call方法借用数组方法 if ( cache[ args ] ){ return cache[ args ]; } var a = 1; for ( var i = 0, l = arguments.length; i 我们看到cache这个变量仅仅在mult函数中被使用，与其让cache变量跟mult函数一起平行地暴露在全局作用域下，不如把它封闭在mult函数内部，这样可以减少页面中的全局变量，以避免这个变量在其他地方被不小心修改而引发错误。代码如下： var mult = (function(){ var cache = {}; return function(){ var args = Array.prototype.join.call( arguments, ',' ); if ( args in cache ){ return cache[ args ]; } var a = 1; for ( var i = 0, l = arguments.length; i 提炼函数是代码重构中的一种常见技巧。如果在一个大函数中有一些代码块能够独立出来，我们常常把这些代码块封装在独立的小函数里面。独立出来的小函数有助于代码复用，如果这些小函数有一个良好的命名，它们本身也起到了注释的作用。如果这些小函数不需要在程序的其他地方使用，最好是把它们用闭包封闭起来。代码如下： var mult = (function(){ var cache = {}; var calculate = function(){ // 封闭calculate函数 var a = 1; for ( var i = 0, l = arguments.length; i 【延续局部变量的寿命】 img对象经常用于进行数据上报，如下所示： var report = function( src ){ var img = new Image(); img.src = src; }; report( 'http://xxx.com/getUserInfo' ); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在bug，在这些浏览器下使用report函数进行数据上报会丢失30%左右的数据，也就是说，report函数并不是每一次都成功发起了HTTP请求。丢失数据的原因是img是report函数中的局部变量，当report函数的调用结束后，img局部变量随即被销毁，而此时或许还没来得及发出HTTP请求，所以此次请求就会丢失掉。 现在我们把img变量用闭包封闭起来，便能解决请求丢失的问题： var report = (function(){ var imgs = []; return function( src ){ var img = new Image(); imgs.push( img ); img.src = src; } })(); 闭包和面向对象设计 过程与数据的结合是形容面向对象中的“对象”时经常使用的表达。 对象以方法的形式包含了过程，而闭包则是在过程中以环境的形式包含了数据。 通常用面向对象思想能实现的功能，用闭包也能实现。反之亦然。 闭包的写法 var extent = function(){ var value = 0; return { call: function(){ value++; console.log( value ); } } }; var extent = extent(); extent.call(); // 输出：1 extent.call(); // 输出：2 extent.call(); // 输出：3 换成面向对象的写法，代码如下 var extent = { value: 0, call: function(){ this.value++; console.log( this.value ); } }; extent.call(); // 输出：1 extent.call(); // 输出：2 extent.call(); // 输出：3 闭包与this 在闭包中使用this对象也可能会导致一些问题。我们知道，this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，而当函数被作为某个对象的方法调用时，this等于那个对象。不过，匿名函数的执行环境具有全局性，因此其this对象通常指向window1。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。下面来看一个例子。 [注意]在通过call()或apply()改变函数执行环境的情况下，this就会指向其他对象。 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ return function(){ return this.name; }; } }; alert(object.getNameFunc()()); //\"The Window\"（在非严格模式下） 以上代码先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含一个方法——getNameFunc()，它返回一个匿名函数，而匿名函数又返回this.name。由于getNameFunc()返回一个函数，因此调用object.getNameFunc()()就会立即调用它返回的函数，结果就是返回一个字符串。然而，这个例子返回的字符串是\"The Window\"，即全局name变量的值。为什么匿名函数没有取得其包含作用域（或外部作用域）的this对象呢？ 因为每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量；不过，把外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了，如下所示。 var name = \"The Window\"; var object = { name : \"My Object\", getNameFunc : function(){ var that = this; return function(){ return that.name; }; } }; alert(object.getNameFunc()()); //\"My Object\" 闭包与内存管理 闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非JavaScript的问题。在IE浏览器中，由于BOM和DOM中的对象是使用C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为null即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 闭包关联关键词 1、变量的作用域2、函数像一层半透明的玻璃3、闭包经典案例：for循环中i值的获取4、闭包作用：1封装变量 2延续局部变量的寿命(图片ping案例)5、闭包与面向对象6、闭包与内存管理 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:27:08 "},"JavaScriptIIEF模仿块级作用域.html":{"url":"JavaScriptIIEF模仿块级作用域.html","title":"JavaScript IIEF 模仿块级作用域","keywords":"","body":"前言 JavaScript没有块级作用域的概念。但是通过IIEF 立即执行函数我们可以实现块级作用域。 function outputNumbers(count){ for (var i=0; i 这个函数中定义了一个for循环，而变量i的初始值被设置为0。在Java、C++等语言中，变量i只会在for循环的语句块中有定义，循环一旦结束，变量i就会被销毁。 可是在JavaScrip中，变量i是定义在ouputNumbers()的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。 即使像下面这样错误地重新声明同一个变量，也不会改变它的值。 function outputNumbers(count){ for (var i=0; i JavaScript从来不会告诉你是否多次声明了同一个变量；遇到这种情况，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。 用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示。 (function(){ //这里是块级作用域 })(); 以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。 现在对上面的函数进行改造 function outputNumbers(count){ (function () { for (var i=0; i 在这个重写后的outputNumbers()函数中，我们在for循环外部插入了一个私有作用域。在匿名函数中定义的任何变量，都会在执行结束时被销毁。因此，变量i只能在循环中使用，使用后即被销毁。 这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。例如： (function(){ var now = new Date(); if (now.getMonth() == 0 && now.getDate() == 1){ alert(\"Happy new year!\"); } })(); [注意]这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。 小结 随着ES6的普及，现在IIEF的使用的越来越少了，此语法了解即可，拥抱未来，毕竟语言是在进步的。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:27:51 "},"JavaScript函数递归.html":{"url":"JavaScript函数递归.html","title":"JavaScript 函数递归","keywords":"","body":"递归函数 递归函数是在一个函数通过名字调用自身的情况下构成的 项目中例如树状结构渲染，对象深复制，等很多方面都会使用到递归函数 function factorial(num){ if (num 非严格模式下还可以使用arguments.callee function factorial(num){ if (num [注意]arguments.callee === factorial === 函数本身 对象深复制(简单版) function deepClone(obj) { // 判断是不是对象 function isObject(o) { return (typeof o === 'object' || typeof o === 'function') && o !== null } // 不是对象的话报错 if (!isObject(obj)) { throw new Error('非对象') } let isArray = Array.isArray(obj) let newObj = isArray ? [...obj] : { ...obj } // 是数组的话 用数组的解构来实现对象的复制，对象也同理 // 静态方法 Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组 Reflect.ownKeys(newObj).forEach(key => { newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key] // 这里进行递归实现多层对象的复制 }) return newObj } 小结 通过本文我们学习了什么是递归，以及递归在项目中的使用，并且有一点一定要注意，递归函数一定要有终止条件不然会导致栈溢出。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:29:26 "},"JavaScript函数式编程.html":{"url":"JavaScript函数式编程.html","title":"函数式编程","keywords":"","body":"参考文献 我眼中的 JavaScript 函数式编程 JavaScript 函数式编程（一） JavaScript函数式编程（一） 征服 JavaScript 面试: 什么是函数式编程？| Eric Elliott 函数式编程基础概念 什么是函数式编程？ 什么是纯函数 基本的函数式编程 链式优化 常见的函数式编程模型 闭包（Closure） 高阶函数 柯里化（Currying） 组合（Composing） Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 14:57:43 "},"事件.html":{"url":"事件.html","title":"事件","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:29:39 "},"javaScript事件机制深入学习事件冒泡，事件捕获，事件绑定方式，移除事件方式，阻止浏览器默认.html":{"url":"javaScript事件机制深入学习事件冒泡，事件捕获，事件绑定方式，移除事件方式，阻止浏览器默认.html","title":"javaScript事件机制深入学习(事件冒泡，事件捕获，事件绑定方式，移除事件方式，阻止浏览器默认","keywords":"","body":"前言 JavaScript与HTML之间的交互是通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器（或处理程序）来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型，支持页面的行为（JavaScript代码）与页面的外观（HTML和CSS代码）之间的松散耦合。 事件处理程序 事件就是用户或浏览器自身执行的某种动作。诸如 click、load 和 mouseover，都是事件的名字。 而响应某个事件的函数就叫做事件处理程序(或事件侦听器)。 【HTML 事件处理程序】 [注]html中定义的事件有权访问全局作用域中的任何代码，例如外部引入的JS文件 [注]this值等于事件的目标元素 【DOM0级事件处理程序】 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ alert(\"Clicked\"); }; 使用DOM0级方法指定的事件处理程序被认为是元素的方法。因此，这时候的事件处理程序是在元素的作用域中运行; var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ alert(this.id); //\"myBtn\" }; this指向当前元素 【删除DOM0级元素】 btn.onclick = null; //删除事件处理程序 【DOM2级事件处理程序】 “DOM2级事件”定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()。接受3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 var btn = document.getElementById(\"myBtn\"); btn.addEventListener(\"click\", function(){ alert(this.id); }, false); 使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。来看下面的例子。 var btn = document.getElementById(\"myBtn\"); btn.addEventListener(\"click\", function(){ alert(this.id); }, false); btn.addEventListener(\"click\", function(){ alert(\"Hello world!\"); }, false); 【DOM2级事件移除方式】 var btn = document.getElementById(\"myBtn\"); btn.addEventListener(\"click\", function(){ alert(this.id); }, false); btn.removeEventListener(\"click\", function(){ alert(this.id); }, false); // 这样做是没有用的。。。 var btn = document.getElementById(\"myBtn\"); var handler = function(){ alert(this.id); }; btn.addEventListener(\"click\", handler, false); //这里省略了其他代码 btn.removeEventListener(\"click\", handler, false); //有效！ [兼容]IE9、Firefox、Safari、Chrome和Opera支持DOM2级事件处理程序 【IE事件处理程序】 IE实现了与DOM中类似的两个方法：attachEvent()和detachEvent()。这两个方法接受相同的两个参数：事件处理程序名称与事件处理程序函数。由于IE8及更早版本只支持事件冒泡，所以通过attachEvent()添加的事件处理程序都会被添加到冒泡阶段。 var btn = document.getElementById(\"myBtn\"); btn.attachEvent(\"onclick\", function(){ alert(\"Clicked\"); }); [注意]attachEvent()的第一个参数是\"onclick\"，而非DOM的addEventListener()方法中的\"click\"。 在IE中使用attachEvent()与使用DOM0级方法的主要区别在于事件处理程序的作用域。在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent()方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。来看下面的例子。 var btn = document.getElementById(\"myBtn\"); btn.attachEvent(\"onclick\", function(){ alert(this === window); //true }); [注意]牢记attachEvent绑定事件中的this === window 对于编写跨浏览器应用非常有帮助 【attachEvent绑定多个事件触发顺序是反的】 var btn = document.getElementById(\"myBtn\"); btn.attachEvent(\"onclick\", function(){ alert(\"Clicked\"); }); btn.attachEvent(\"onclick\", function(){ alert(\"Hello world!\"); }); 结果是先弹出\"Hello world!\",然后才是\"Clicked\" 【移除IE事件】 var btn = document.getElementById(\"myBtn\"); var handler = function(){ alert(\"Clicked\"); }; btn.attachEvent(\"onclick\", handler); //这里省略了其他代码 btn.detachEvent(\"onclick\", handler); [兼容] 支持IE事件处理程序的浏览器有IE和Opera。 跨浏览器兼容的事件处理 var EventUtil = { addHandler: function(element, type, handler){ if (element.addEventListener){ element.addEventListener(type, handler, false); } else if (element.attachEvent){ element.attachEvent(\"on\" + type, handler); } else { element[\"on\" + type] = handler; } }, removeHandler: function(element, type, handler){ if (element.removeEventListener){ element.removeEventListener(type, handler, false); } else if (element.detachEvent){ element.detachEvent(\"on\" + type, handler); } else { element[\"on\" + type] = null; } } }; addHandler()和removeHandler()没有考虑到所有的浏览器问题，例如在IE中的作用域问题。不过，使用它们添加和移除事件处理程序还是足够了。此外还要注意，DOM0级对每个事件只支持一个事件处理程序。好在，只支持DOM0级的浏览器已经没有那么多了，因此这对你而言应该不是什么问题。 事件流 如果你单击了某个按钮，他们都认为单击事件不仅仅发生在按钮上。换句话说，在单击按钮的同时，你也单击了按钮的容器元素，甚至也单击了整个页面。 事件流描述的是从页面中接收事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了差不多是完全相反的事件流的概念。IE的事件流是事件冒泡流，而Netscape Communicator的事件流是事件捕获流。 事件冒泡 IE的事件流叫做事件冒泡（event bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。 click事件首先在元素上发生，而这个元素就是我们单击的元素。然后，click事件沿DOM树向上传播，在每一级节点上都会发生，直至传播到document对象。图片展示了事件冒泡的过程 [注意]所有现代浏览器都支持事件冒泡，但在具体实现上还是有一些差别。IE5.5及更早版本中的事件冒泡会跳过元素（从直接跳到document）。IE9、Firefox、Chrome和Safari则将事件一直冒泡到window对象。 事件捕获 事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 在事件捕获过程中，document对象首先接收到click事件，然后事件沿DOM树依次向下，一直传播到事件的实际目标，即\\元素。图片展示了事件捕获的过程。 [兼容]由于老版本的浏览器不支持(IE8-)，因此很少有人使用事件捕获。 DOM事件流 “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。 在DOM事件流中，实际的目标（元素）在捕获阶段不会接收到事件。这意味着在捕获阶段，事件从document到再到后就停止了。下一个阶段是“处于目标”阶段，于是事件在上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回文档。 多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera 9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。 [兼容]IE9、Opera、Firefox、Chrome和Safari都支持DOM事件流；IE8及更早版本不支持DOM事件流。 事件的 Event 对象 在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持event对象，但支持方式不同。 兼容DOM的浏览器会将一个event对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0级或DOM2级），都会传入event对象。 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(event){ alert(event.type); //\"click\" }; btn.addEventListener(\"click\", function(event){ alert(event.type); //\"click\" }, false); event对象表 属性/方法 类　　型 读/写 说　　明 bubbles Boolean 只读 表明事件是否冒泡 cancelable Boolean 只读 表明是否可以取消事件的默认行为 currentTarget Element 只读 其事件处理程序当前正在处理事件的那个元素 defaultPrevented Boolean 只读 为true表示已经调用了preventDefault()（DOM3级事件中新增） detail Integer 只读 与事件相关的细节信息 eventPhase Integer 只读 调用事件处理程序的阶段：1表示捕获阶段，2表示“处于目标”，3表示冒泡阶段 preventDefault() Function 只读 取消事件的默认行为。如果cancelable是true，则可以使用这个方法 stopImmediatePropagation() Function 只读 取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（DOM3级事件中新增） stopPropagation() Function 只读 取消事件的进一步捕获或冒泡。如果bubbles为true，则可以使用这个方法 target Element 只读 事件的目标 trusted Boolean 只读 为true表示事件是浏览器生成的。为false表示事件是由开发人员通过JavaScript创建的（DOM3级事件中新增） type String 只读 被触发的事件的类型 view AbstractView 只读 与事件关联的抽象视图。等同于发生事件的window对象 在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。如果直接将事件处理程序指定给了目标元素，则this、currentTarget和target包含相同的值。来看下面的例子。 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(event){ alert(event.currentTarget === this); //true alert(event.target === this); //true }; [注]target是click事件的真正目标，例如再document.body中注册事件，但是在界面点击的是btn，target则会等于btn 【阻止浏览器的默认行为】 event.preventDefault(); [注]只有cancelable属性设置为true的事件，才可以使用preventDefault()来取消其默认行为。 【阻止事件冒泡和捕获】event.stopPropagation(); var btn = document.getElementById(\"myBtn\"); btn.onclick = function(event){ alert(\"Clicked\"); event.stopPropagation(); }; document.body.onclick = function(event){ alert(\"Body clicked\"); }; 这样在body上面注册的事件则不会发生 【eventPhase事件处理程序的阶段】 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(event){ alert(event.eventPhase); //2 目标阶段 }; document.body.addEventListener(\"click\", function(event){ alert(event.eventPhase); //1 捕获阶段 }, true); document.body.onclick = function(event){ alert(event.eventPhase); //3 冒泡阶段 }; [注]只有在事件处理程序执行期间，event对象才会存在；一旦事件处理程序执行完成，event对象就会被销毁。 IE中的事件对象 【IE中获取事件对象】 DOM0级绑定：通过window获取event对象 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ var event = window.event; alert(event.type); //\"click\" }; DOM2级事件：即可通过window获取也可通过参数传入获取 var btn = document.getElementById(\"myBtn\"); btn.attachEvent(\"onclick\", function(event){ alert(event.type); //\"click\" }); HTML中指定事件程序：则是通过event对象获取 IE的event对象同样也包含与创建它的事件相关的属性和方法。其中很多属性和方法都有对应的或者相关的DOM属性和方法。与DOM的event对象一样，这些属性和方法也会因为事件类型的不同而不同，但所有事件对象都会包含下表所列的属性和方法。 属性/方法 类　　型 读/写 说　　明 cancelBubble Boolean 读/写 默认值为false，但将其设置为true就可以取消事件冒泡（与DOM中的stopPropagation()方法的作用相同） returnValue Boolean 读/写 默认值为true，但将其设置为false就可以取消事件的默认行为（与DOM中的preventDefault()方法的作用相同） srcElement Element 只读 事件的目标（与DOM中的target属性相同） type String 只读 被触发的事件的类型 因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。故而，最好还是使用event.srcElement比较保险 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ alert(window.event.srcElement === this); //true }; btn.attachEvent(\"onclick\", function(event){ alert(event.srcElement === this); //通过attachEvent绑定事件时this === window 所以不等于event.srcElement }); 【IE中阻止浏览器默认行为】 var link = document.getElementById(\"myLink\"); link.onclick = function(){ window.event.returnValue = false; }; 【IE中阻止事件冒泡】window.event.cancelBubble = true; var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ alert(\"Clicked\"); window.event.cancelBubble = true; }; document.body.onclick = function(){ alert(\"Body clicked\"); }; 跨浏览器的事件对象兼容 var EventUtil = { getEvent: function(event){ return event ? event : window.event; }, getTarget: function(event){ return event.target || event.srcElement; }, preventDefault: function(event){ if (event.preventDefault){ event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function(event){ if (event.stopPropagation){ event.stopPropagation(); } else { event.cancelBubble = true; } } }; 事件的内存和性能 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。导致这一问题的原因是多方面的。首先，每个函数都是对象，都会占用内存；内存中的对象越多，性能就越差。 【事件委托】 对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。例如，click事件会一直冒泡到document层次。也就是说，我们可以为整个页面指定一个onclick事件处理程序，而不必给每个可单击的元素分别添加事件处理程序。 Go somewhere Do something Say hi 为3个li都添加相应的点击事件，这样会导致性能更差，我们可以只在ul上面添加一个点击事件，利用冒泡原理来处理事件 var list = document.getElementById(\"myLinks\"); EventUtil.addHandler(list, \"click\", function(event){ event = EventUtil.getEvent(event); var target = EventUtil.getTarget(event); switch(target.id){ case \"doSomething\": document.title = \"I changed the document's title\"; break; case \"goSomewhere\": location.href = \"http://www.wrox.com\"; break; case \"sayHi\": alert(\"hi\"); break; } }); 在页面中设置事件处理程序所需的时间更少。只添加一个事件处理程序所需的DOM引用更少，所花的时间也更少。 整个页面占用的内存空间更少，能够提升整体性能。 【移除事件处理程序】 每当将事件处理程序指定给元素时，运行中的浏览器代码与支持页面交互的JavaScript代码之间就会建立一个连接。这种连接越多，页面执行起来就越慢。在不需要的时候移除事件处理程序，也是解决这个问题的一种方案。内存中留有那些过时不用的“空事件处理程序”（dangling event handler），也是造成Web应用程序内存与性能问题的主要原因。 在两种情况下，可能会造成上述问题。第一种情况就是从文档中移除带有事件处理程序的元素时。这可能是通过纯粹的DOM操作，例如使用removeChild()和replaceChild()方法，但更多地是发生在使用innerHTML替换页面中某一部分的时候。如果带有事件处理程序的元素被innerHTML删除了，那么原来添加到元素中的事件处理程序极有可能无法被当作垃圾回收。来看下面的例子。 var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ //先执行某些操作 document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; //麻烦了！ }; 这里，有一个按钮被包含在\\元素中。为避免双击，单击这个按钮时就将按钮移除并替换成一条消息；这是网站设计中非常流行的一种做法。但问题在于，当按钮被从页面中移除时，它还带着一个事件处理程序呢。如果你知道某个元素即将被移除，那么最好手工移除事件处理程序. var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){ //先执行某些操作 btn.onclick = null; //移除事件处理程序 document.getElementById(\"myDiv\").innerHTML = \"Processing...\"; }; [注意]在事件处理程序中删除按钮也能阻止事件冒泡。目标元素在文档中是事件冒泡的前提。 模拟事件 事件经常由用户操作或通过其他浏览器功能来触发。但很少有人知道，也可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样。也就是说，这些事件该冒泡还会冒泡，而且照样能够导致浏览器执行已经指定的处理它们的事件处理程序。在测试Web应用程序，模拟触发事件是一种极其有用的技术。DOM2级规范为此规定了模拟特定事件的方式，IE9、Opera、Firefox、Chrome和Safari都支持这种方式。IE有它自己模拟事件的方式。 【DOM中的事件模拟】可以在document对象上使用createEvent()方法创建event对象。这个方法接收一个参数，即表示要创建的事件类型的字符串。在DOM2级中，所有这些字符串都使用英文复数形式，而在DOM3级中都变成了单数。这个字符串可以是下列几字符串之一。 UIEvents：一般化的UI事件。鼠标事件和键盘事件都继承自UI事件。DOM3级中是UIEvent。 MouseEvents：一般化的鼠标事件。DOM3级中是MouseEvent。 MutationEvents：一般化的DOM变动事件。DOM3级中是MutationEvent。 HTMLEvents：一般化的HTML事件。没有对应的DOM3级事件（HTML事件被分散到其他类别中）。 模拟事件的最后一步就是触发事件。这一步需要使用dispatchEvent()方法，所有支持事件的DOM节点都支持这个方法。调用dispatchEvent()方法时，需要传入一个参数，即表示要触发事件的event对象。触发事件之后，该事件就跻身“官方事件”之列了，因而能够照样冒泡并引发相应事件处理程序的执行。 【模拟鼠标事件】创建新的鼠标事件对象并为其指定必要的信息，就可以模拟鼠标事件。创建鼠标事件对象的方法是为createEvent()传入字符串\"MouseEvents\"。返回的对象有一个名为initMouseEvent()方法，用于指定与该鼠标事件有关的信息。这个方法接收15个参数，分别与鼠标事件中每个典型的属性一一对应；这些参数的含义如下。 type（字符串）：表示要触发的事件类型，例如\"click\"。 bubbles（布尔值）：表示事件是否应该冒泡。为精确地模拟鼠标事件，应该把这个参数设置为true。 cancelable（布尔值）：表示事件是否可以取消。为精确地模拟鼠标事件，应该把这个参数设置为true。 view（AbstractView）：与事件关联的视图。这个参数几乎总是要设置为document.defaultView。 detail（整数）：与事件有关的详细信息。这个值一般只有事件处理程序使用，但通常都设置为0。 screenX（整数）：事件相对于屏幕的X坐标。 screenY（整数）：事件相对于屏幕的Y坐标。 clientX（整数）：事件相对于视口的X坐标。 clientY（整数）：事件想对于视口的Y坐标。 ctrlKey（布尔值）：表示是否按下了Ctrl键。默认值为false。 altKey（布尔值）：表示是否按下了Alt键。默认值为false。 shiftKey（布尔值）：表示是否按下了Shift键。默认值为false。 metaKey（布尔值）：表示是否按下了Meta键。默认值为false。 button（整数）：表示按下了哪一个鼠标键。默认值为0。 relatedTarget（对象）：表示与事件相关的对象。这个参数只在模拟mouseover或mouseout时使用。 显而易见，initMouseEvent()方法的这些参数是与鼠标事件的event对象所包含的属性一一对应的。其中，前4个参数对正确地激发事件至关重要，因为浏览器要用到这些参数；而剩下的所有参数只有在事件处理程序中才会用到。当把event对象传给dispatchEvent()方法时，这个对象的target属性会自动设置。下面，我们就通过一个例子来了解如何模拟对按钮的单击事件。 var btn = document.getElementById(\"myBtn\"); //创建事件对象 var event = document.createEvent(\"MouseEvents\"); //初始化事件对象 event.initMouseEvent(\"click\", true, true, document.defaultView, 0, 0, 0, 0, 0, false, false, false, false, 0, null); btn.onclick = function(event){ console.log(`${event.target.id}被点击了`); }; //触发事件 btn.dispatchEvent(event); 当然还可以模拟键盘事件等等...这里就不赘述了，如果有相应的需求可以查阅相关资料 【IE中的事件模拟】在IE8及之前版本中模拟事件与在DOM中模拟事件的思路相似：先创建event对象，然后为其指定相应的信息，然后再使用该对象来触发事件。当然，IE在实现每个步骤时都采用了不一样的方式。 调用document.createEventObject()方法可以在IE中创建event对象。但与DOM方式不同的是，这个方法不接受参数，结果会返回一个通用的event对象。然后，你必须手工为这个对象添加所有必要的信息（没有方法来辅助完成这一步骤）。最后一步就是在目标上调用fireEvent()方法，这个方法接受两个参数：事件处理程序的名称和event对象。在调用fireEvent()方法时，会自动为event对象添加srcElement和type属性；其他属性则都是必须通过手工添加的。换句话说，模拟任何IE支持的事件都采用相同的模式。例如，下面的代码模拟了在一个按钮上触发click事件过程。 var btn = document.getElementById(\"myBtn\"); //创建事件对象 var event = document.createEventObject(); //初始化事件对象 event.screenX = 100; event.screenY = 0; event.clientX = 0; event.clientY = 0; event.ctrlKey = false; event.altKey = false; event.shiftKey = false; event.button = 0; //触发事件 btn.fireEvent(\"onclick\", event); 【自定义DOM事件】DOM3级还定义了“自定义事件”。自定义事件不是由DOM原生触发的，它的目的是让开发人员创建自己的事件。要创建新的自定义事件，可以调用createEvent(\"CustomEvent\")。返回的对象有一个名为initCustomEvent()的方法，接收如下4个参数。 type（字符串）：触发的事件类型，例如\"keydown\"。 bubbles（布尔值）：表示事件是否应该冒泡。 cancelable（布尔值）：表示事件是否可以取消。 detail（对象）：任意值，保存在event对象的detail属性中。 示例 var div = document.getElementById(\"myDiv\"), event; EventUtil.addHandler(div, \"myevent\", function(event){ alert(\"DIV: \" + event.detail); }); EventUtil.addHandler(document, \"myevent\", function(event){ alert(\"DOCUMENT: \" + event.detail); }); if (document.implementation.hasFeature(\"CustomEvents\", \"3.0\")){ event = document.createEvent(\"CustomEvent\"); event.initCustomEvent(\"myevent\", true, false, \"Hello world!\"); div.dispatchEvent(event); } [兼容]支持自定义DOM事件的浏览器有IE9+和Firefox 6+ 小结 通过本文 我们学习了事件流，冒泡，目标阶段，捕获； 事件处理程序，HTML处理，DOM0，DOM2级事件处理方式； 事件对象，常用的属性，例如阻止冒泡，阻止浏览器的默认事件发生，已经事件对象的兼容性 事件的内存和性能文件，例如采用“事件委托”的方式来提升性能 最后我们学习了如何模拟HTML事件，以及模拟自定义事件的方法 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:34:40 "},"[浏览器事件循环]javaScript事件循环EventLoop.html":{"url":"[浏览器事件循环]javaScript事件循环EventLoop.html","title":"[浏览器事件循环] javaScript事件循环 EventLoop","keywords":"","body":"前言 Event Loop即事件循环，是指浏览器或Node的一种解决javaScript单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。 先熟悉基本概念 【堆Heap】 堆是一种数据结构，是利用完全二叉树维护的一组数据，堆分为两种，一种为最大堆，一种为最小堆，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。 堆是线性数据结构，相当于一维数组，有唯一后继。 【栈Stack】栈在计算机科学中是限定仅在表尾进行插入或删除操作的线性表。 栈是一种数据结构，它按照后进先出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据。 栈是只能在某一端插入和删除的特殊线性表。 【队列Queue】特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。 进行插入操作的端称为队尾，进行删除操作的端称为队头。 队列中没有元素时，称为空队列。 【进程】进程是系统分配的独立资源，是 CPU 资源分配的基本单位，进程是由一个或者多个线程组成的。 【线程】线程是进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。 把这些概念拿到浏览器中来说，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。 浏览器内核 浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程（也不一定，因为多个空白 tab 标签会合并成一个进程），浏览器内核（浏览器渲染进程）属于浏览器多进程中的一种。 浏览器内核有多种线程在工作。 【GUI 渲染线程】负责渲染页面，解析 HTML，CSS 构成 DOM 树等，当页面重绘或者由于某种操作引起回流都会调起该线程。 和 JS 引擎线程是互斥的，当 JS 引擎线程在工作的时候，GUI 渲染线程会被挂起，GUI 更新被放入在 JS 任务队列中，等待 JS 引擎线程空闲的时候继续执行。 【JS 引擎线程】单线程工作，负责解析运行 JavaScript 脚本。 和 GUI 渲染线程互斥，JS 运行耗时过长就会导致页面阻塞。 【事件触发线程】当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待 JS 引擎处理。 【定时器触发线程】浏览器定时计数器并不是由 JS 引擎计数的，阻塞会导致计时不准确。 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 JS 引擎处理。 【http 请求线程】http 请求的时候会开启一条请求线程。 请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 JS 引擎处理。 基础知识我们基本了解了些必要的，下面我们开始介绍Event Loop js中的任务分类 任务被分为两种，一种宏任务（MacroTask）也叫Task，一种叫微任务（MicroTask） 也叫jobs 【MacroTask（宏任务）】类型：script全部代码、setTimeout、setInterval、setImmediate、I/O、UI Rendering 【MicroTask（微任务）】类型：Process.nextTick（Node独有）、Promise 、MutationObserver Event Loop 目前讨论的两种情况：浏览器的Event Loop 以及Node中的Event Loop 浏览器中的Event Loop Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。 【JS调用栈】JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空。 【同步任务和异步任务】Javascript单线程任务被分为同步任务和异步任务，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行。 浏览器进行事件循环工作方式 1、选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即null，则执行跳转到微任务（MicroTask）的执行步骤。 2、将事件循环中的任务设置为已选择任务。 3、执行任务。 4、将事件循环中当前运行任务设置为null。 5、将已经运行完成的任务从任务队列中删除。 6、microtasks步骤：进入microtask检查点。 7、更新界面渲染。 8、返回第一步。 【执行进入microtask检查点时，浏览器会执行以下步骤：】 设置microtask检查点标志为true。 当事件循环microtask执行不为空时：选择一个最先进入的microtask队列的microtask，将事件循环的microtask设置为已选择的microtask，运行microtask，将已经执行完成的microtask为null，移出microtask中的microtask。 清理IndexDB事务 设置进入microtask检查点的标志为false。 【重点】总结以上规则为一条通俗好理解的： 1、顺序执行先执行同步方法，碰到MacroTask直接执行，并且把回调函数放入MacroTask执行队列中（下次事件循环执行）；碰到microtask直接执行。把回调函数放入microtask执行队列中（本次事件循环执行） 2、当同步任务执行完毕后，去执行微任务microtask。（microtask队列清空） 3、由此进入下一轮事件循环：执行宏任务 MacroTask （setTimeout，setInterval，callback） [总结]所有的异步都是为了按照一定的规则转换为同步方式执行。 查看一个示例 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); 1、一开始task队列中只有script，则script中所有函数放入函数执行栈执行，代码按顺序执行。 2、接着遇到了setTimeout,它的作用是0ms后将回调函数放入task队列中，也就是说这个函数将在下一个事件循环中执行（注意这时候setTimeout执行完毕就返回了）。 3、接着遇到了Promise，按照前面所述Promise属于microtask，所以第一个.then()会放入microtask队列。 4、当所有script代码执行完毕后，此时函数执行栈为空。 5、开始检查microtask队列，此时队列不为空,执行.then()的回调函数输出'promise1'，由于.then()返回的依然是promise,所以第二个.then()会放入microtask队列继续执行,输出'promise2'。此时microtask队列为空了 6、进入下一个事件循环，检查task队列发现了setTimeout的回调函数，立即执行回调函数输出'setTimeout'，代码执行完毕。 小结 基本上能理解这个例子的话，对于浏览器的事件循环应该已经可以理解的差不多了。由于本篇文章涉及的知识点比较多，不易篇幅太长，至于node的事件循环方式则跟浏览器的实现方式不太一样。所以后面会在总结一篇文章 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:38:51 "},"BOM.html":{"url":"BOM.html","title":"BOM","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:39:03 "},"客户端检测.html":{"url":"客户端检测.html","title":"客户端检测","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:39:20 "},"DOM.html":{"url":"DOM.html","title":"DOM","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:39:34 "},"元素尺寸.html":{"url":"元素尺寸.html","title":"元素尺寸","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:39:45 "},"表单脚本.html":{"url":"表单脚本.html","title":"表单脚本","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:39:59 "},"脚本化CSS.html":{"url":"脚本化CSS.html","title":"脚本化css","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:40:11 "},"HTML5新特性.html":{"url":"HTML5新特性.html","title":"HTML5新特性","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-02 20:40:23 "},"javaScriptdrag对象进行拖拽使用详解.html":{"url":"javaScriptdrag对象进行拖拽使用详解.html","title":"javaScript drag对象进行拖拽使用详解","keywords":"","body":"drag简介 HMTL5提供的支持原生拖拽的实现 兼容性如何？ 桌面端的支持比较好，移动端的支持还是比较差 拖拽流程 设置可拖拽目标.设置属性draggable=\"true\"实现元素的可拖拽(文本、图片和链接是默认可以拖放的，它们的draggable属性自动被设置成了true。) 监听dragstart，通过DataTransfer设置拖拽数据 为拖拽操作设置反馈图标(可选) 设置允许的拖放效果，如copy,move,link 设置拖放目标，默认情况下浏览器阻止所有的拖放操作，所以需要监听dragenter或者dragover取消浏览器默认行为使元素可拖放. 监听drop事件执行所需操作 drag事件 dragstart：在元素开始被拖动时候触发 drag：在元素被拖动时反复触发（可以在此处节流） dragend：在拖动操作完成时触发 dragenter：当被拖动元素进入目的地元素所占据的屏幕空间时触发 dragover：当被拖动元素在目的地元素内时触发 dragleave：当被拖动元素没有放下就离开目的地元素时触发 DataTransfer对象 在进行拖放操作时，DataTransfer 对象用来保存，通过拖放动作，拖动到浏览器的数据。它可以保存一项或多项数据、一种或者多种数据类型。 e.dataTransfer.files 包含一个在数据传输上所有可用的本地文件列表。如果拖动操作不涉及拖动文件，此属性是一个空列表。 e.dataTransfer.types 保存一个被存储数据的类型列表作为第一项，顺序与被添加数据的顺序一致。 DataTransfer-MDN 从操作系统拖拽图片到指定区域进行预览 从操作系统拖拽文件到浏览器中.不会触发dragstart,dragend,只需取消拖放区域的默认行为,设置反馈,并在拖放发生时取消浏览器默认行为,通过e.dataTransfer.files获取文件信息进行操作 从文件夹中拖拽图片到下面的区域进行预览 #demo2 { margin: 20px; } #demo2 .preview { height: 300px; background: #ddd; } #demo2 li { float: left; margin-left: 40px; } #demo2 img { max-height: 150px; width: auto; } (function (w) { var doc = w.document; var dnd = { init: function () { var me = this; var preview = doc.querySelector('#demo2 .preview'); preview.addEventListener('dragover', function (e) { e.preventDefault(); }, false); preview.addEventListener('drop', function (e) { // 操作系统拖放文件到浏览器需要取消默认行为 e.preventDefault(); [].forEach.call(e.dataTransfer.files, function (file) { if (file && file.type.match('image.*')) { var reader = new FileReader(); reader.onload = function (e) { var img = doc.createElement('img'); img.src = e.target.result; var li = doc.createElement('li'); li.appendChild(img); preview.appendChild(li); }; reader.readAsDataURL(file); } }); }, false); } }; dnd.init(); }(window)); drag实例 This div is draggable #draggable { width: 200px; height: 20px; text-align: center; background: white; } .dropzone { width: 200px; height: 20px; background: blueviolet; margin-bottom: 10px; padding: 10px; } var dragged; /* 拖动目标元素时触发drag事件 */ document.addEventListener(\"drag\", function( event ) { }, false); document.addEventListener(\"dragstart\", function( event ) { // 保存拖动元素的引用(ref.) dragged = event.target; // 使其半透明 event.target.style.opacity = .5; }, false); document.addEventListener(\"dragend\", function( event ) { // 重置透明度 event.target.style.opacity = \"\"; }, false); /* 放置目标元素时触发事件 */ document.addEventListener(\"dragover\", function( event ) { // 阻止默认动作以启用drop event.preventDefault(); }, false); document.addEventListener(\"dragenter\", function( event ) { // 当可拖动的元素进入可放置的目标时高亮目标节点 if ( event.target.className == \"dropzone\" ) { event.target.style.background = \"purple\"; } }, false); document.addEventListener(\"dragleave\", function( event ) { // 当拖动元素离开可放置目标节点，重置其背景 if ( event.target.className == \"dropzone\" ) { event.target.style.background = \"\"; } }, false); document.addEventListener(\"drop\", function( event ) { // 阻止默认动作（如打开一些元素的链接） event.preventDefault(); // 将拖动的元素到所选择的放置目标节点中 if ( event.target.className == \"dropzone\" ) { event.target.style.background = \"\"; dragged.parentNode.removeChild( dragged ); event.target.appendChild( dragged ); } }, false); 小结 通过本章的学习，我们更深入的了解到如何使用drag进行拖放，并且通过dataTransfer获取拖放的相应数据。由于该对象的浏览器兼容还存在问题，所以在使用时务必查询的can i use，确保符合项目需求。否则可以选择 mouse事件进行拖拽处理 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:09:13 "},"错误处理与调试.html":{"url":"错误处理与调试.html","title":"错误处理与调试","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:09:42 "},"数据传递与格式.html":{"url":"数据传递与格式.html","title":"数据传递与格式","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:09:57 "},"Fetch入门教程.html":{"url":"Fetch入门教程.html","title":"Fetch 入门教程","keywords":"","body":"前言 Fetch API 提供了一个 JavaScript接口，用于访问和操纵HTTP管道的部分，例如请求和响应。它还提供了一个全局 fetch()方法，该方法提供了一种简单，合乎逻辑的方式来跨网络异步获取资源。本文将详细介绍fetch的相关内容 概述 　　跨网络异步获取资源的功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如 CORS和HTTP的扩展 　　fetch 规范与 jQuery.ajax() 主要有两种方式的不同 　　1、当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）， 仅当网络故障时或请求被阻止时，才会标记为 reject 　　2、默认情况下, fetch 不会从服务端发送或接收任何 cookies，如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项） fetch请求 　　一个基本的 fetch请求设置起来很简单。这里我们通过网络获取一个图像并将其插入到一个 元素中。最简单的用法是只提供一个参数用来指明想fetch到的资源路径，然后返回一个包含响应结果的promise(一个 Response 对象) let myImage = document.querySelector('img'); fetch('flowers.jpg') .then(function(response) { return response.blob(); }) .then(function(myBlob) { let objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; }); 自定义参数 fetch() 接受第二个可选参数，一个可以控制不同配置的 init 对象： var myHeaders = new Headers(); var myInit = { method: 'GET', headers: myHeaders, mode: 'cors', cache: 'default' }; fetch('flowers.jpg',myInit) .then(function(response) { return response.blob(); }) .then(function(myBlob) { var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; }); post // 通过fetch获取百度的错误提示页面 fetch('https://www.baidu.com/search/error.html', { method: 'POST', body: JSON.stringify({a:1}), 　 headers: { ...new Headers(headers), 'Content-Type': 'application/json' } }) .then((res)=>{ return res.text() }) .then((res)=>{ console.log(res) }) JSON数据 var url = 'https://example.com/profile'; var data = {username: 'example'}; fetch(url, { method: 'POST', // or 'PUT' body: JSON.stringify(data), // data can be `string` or {object}! headers: new Headers({ 'Content-Type': 'application/json' }) }).then(res => res.json()) .catch(error => console.error('Error:', error)) .then(response => console.log('Success:', response)); 上传文件 可以通过HTML 元素，FormData() 和fetch()上传文件。 上传单个文件： var formData = new FormData(); var fileField = document.querySelector(\"input[type='file']\"); formData.append('username', 'abc123'); formData.append('avatar', fileField.files[0]); fetch('https://example.com/profile/avatar', { method: 'PUT', body: formData }) .then(response => response.json()) .catch(error => console.error('Error:', error)) .then(response => console.log('Success:', response)); 上传多个文件 var formData = new FormData(); var photos = document.querySelector(\"input[type='file'][multiple]\"); formData.append('title', 'My Vegas Vacation'); formData.append('photos', photos.files); fetch('https://example.com/posts', { method: 'POST', body: formData }) .then(response => response.json()) .then(response => console.log('Success:', JSON.stringify(response))) .catch(error => console.error('Error:', error)); 检测成功 　　如果遇到网络故障，fetch() promise 将会 reject，带上一个 TypeError 对象。虽然这个情况经常是遇到了权限问题或类似问题——比如 404 不是一个网络故障。想要精确的判断 fetch() 是否成功，需要包含 promise resolved 的情况，此时再判断 Response.ok 是不是为 true fetch('flowers.jpg').then(function(response) { if(response.ok) { response.blob().then(function(myBlob) { var objectURL = URL.createObjectURL(myBlob); myImage.src = objectURL; }); } else { console.log('Network response was not ok.'); } }) .catch(function(error) { console.log('There has been a problem with your fetch operation: ' + error.message); }); 强制发送cookie 为了让浏览器发送包含凭据的请求（即使是跨域源），要将credentials: 'include'添加到传递给 fetch()方法的init对象。 fetch('https://example.com', { credentials: 'include' }) 如果你只想在请求URL与调用脚本位于同一起源处时发送凭据，请添加credentials: 'same-origin'。 fetch('https://example.com', { credentials: 'same-origin' }) 要改为确保浏览器不在请求中包含凭据，请使用credentials: 'omit'。 fetch('https://example.com', { credentials: 'omit' }) Headers 　　使用 Headers 的接口，可以通过 Headers() 构造函数来创建一个自己的 headers 对象。一个 headers 对象是一个简单的多名值对： var content = \"Hello World\"; var myHeaders = new Headers(); myHeaders.append(\"Content-Type\", \"text/plain\"); myHeaders.append(\"Content-Length\", content.length.toString()); myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\"); 也可以传一个多维数组或者对象字面量： myHeaders = new Headers({ \"Content-Type\": \"text/plain\", \"Content-Length\": content.length.toString(), \"X-Custom-Header\": \"ProcessThisImmediately\", }); 它的内容可以被获取： console.log(myHeaders.has(\"Content-Type\")); // true console.log(myHeaders.has(\"Set-Cookie\")); // false myHeaders.set(\"Content-Type\", \"text/html\"); myHeaders.append(\"X-Custom-Header\", \"AnotherValue\"); console.log(myHeaders.get(\"Content-Length\")); // 11 console.log(myHeaders.getAll(\"X-Custom-Header\")); // [\"ProcessThisImmediately\", \"AnotherValue\"] myHeaders.delete(\"X-Custom-Header\"); console.log(myHeaders.getAll(\"X-Custom-Header\")); // [ ] 封装 下面是对fetch的一个简单的封装 function _fetch(url, data, method = 'GET',options={}) { const body = o2s(data); let params = { method: method, }; if (method === 'GET') { // 如果是GET请求，拼接url url += '?' + body; } else { params.body=body } if(options.cookie!=undefined){ params.credentials='include' } if(options.headers!=undefined && typeof options.headers==\"object\"){ params.headers=new Headers(options.headers); }else{ params.headers=new Headers({ 'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded' }); } fetch(url, params).then(r => options.dataType==\"text\"?r.text():r.json()).then(r => r); } export function o2s(obj, arr = [], idx = 0) { for (let item in obj) { arr[idx++] = [item, obj[item]]; } return new URLSearchParams(arr).toString(); } export function get(url, data,,options={}) { return _fetch(url, data, 'GET',options); } export function post(url, data,options={}) { return _fetch(url, data, 'POST',options); } post(\"/api/test\",{title:\"标题\"},{ dataType:\"json\", cookie:true, headers:{ 'Accept': 'application/json', 'Content-Type': 'application/x-www-form-urlencoded' } }); Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:11:42 "},"js文件上传原理（form表单，FormData+XHR2+FileReader+canvas）.html":{"url":"js文件上传原理（form表单，FormData+XHR2+FileReader+canvas）.html","title":"js文件上传原理（form表单 ，FormData + XHR2 + FileReader + canvas）","keywords":"","body":"目前实现上传的方式 浏览器小于等于IE9(低版本浏览器)使用下面的方式实现的 flash实现（主流插件的方式，本文不涉及） form + iframe（项目中很少用到，本文不涉及） form表单提交的方式是所有浏览器都支持的，借助iframe是为了实现不刷新界面上传 主流浏览器 + IE10+ 则是通过以下方式实现的上传 FormData + XHR2 + FileReader + canvas FormData介绍 FormData接口提供了一种轻松构造一组表示表单字段及其值的键/值对的方法，然后可以使用XMLHttpRequest.send()方法轻松地发送这些值。如果将编码类型设置为“multipart/form-data”，则使用与表单相同的格式。 常用方法： FormData.append(); // 添加键值对 FormData.delete(); // 删除键值对 FormData.entries(); // 返回允许遍历此对象中包含的所有键/值对的迭代器 ...具体还有很多方法可以参考网站：FormData XMLHttpRequest简介 使用XMLHttpRequest (XHR)对象可以与服务器交互。您可以从URL获取数据，而无需让整个的页面刷新。这使得Web页面可以只更新页面的局部，而不影响用户的操作。XMLHttpRequest在 Ajax 编程中被大量使用。 常用属性和方法 const xhr = new XMLHttpRequest() // 常用属性 xhr.onreadystatechange // 当readyState属性发生变化时调用的函数 xhr. readyState // 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 xhr.responseText // 包含对请求的响应，如果请求未成功或尚未发送，则返回null xhr.timeout // 表示该请求的最大请求时间（毫秒），超过该时间请求会自动结束。 xhr.upload // 表示上传过程。 // 常用方法 xhr.abort() // 中止请求 xhr.open() // 初始化一个请求。该方法只能JavaScript代码中使用 xhr.setRequestHeader() // 设置HTTP请求头的值 xhr.send() // 发送请求。如果请求是异步的（默认），那么该方法将在请求发送后立即返回 更多关于XMLHttpRequest的信息点击：XMLHttpRequest FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容，使用 File 或 Blob 对象指定要读取的文件或数据。 其中File对象可以是来自用户在一个元素上选择文件后返回的FileList对象,也可以来自拖放操作生成的 DataTransfer对象,还可以是来自在一个HTMLCanvasElement上执行mozGetAsFile()方法后返回结果。 属性： FileReader.error // 表示在读取文件时发生的错误 FileReader.readyState // 表示FileReader状态的数字。0:还没有加载任何数据; 1:数据正在被加载；2:已完成全部的读取请求 FileReader.result // 文件的内容。该属性仅在读取操作完成后才有效，数据的格式取决于使用哪个方法来启动读取操作。 事件处理 FileReader.onabort= ()=>{} // 该事件在读取操作被中断时触发 FileReader.onerror = ()=>{} // 该事件在读取操作发生错误时触发。 FileReader.onload = ()=>{} // 该事件在读取操作完成时触发。 FileReader.onloadstart = ()=>{} // 该事件在读取操作开始时触发 FileReader.onloadend = ()=>{} // 该事件在读取操作结束时（要么成功，要么失败）触发 FileReader.onprogress = ()=>{} // 该事件在读取Blob时触发 方法 FileReader.abort() // 中止读取操作。在返回时，readyState属性为DONE FileReader.readAsArrayBuffer() // 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象 FileReader.readAsDataURL() // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容 FileReader.readAsText() // 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 form表单上传 所有浏览器都支持的上传方式，且submit提交后页面会刷新。action: 提交地址enctype的常见类型(告诉服务器我们发送过去的数据是用哪种格式进行编码的) application/x-www-form-urlencoded (默认数据编码方式) multipart/form-data(复杂，但它允许在数据中包含整个文件，所以常用于文件上传) text/plain(一般用于debug) FormData + XHR2 + FileReader + canvas 【实现步骤】 监听一个input(type=‘file’)的onchange事件，这样获取到文件file； 将file转成dataUrl; 然后根据dataUrl利用canvas绘制图片压缩，然后再转成新的dataUrl； 再把dataUrl转成Blob； 把Blob append进FormData中； xhr实现上传。 HTML代码 1、监听input的change事件 function handleInputChange (event) { const file = event.target.files[0]; // 获取当前选中的文件 const imgMasSize = 1024 * 1024 * 10; // 限制大小10MB // 检查文件类型 if(['jpeg', 'png', 'gif', 'jpg'].indexOf(file.type.split(\"/\")[1]) imgMasSize ) { // 文件大小自定义限制 } // 图片压缩处理函数 transformFileToDataUrl(file); } 2、将file转成dataUrl function transformFileToDataUrl (file) { const imgCompassMaxSize = 200 * 1024; // 超过 200k 就压缩 // 存储文件相关信息 imgFile.type = file.type || 'image/jpeg'; imgFile.size = file.size; imgFile.name = file.name; imgFile.lastModifiedDate = file.lastModifiedDate; // 封装好的函数 const reader = new FileReader(); // file转dataUrl是个异步函数,onload表示读取完成了 reader.onload = function(e) { const result = e.target.result; if(result.length 3、canvas进行压缩的处理 function compress (dataURL, callback, shouldCompress = true) { const img = new window.Image(); // new 一个图片对象 img.src = dataURL; // 通过fileReader读取到的base64数据 img.onload = function () { // 1、创建canvas上下文 const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); // 获取图片宽高赋值给canvas绘图 canvas.width = img.width; canvas.height = img.height; // 绘制出一张canvas图片 ctx.drawImage(img, 0, 0, canvas.width, canvas.height); let compressedDataUrl; if(shouldCompress){ compressedDataUrl = canvas.toDataURL(imgFile.type, 0.2); // 后面的系数是绘图输出图片质量 } else { compressedDataUrl = canvas.toDataURL(imgFile.type, 1); // 不改变原图质量 } document.getElementById('preview').appendChild(img); callback(compressedDataUrl); // 最后图片压缩好后，去进行base64 -> blob的转换(传递到后台) } } 4、把Blob append进FormData中； function processData (dataURL) { const binaryString = window.atob(dataURL.split(',')[1]); // window.atob对用base-64编码过的字符串进行解码 const arrayBuffer = new ArrayBuffer(binaryString.length); // ArrayBuffer 对象用来表示通用的、固定长度的原始二进制数据缓冲区。ArrayBuffer 不能直接操作，而是要通过类型数组对象或 DataView 对象来操作，它们会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。 const intArray = new Uint8Array(arrayBuffer); // Uint8Array类型化数组表示一个由8位无符号整数组成的数组。内容初始化为0。一旦建立，您可以使用对象的方法或使用标准数组索引语法(即使用括号符号)引用数组中的元素。 for (let i = 0, j = binaryString.length; i 5、xhr实现上传 function uploadImg (formData) { const xhr = new XMLHttpRequest(); // 进度监听 xhr.upload.addEventListener('progress', (e)=>{ console.log(e, e.loaded , e.total); // 可以利用这两个对象算出目前的传输比例 }, false); xhr.onreadystatechange = function () { if (xhr.readyState === 4) { const result = JSON.parse(xhr.responseText); if (xhr.status === 200) { // 上传成功 console.log(result); } else { // 上传失败 } } }; xhr.open('POST', '/upload' , true); // 中间\"/upload\"为后台上传地址(如果需要兼容性强可以使用限制的ajax库) xhr.send(formData); // 发送到后台 } 代码github访问地址：上传实例代码 小结 通过本节内容，我们应该彻底的理解了前端上传是如何实现的，给出的代码实例虽然简单，但是已经是非常核心，我们可以通过这个版本去实现一个非常复杂的需求，譬如多图片上传，那么也就是遍历的调用transformFileToDataUrl这个方法去实现。在例如添加上拖拽文件到指定区域去上传，那么我们只需要了解下drag对象就可以很轻松的实现了。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 10:54:50 "},"axios入门教程.html":{"url":"axios入门教程.html","title":"axios 入门教程","keywords":"","body":"参考文献 官网api 什么是axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特性 从浏览器中创建XMLHttpRequests 从 node.js 创建http请求 支持PromiseAPI 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御XSRF 浏览器支持 安装 npm install axios bower install axios config 这些是创建请求时可以用的配置选项。只有url是必需的。如果没有指定method，请求将默认使用get方法。 { // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // default // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data, headers) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: 'brackets'}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // default // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // default // `responseEncoding` indicates encoding to use for decoding responses // Note: Ignored for `responseType` of 'stream' or client-side requests responseEncoding: 'utf8', // default // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` is the name of the http header that carries the xsrf token value xsrfHeaderName: 'X-XSRF-TOKEN', // default // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // Do whatever you want with the native progress event }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status &gt;= 200 &amp;&amp; status &lt; 300; // default }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // default // `socketPath` defines a UNIX Socket to be used in node.js. // e.g. '/var/run/docker.sock' to send requests to the docker daemon. // Only either `socketPath` or `proxy` can be specified. // If both are specified, `socketPath` is used. socketPath: null, // default // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: '127.0.0.1', port: 9000, auth: { username: 'mikeymike', password: 'rapunz3l' } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } 请求方法 axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 【get】 axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 【post】 axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 执行多个并发请求 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) { // 两个请求现在都执行完成 })); 响应结构 { // `data` 由服务器提供的响应 data: {}, // `status` 来自服务器响应的 HTTP 状态码 status: 200, // `statusText` 来自服务器响应的 HTTP 状态信息 statusText: 'OK', // `headers` 服务器响应的头 headers: {}, // `config` 是为请求提供的配置信息 config: {}, // 'request' // `request` is the request that generated this response // It is the last ClientRequest instance in node.js (in redirects) // and an XMLHttpRequest instance the browser request: {} } 使用then时，你将接收下面这样的响应 axios.get('/user/12345') .then(function(response) { console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); }) 配置默认值 你可以指定将被用在各个请求的配置默认值 全局的 axios 默认值 axios.defaults.baseURL = 'https://api.example.com'; axios.defaults.headers.common['Authorization'] = AUTH_TOKEN; axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 自定义实例默认值 // Set config defaults when creating the instance const instance = axios.create({ baseURL: 'https://api.example.com' }); // Alter defaults after instance has been created instance.defaults.headers.common['Authorization'] = AUTH_TOKEN; 配置的优先顺序 配置会以一个优先顺序进行合并。这个顺序是：在lib/defaults.js找到的库的默认值，然后是实例的defaults属性，最后是请求的config参数。后者将优先于前者。这里是一个例子： // 使用由库提供的配置的默认值来创建实例 // 此时超时配置的默认值是 `0` var instance = axios.create(); // 覆写库的超时默认值 // 现在，在超时前，所有请求都会等待 2.5 秒 instance.defaults.timeout = 2500; // 为已知需要花费很长时间的请求覆写超时设置 instance.get('/longRequest', { timeout: 5000 }); 拦截器 在请求或响应被then或catch处理前拦截它们。 // 添加请求拦截器 axios.interceptors.request.use(function (config) { // 在发送请求之前做些什么 return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); }); // 添加响应拦截器 axios.interceptors.response.use(function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); }); 如果你想在稍后移除拦截器，可以这样： const myInterceptor = axios.interceptors.request.use(function () {/*...*/}); axios.interceptors.request.eject(myInterceptor); 可以为自定义 axios 实例添加拦截器 const instance = axios.create(); instance.interceptors.request.use(function () {/*...*/}); 错误处理 axios.get('/user/12345') .catch(function (error) { if (error.response) { // The request was made and the server responded with a status code // that falls out of the range of 2xx console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); } else if (error.request) { // The request was made but no response was received // `error.request` is an instance of XMLHttpRequest in the browser and an instance of // http.ClientRequest in node.js console.log(error.request); } else { // Something happened in setting up the request that triggered an Error console.log('Error', error.message); } console.log(error.config); }); 可以使用validateStatus配置选项定义一个自定义 HTTP 状态码的错误范围。 axios.get('/user/12345', { validateStatus: function (status) { return status 取消 可以通过传递一个 executor 函数到CancelToken的构造函数来创建 cancel token： const CancelToken = axios.CancelToken; let cancel; axios.get('/user/12345', { cancelToken: new CancelToken(function executor(c) { // executor 函数接收一个 cancel 函数作为参数 cancel = c; }) }); // cancel the request cancel(); 使用 application/x-www-form-urlencoded format 默认情况下，axios将JavaScript对象序列化为JSON。 要以application / x-www-form-urlencoded格式发送数据，您可以使用以下选项之一 浏览器 在浏览器中，您可以使用URLSearchParams API，如下所示： const params = new URLSearchParams(); params.append('param1', 'value1'); params.append('param2', 'value2'); axios.post('/foo', params); 请注意，所有浏览器都不支持URLSearchParams（请参阅caniuse.com），但可以使用polyfill（确保填充全局环境）。 或者，您可以使用qs库编码数据： const qs = require('qs'); axios.post('/foo', qs.stringify({ 'bar': 123 })); 或者以另一种方式（ES6）， import qs from 'qs'; const data = { 'bar': 123 }; const options = { method: 'POST', headers: { 'content-type': 'application/x-www-form-urlencoded' }, data: qs.stringify(data), url, }; axios(options); Node.js 在node.js中，您可以使用querystring模块，如下所示： const querystring = require('querystring'); axios.post('http://something.com/', querystring.stringify({ foo: 'bar' })); Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:15:42 "},"存储.html":{"url":"存储.html","title":"存储","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:16:01 "},"Cookie.html":{"url":"Cookie.html","title":"Cookie","keywords":"","body":"前言 cookie是一种早期的客户端存储机制，起初是针对服务器端脚本设计使用的，只适合存储少量文本数据。从最底层来看，作为HTTP协议的一种扩展实现它。cookie数据会自动在Web浏览器和Web服务器之间传输，因此服务端脚本就可以读、写存储在客户端的cookie的值。任何以cookie形式存储的数据，不论服务器端是否需要，每一次HTTP请求都会把这些数据传输到服务器端。 概述 “cookie”这个名字没有太多的含义，但是在计算机历史上其实很早就用到它了。“cookie”和“magic cookie”用于代表少量数据，特别是指类似密码这种用于识别身份或者许可访问的保密数据。在javascript中，cookie用于保存状态以及能够为Web浏览器提供一种身份识别机制。但是，javascript中使用cookie不会采用任何加密机制，因此它们是不安全的。但是，通过https来传输cookie数据是安全的，不过这和cookie本身无关，而和https协议相关 HTTP Cookie，通常直接叫做cookie，最初是在客户端用于存储会话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为响应的一部分，其中包含会话信息。例如，这种服务器响应的头可能如下 HTTP/1.1 200 OK Content-type: Text/html Set-Cookie: name=value Other-header: other-header-value 这个HTTP响应设置以name为名称、以value为值的一个cookie，名称和值在传送时都必须是URL编码的。浏览器会存储这样的会话信息，并在这之后，通过为每个请求添加Cookie HTTP头将信息发送回服务器，如下所示： GET /index.html HTTP/1.1 Cookie: name=value Other-header: other-header-value 发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求 标识 浏览器默认打开Cookie功能。window.navigator.cookieEnabled属性返回一个布尔值，表示浏览器是否打开Cookie功能 window.navigator.cookieEnabled // true 可以通过浏览器的一些设置将cookie功能关闭 window.navigator.cookieEnabled // false 此时，客户端本地将不再存储任何cookie 限制 cookie在性质上是绑定在特定的域名下的。当设定了一个cookie后，再给创建它的域名发送请求时，都会包含这个cookie。这个限制确保了储存在cookie中的信息只能让批准的接受者访问，而无法被其他域访问 [注意]不同的浏览器存入的cookie位置不一样，不能通用 由于cookie是存在客户端计算机上的，还加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。每个域的cookie总数是有限的，不过浏览器之间各有不同。如下所示 IE6-浏览器限制每个域名最多20个cookie IE7+浏览器限制每个域名最多50个。IE7最初是支持每个域名最大20个cookie，之后被微软的一个补丁所更新 Firefox限制每个域最多50个cookie Opera限制每个域最多30个cookie Safari和Chrome对于每个域的cookie数量限制没有硬性规定 当超过单个域名限制之后还要再设置cookie，浏览器就会清除以前设置的cookie。IE和Opera会删除最近最少使用过的(LRU, LeastRecentlyUsed)cookie，腾出空间给新设置的cookie。Firefox看上去好像是随机决定要清除哪个cookie，所以考虑cookie限制非常重要，以免出现不可预期的后果 浏览器中对于cookie的尺寸也有限制。大多数浏览器都有大约4096B(加减1)的长度限制。为了最佳的浏览器兼容性，最好将整个cookie长度限制在4095B(含4095)以内。尺寸限制影响到一个域下所有的cookie，而并非每个cookie单独限制 如果尝试创建超过最大尺寸限制的cookie，那么该cookie会被悄无声息地丢掉。注意，虽然一个字符串常占用一字节，但是多字节情况则有不同 【同源】两个网址只要域名相同和端口相同，就可以共享Cookie。注意，这里不要求协议相同 也就是说，http://example.com设置的Cookie，可以被https://example.com读取 组成 cookie由浏览器保存的以下7块信息构成 Set-Cookie: name=value[; expires=date][; max-age=secondes][; domain=domain][; path=path][; secure] 　　1、名称：唯一确定cookie的名称。cookie名称是不区分大小写的，所以myCookie和MyCookie被认为是同一个cookie。然而，实践中最好将cookie名称看作是区分大小写的，因为某些服务器会这样处理cookie。cookie的名称必须是经过URL编码的 　　2、值：储存在cookie中的字符串值。值必须被URL编码 　　3、域：cookie对于哪个域是有效的。所有向该域发送的请求中都会包含这个cookie信息。这个值可以包含子域(subdomain，如www.wrox.com)，也可以不包含它(如.wrox.com，则对于wrox.com的所有子域都有效)。如果没有明确设定，那么这个域会被认作来自设置cookie的那个域 　　4、路径：对于指定域中的路径，必须是绝对路径（比如/、/books），如果未指定，默认为请求该Cookie的网页路径。例如，可以指定cookie只有从\"http://www.wrox.com/books/\"中才能访问，那么http://www.wrox.com的页面就不会发送cookie信息，即使请求都是来自同一个域的 　　[注意]这里的匹配不是绝对匹配，而是从根路径开始，只要path属性匹配发送路径的一部分，就可以发送。比如，path属性等于/blog，则发送路径是/blog或者/blogroll，Cookie都会发送。path属性生效的前提是domain属性匹配 　　5、失效时间(expires)：表示cookie何时应该被删除的时间戳(也就是，何时应该停止向服务器发送这个cookie)。默认情况下，浏览器会话结束时即将所有cookie删除；不过也可以自己设置删除时间。这个值是个GMT格式的日期(Wdy,DD-Mon-YYYY HH:MM:SS GMT)，用于指定应该删除cookie的准确时间。因此，cookie可在浏览器关闭后依然保存在用户的机器上。如果设置的失效日期是个以前的时间，则cookie会被立刻删除 document.cookie = \"a = 2; expires = \" + (new Date( +new Date() + 4000*60*60*24 )).toUTCString(); 　　[注意1]必须使用toUTCString()或者toGMTString()，如果使用toString()会因为时区问题，导致时间设置错误 　　[注意2]浏览器根据本地时间，决定Cookie是否过期，由于本地时间是不精确的，所以没有办法保证Cookie一定会在服务器指定的时间过期 　　6、有效期(max-age)：表示cookie有效期为多久，单位为秒(s) document.cookie = \"b = 3; max-age=60\"; 　　7、安全标志：指定后，cookie只有在使用SSL连接的时候才发送到服务器。例如，cookie信息只能发送给\"https:www.wrox.com\"，而\"http:www.wrox.com\"的请求则不能发送cookie 　　每一段信息都作为Set-Cookie头的一部分，使用分号加空格分隔每一段，如下所示 HTTP/1.1 200 0K Content-type: text/html Set-Cookie: name=value; expires=Mon, 22-Jan-17 07:10:24 GMT; domains=.wrox.com Other-header: other-header-value 　　该头信息指定了一个叫做name的cookie，它会在格林威治时间2017年1月22日7:10:24失效，同时对于www.wrox.com和wrox.com的任何子域(如p2p.wrox.com)都有效 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-29 19:55:19 "},"模块化.html":{"url":"模块化.html","title":"模块化","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:16:12 "},"高级技巧.html":{"url":"高级技巧.html","title":"高级技巧","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:16:25 "},"setTimeout和setInterval.html":{"url":"setTimeout和setInterval.html","title":"setTimeout和setInterval","keywords":"","body":"JavaScript进程工作流简述 使用setTimeout()和setInterval()创建的定时器可以用于实现有趣且有用的功能。虽然人们对JavaScript的定时器存在普遍的误解，认为它们是线程，其实JavaScript是运行于单线程的环境中的，而定时器仅仅只是计划代码在未来的某个时间执行。执行时机是不能保证的，因为在页面的生命周期中，不同时间可能有其他代码在控制JavaScript进程。在页面下载完后的代码运行、事件处理程序、Ajax回调函数都必须使用同样的线程来执行。实际上，浏览器负责进行排序，指派某段代码在某个时间点运行的优先级。 可以把JavaScript想象成在时间线上运行的。当页面载入时，首先执行是任何包含在元素中的代码，通常是页面生命周期后面要用到的一些简单的函数和变量的声明，不过有时候也包含一些初始数据的处理。在这之后，JavaScript进程将等待更多代码执行。当进程空闲的时候，下一个代码会被触发并立刻执行。例如，当点击某个按钮时，onclick事件处理程序会立刻执行，只要JavaScript进程处于空闲状态。这样一个页面的时间线类似于图22-1。 除了主JavaScript执行进程外，还有一个需要在进程下一次空闲时执行的代码队列。随着页面在其生命周期中的推移，代码会按照执行顺序添加入队列。例如，当某个按钮被按下时，它的事件处理程序代码就会被添加到队列中，并在下一个可能的时间里执行。当接收到某个Ajax响应时，回调函数的代码会被添加到队列。在JavaScript中没有任何代码是立刻执行的，但一旦进程空闲则尽快执行。 定时器对队列的工作方式是，当特定时间过去后将代码插入。注意，给队列添加代码并不意味着对它立刻执行，而只能表示它会尽快执行。设定一个150ms后执行的定时器不代表到了150ms代码就立刻执行，它表示代码会在150ms后被加入到队列中。如果在这个时间点上，队列中没有其他东西，那么这段代码就会被执行，表面上看上去好像代码就在精确指定的时间点上执行了。其他情况下，代码可能明显地等待更长时间才执行。 关于定时器要记住的最重要的事情是，指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码。 setTimeout和setInterval 【setInterval】 使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个方式的问题在于，定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。幸好，JavaScript引擎够聪明，能避免这个问题。当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔。 这种重复定时器的规则有2点问题： (1) 某些间隔会被跳过 (2) 多个定时器的代码执行之间的间隔可能会比预期的小 为了避免setInterval()的重复定时器的这2个缺点，你可以用如下模式使用链式setTimeout()调用。 setTimeout(function(){ //处理中 setTimeout(arguments.callee, interval); }, interval); 这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用使用了arguments.callee来获取对当前执行的函数的引用，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。 如果上面Javascript计时器原理理解了，就很好明白倒计时功能存在问题的隐患。先看一段测试代码： let start = new Date().getTime(); let count = 0; //定时器测试 setInterval(function(){ count++; console.log( new Date().getTime() - (start + count * 1000)); },1000); 目测代码就知道运行结果，定时器每秒执行一次，每次输出应该是0 。 实际输出： 结论：由于代码执行占用时间和其他事件阻塞原因，导致有些事件执行延迟了几ms，但影响很微。 下面加一段阻塞代码看看： let start = new Date().getTime(); let count = 0; //占用线程事件 setInterval(function(){ let j = 0; while(j++ { count++; console.log( new Date().getTime() - (start + count * 1000)); },1000); 实际输出：结论：由于加了很占线程的阻塞事件，导致定时器事件每次执行延迟越来越严重。 由于实际项目中，执行计时器的同时，会有很多其他异步阻塞事件，会导致倒计时功能不精确。 解决思路 这里先分析一下从获取服务器时间到前端显示倒计时的过程： 客户端http请求服务器时间； 服务器响应完成； 服务器通过网络传输时间数据到客户端； 客户端根据活动开始时间和服务器时间差做倒计时显示； 服务器响应完成的时间其实就是服务器时间，但经过网络传输这一步，就会产生误差了，误差大小视网络环境而异，这部分时间前端也没有什么好办法计算出来，一般是几十ms以内，大的可能有几百ms。 获得服务器时间后，前端进入倒计时计算和计时器显示，这步就要考虑js代码冻结和线程阻塞造成计时器延时问题了，我的思路是通过引入计数器，判断计时器延迟执行的时间来调整，尽量让误差缩小，不同浏览器不同时间段打开页面倒计时误差可控制在1s以内。 //继续线程占用 setInterval(function(){ let j = 0; while(j++ = 0){ timeCounter = setTimeout(countDownStart,interval); } function countDownStart(){ count++; let offset = new Date().getTime() - (startTime + count * interval); let nextTime = interval - offset; if (nextTime 结论：由于线程阻塞延迟问题，做了setTimeout执行时间的误差修正，保证setTimeout执行时间一致。若冻结时间特别长的，还要做特殊处理。 做100%精确的倒计时很难，但做到相对比较准确是可以的。 在倒计时功能开发中，有几点总结： 要了解好js单线程工作原理； 清楚了解服务器系统时间传送到前端的流程； 了解前端渲染和线程阻塞造成的时间误差； 参考文献 JS实现活动精确倒计时 你真的知道怎么用javascript来写一个倒计时吗 ? Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-11 07:32:58 "},"JS动画.html":{"url":"JS动画.html","title":"动画","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:17:20 "},"JS性能规范.html":{"url":"JS性能规范.html","title":"性能&规范","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:17:52 "},"JS重点难点.html":{"url":"JS重点难点.html","title":"重点难点","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:18:19 "},"JS其它.html":{"url":"JS其它.html","title":"其它","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:18:42 "},"JavaScript判断数组和对象是否为空的方法.html":{"url":"JavaScript判断数组和对象是否为空的方法.html","title":"JavaScript 判断数组和对象是否为空的方法","keywords":"","body":"前言 平时开发中经常需要判断一个数组或者一个对象是否为空，但是我们发现直接判断if([]){}这样做是不行的。本文将总结几种有效的判断方式 起因 先看一小段简单的代码： const arr = []; // 当数组有值得时候进入逻辑分支，没有值得时候不进入逻辑分支 if(arr){ //我们的业务逻辑; console.log(123); } 通过运行代码我们发现实际上会打印出123,就说明此时，[] 通过判断为true。 原因:空数组其实就是一个对象，而任意对象通过Boolean()进行转换都为true； [个人理解]：arr变量保存着一个指针地址，实际上是有值得，这也是为什么两个空数组进行判断会是false的原因，毕竟两个地址都不一样 []===[] 为false 空数组的判断 1、JSON.stringify const arr = []; JSON.stringify(arr) === '[]' 2、数组长度判断 const arr = []; arr.length === 0 3、数组隐式转换为数字 const arr = []; +arr === 0 +arr 会隐式转换为数字0 空对象的判断 1、JSON.stringify const obj = {}; JSON.stringify(obj) === '{}' 2、ES6 新增的方法 Object.keys() Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。 Object.keys(obj).length === 0; 小结 实际项目中经常碰到要判断空数组和空对象，特此总结下常用的几种方法。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:20:31 "},"Node.html":{"url":"Node.html","title":"Node.js","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:35:12 "},"包管理.html":{"url":"包管理.html","title":"包管理","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:20:54 "},"semver规范（语义化版本）.html":{"url":"semver规范（语义化版本）.html","title":"semver规范（语义化版本）","keywords":"","body":"semver规范（语义化版本） semver 约定一个包的版本号必须包含3个数字，格式必须 为 MAJOR.MINOR.PATCH, 意为 主版本号.小版本号.修订版本号. 版本格式 MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号 MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号 PATCH 对应修订版本号，一般针对修复 BUG 的版本号 对于包作者（发布者），npm 要求在 publish 之前，必须更新版本号。npm 提供了 npm version 工具，执行 npm version major|minor|patch 可以简单地将版本号中相应的数字加1 常用命令 npm version patch 对于包的引用者来说，我们需要在 dependencies 中使用 semver 约定的 semver range 指定所需依赖包的版本号或版本范围。npm 提供了网站 https://semver.npmjs.com 可方便地计算所输入的表达式的匹配范围。常用的规则示例如下表： rang 含义 例子 ^2.2.1 指定的 MAJOR 版本号下, 所有更新的版本 匹配 2.2.3, 2.3.0; 不匹配 1.0.3, 3.0.1 ~2.2.1 指定 MAJOR.MINOR 版本号下，所有更新的版本 匹配 2.2.3, 2.2.9 ; 不匹配 2.3.0, 2.4.5 >=2.1 版本号大于或等于 2.1.0 匹配 2.1.2, 3.1 版本号小于或等于 2.2 匹配 1.0.0, 2.2.1, 2.2.11 1.0.0 - 2.0.0 版本号从 1.0.0 (含) 到 2.0.0 (含) 匹配 1.0.0, 1.3.4, 2.0.0 任意两条规则，用空格连接起来，表示“与”逻辑，即两条规则的交集: 如 >=2.3.1 =2.3.1 且 任意两条规则，通过 || 连接起来，表示“或”逻辑，即两条规则的并集: 如 ^2 >=2.3.1 || ^3 >3.2 [注] 除了这几种，还有如下更直观的表示版本号范围的写法: * 或 x 匹配所有主版本 1 或 1.x 匹配 主版本号为 1 的所有版本 1.2 或 1.2.x 匹配 版本号为 1.2 开头的所有版本 [注] 在常规仅包含数字的版本号之外，semver 还允许在 MAJOR.MINOR.PATCH 后追加 - 后跟点号分隔的标签，作为预发布版本标签 - Prerelese Tags，通常被视为不稳定、不建议生产使用的版本。例如： 1.0.0-alpha1.0.0-beta.11.0.0-rc.3 版本格式 当要发布大版本或者核心的Feature时，但是又不能保证这个版本的功能 100% 正常。这个时候就需要通过发布先行版本。比较常见的先行版本包括：内测版、灰度版本了和RC版本。Semver规范中使用alpha、beta、rc(以前叫做gama)来修饰即将要发布的版本。它们的含义是： alpha: 内部版本 beta: 公测版本 rc: 即Release candiate，正式版本的候选版本 比如：1.0.0-alpha.0, 1.0.0-alpha.1, 1.0.0-beta.0, 1.0.0-rc.0, 1.0.p-rc.1 等版本。alpha, beta, rc后需要带上次数信息。 版本发布准则 列举出比较实用的一些规则： 标准的版本号必须采用XYZ的格式，并且X、Y 和 Z 为非负的整数，禁止在数字前方补零，版本发布需要严格递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。 某个软件版本发行后，任何修改都必须以新版本发行。 1.0.0 的版本号用于界定公共 API。当你的软件发布到了正式环境，或者有稳定的API时，就可以发布1.0.0版本了。 版本的优先层级指的是不同版本在排序时如何比较。判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:23:04 "},"npm常用命令学习.html":{"url":"npm常用命令学习.html","title":"npm常用命令学习","keywords":"","body":"什么是npm npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。 npm不需要单独安装。在安装Node的时候，会连带一起安装npm。但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。 npm install npm@latest -g @latest表示最新版本 -g表示全局安装 常用的npm命令 npm help 查看命令列表 npm -l 查看各个命令的简单用法 npm -v 查看npm的版本 npm config list -l 查看 npm 的配置 npm init 初始化一个package.json文件，但是有很多问答需要手动输入 npm init -y 默认直接帮我们输入好，这是一个快捷方式 npm install 下载package.json中的依赖包 npm install --save-dev === npm install webpack -D npm install --save === npm install webpack -S npm info webapck 查看软件有哪些版本号 npm install webpack@4.2.2 安装软件的具体版本 npm set npm set 用来设置环境变量 上面命令等于为npm init设置了默认值，以后执行npm init的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行npm config。 npm set init-author-name 'Your name' npm set init-author-email 'Your email' npm set init-author-url 'http://yourdomain.com' npm set init-license 'MIT' npm config npm config get globalconfig 输出全局配置文件npmrc的路径 npm config set prefix $dir 上面的命令将指定的$dir目录，设为模块的全局安装目录。如果当前有这个目录的写权限，那么运行npm install的时候，就不再需要sudo命令授权了。 npm info npm info命令可以查看每个模块的具体信息。比如，查看underscore模块的信息。 npm list npm list命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。 npm list 当前目录的依赖树状结构 npm list -global 全局目录的依赖树状结构 npm list webpack 列出单个模块例如webpack npm install Node模块采用npm install命令安装。每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和gulp。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 # 本地安装 npm install # 全局安装 sudo npm install -global sudo npm install -g npm install也支持直接输入Github代码库地址。 npm install git://github.com/package/path.git npm install git://github.com/package/path.git#0.1.0 安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 npm install --force 如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。 rm -rf node_modules npm install 【安装不同版本】install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。 npm install sax@latest npm install sax@0.1.1 npm install sax@\">=0.1.0 @1.3.1-beta.3 // 安装指定的beta版本 install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。 –save：模块名将被添加到dependencies，可以简化为参数-S。 –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D npm install默认会安装dependencies字段和devDependencies字段中的所有模块，如果使用--production参数，可以只安装dependencies字段的模块。 npm install --production npm update，npm uninstall # 升级当前项目的指定模块 npm update [package name] # 升级全局安装的模块 npm update -global [package name] npm uninstall命令，卸载已安装的模块。 npm uninstall [package name] # 卸载全局模块 npm uninstall [package name] -global npm run npm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。 npm run命令会自动在环境变量$PATH添加node_modules/.bin目录，所以scripts字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。 npm run如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令。 npm内置了两个命令简写，npm test等同于执行npm run test，npm start等同于执行npm run start。 { \"name\": \"myproject\", \"devDependencies\": { \"jshint\": \"latest\", \"browserify\": \"latest\", \"mocha\": \"latest\" }, \"scripts\": { \"lint\": \"jshint **.js\", // 执行命令 npm run lint 则会执行冒号后面的命令 \"test\": \"mocha test/\" } } 关于这部分的内容具体可以看另外一篇文章npm scripts 脚本基础 npm bin npm bin命令显示相对于当前目录的，Node模块的可执行脚本所在的目录（即.bin目录）。 # 项目根目录下执行 npm bin ./node_modules/.bin npm adduser npm adduser用于在npmjs.com注册一个用户。 npm adduser Username: YOUR_USER_NAME Password: YOUR_PASSWORD Email: YOUR_EMAIL@domain.com npm publish npm publish用于将当前模块发布到npmjs.com。执行之前，需要向npmjs.com申请用户名。 npm owner 模块的维护者可以发布新版本。npm owner命令用于管理模块的维护者。 # 列出指定模块的维护者 npm owner ls # 新增维护者 npm owner add # 删除维护者 npm owner rm semver规范（语义化版本） semver 约定一个包的版本号必须包含3个数字，格式必须为 MAJOR.MINOR.PATCH, 意为 主版本\b号.小版本号.修订版本号. MAJOR 对应大的版本号迭代，做了不兼容旧版的修改时要更新 MAJOR 版本号 MINOR 对应小版本迭代，发生兼容旧版API的修改或功能更新时，更新MINOR版本号 PATCH 对应修订版本号，一般针对修复 BUG 的版本号 对于包作者（发布者），npm 要求在\b publish 之前，必须更新版本号。npm 提供了 npm version 工具，执行 npm version major|minor|patch 可以简单地将版本号中相应的数字加1 常用命令 npm version patch 对于\b包的引用者来说，我们需要在 dependencies 中使用 semver 约定的 semver range 指定所需依赖包的版本号或版本范围。npm 提供了网站 https://semver.npmjs.com 可方便地计算所输入的表达式的匹配范围。常用的规则示例如下表： rang 含义 例子 ^2.2.1 指定的 MAJOR 版本号下, 所有更新的版本 匹配 2.2.3, 2.3.0; 不匹配 1.0.3, 3.0.1 ~2.2.1 指定 MAJOR.MINOR 版本号下，所有更新的版本 匹配 2.2.3, 2.2.9 ; 不匹配 2.3.0, 2.4.5 >=2.1 版本号大于或等于 2.1.0 匹配 2.1.2, 3.1 版本号小于或等于 2.2 匹配 1.0.0, 2.2.1, 2.2.11 1.0.0 - 2.0.0 版本号\b从 1.0.0 (含) 到 2.0.0 (含) 匹配 1.0.0, 1.3.4, 2.0.0 任意两条规则，用空格连接起来，表示“与”逻辑，即两条规则的交集: 如 >=2.3.1 =2.3.1 且 任意两条规则，通过 || 连接起来，表示“或”逻辑，即两条规则的并集: 如 ^2 >=2.3.1 || ^3 >3.2 [注] 除了这几种，还有如下更直观的表示版本号范围的写法: * 或 x 匹配所有主版本 1 或 1.x 匹配 主版本号为 1 的所有版本 1.2 或 1.2.x 匹配 版本号为 1.2 开头的所有版本 [注] 在常规仅包含数字的版本号之外，semver 还允许在 MAJOR.MINOR.PATCH 后追加 - 后跟点号分隔的标签，作为预发布版本标签 - Prerelese Tags，通常被视为不稳定、不建议生产使用的版本。例如： 1.0.0-alpha1.0.0-beta.11.0.0-rc.3 npm5 新增package-lock 文件 package-lock.json 的作用是锁定依赖安装结构，如果查看这个 json 的结构，会发现与 node_modules 目录的文件层级结构是一一对应的。 npm5.2新增工具npx npx 的使用很简单，就是执行 npx 即可，这里的 默认就是 ./node_modules 目录中安装的可执行脚本名。例如上面本地安装好的 webpack 包，我们可以直接使用 npx webpack 执行即可。如果使用npm webpack命令的话，会调用全局的webpack，但当全局的版本和项目的版本不一致的时候，我们还是可以使用npx来只调用项目中的webpack 最佳实践 使用 npm: >=5.1 版本, 保持 package-lock.json 文件默认开启配置 初始化：第一作者初始化项目时使用 npm install 安装依赖包, 默认保存 ^X.Y.Z 依赖 range 到 package.json中; 提交 package.json, package-lock.json, 不要提交 node_modules 目录 初始化：项目成员首次 checkout/clone 项目代码后，执行一次 npm install 安装依赖包 不要手动修改 package-lock.json 升级依赖包 升级\b小版本: 本地执行 npm update 升级到新的小版本 升级大版本: 本地执行 npm install @ 升级到新的大版本 也可手动修改 package.json 中版本号为要升级的版本(大于现有版本号)并指定所需的 semver, 然后执行 npm install 本地验证升级后新版本无问题后，提交新的 package.json, package-lock.json 文件 降级依赖包 正确做法: npm install @ 验证无问题后，提交 package.json 和 package-lock.json 文件 错误做法: 手动修改 package.json 中的版本号为更低版本的 semver, 这样修改并不会生效，因为再次执行 npm install 依然会安装 package-lock.json 中的锁定版本 删除依赖包: Plan A: npm uninstall 并提交 package.json 和 package-lock.json Plan B: 把要卸载的包从 package.json 中 dependencies 字段删除, 然后执行 npm install 并提交 package.json 和 package-lock.json 任何时候有人提交了 package.json, package-lock.json 更新后，团队其他成员应在 svn update/git pull 拉取更新后执行 npm install 脚本安装更新后的依赖包 小结 通过本文学习下npm的一些常用命令以及规范，semver的版本管理规范，以及npm的一些最佳实践方式 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:25:21 "},"npmscripts脚本基础指南.html":{"url":"npmscripts脚本基础指南.html","title":"npm scripts 脚本基础指南","keywords":"","body":"什么是npm脚本？ npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 初始化package.json -> npm init -> 经历一系列的问答即可 { // ... \"scripts\": { \"build\": \"node start.js\" } } 此时我们执行 npm run build 就等于执行 node start.js 【npm脚本的优势】 项目的相关脚本都集中在一个地方 可以利用 npm 提供的很多辅助功能 代码示例： 执行命令 mkdir npmscript cd npmscript npm init ...一路回车 start.js一个简单的web服务器代码 //引入http模块 var http = require(\"http\"); //设置主机名 var hostName = '127.0.0.1'; //设置端口 var port = 8088; //创建服务 var server = http.createServer(function(req,res){ res.setHeader('Content-Type','text/plain'); res.end(\"hello nodejs\"); }); server.listen(port,hostName,function(){ console.log(`服务器运行在http://${hostName}:${port}`); }); 执行刚设置好的命令 npm run build npm scripts 原理 npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。 这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。 \"test\": \"mocha test\" 而不同写成下面这样 \"test\": \"./node_modules/.bin/mocha test\" 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。 npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 通配符 由于 npm 脚本就是 Shell 脚本，因此可以使用shell通配符 \"lint\": \"jshint *.js\" // * 表示所有 传递参数和获取参数 【方法一】向npm 脚本传入参数，要使用 -- 表明。 \"scripts\": { \"build\": \"node start.js -- port=8090\" // 通过 -- port=8090 传入参数 } 在我们的start.js文件中获取 // 打印process.argv对象看下 console.log(process.argv); 看下输出什么？ 可以看到数组中有port的相关信息，我们在通过数组方法就可以取出相应的值。 【方法二】package.json中添加config \"config\": { \"port\": \"8099\" } 然后在start.js中打印 process.env.npm_package_config_port 的信息看看 同样也可以获取到相应的信息 执行顺序 并行执行: & npm run script1.js & npm run script2.js 继发执行：&& npm run script1.js && npm run script2.js 默认值 一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用 \"start\": \"node server.js\"， \"install\": \"node-gyp rebuild\" 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 钩子 npm脚本有pre和post两个钩子。 { \"name\": \"npmscripts\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"prebuild\":\"echo I run before the build script\", \"build\": \"node start.js -- port=8090\", \"postbuild\":\"echo I run after the build script\" }, \"author\": \"\", \"license\": \"ISC\" } start.js 建一个空文件即可 用户执行 npm run build的时候，会自动按照下面的顺序执行。 npm run prebuild && npm run build && npm run postbuild 因此可以在pre和post钩子上完成一些准备工作和清理工作; 再执行下npm run build 可以看看结果 【默认钩子】 prepublish，postpublish preinstall，postinstall preuninstall，postuninstall preversion，postversion pretest，posttest prestop，poststop prestart，poststart prerestart，postrestart 【自定义命令的钩子】 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子 npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。 package.json { \"name\": \"npmscripts\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"pretest\": \"node start.js\", \"test\": \"node start.js\", \"posttest\": \"node start.js\" }, \"author\": \"\", \"license\": \"ISC\" } start.js const TARGET = process.env.npm_lifecycle_event; if (TARGET === 'test') { console.log(`Running the test task!`); } if (TARGET === 'pretest') { console.log(`Running the pretest task!`); } if (TARGET === 'posttest') { console.log(`Running the posttest task!`); } 执行命令 npm run test 可以看看效果； 简写形式 四个常用的npm脚本有简写形式 npm start是npm run start npm stop是npm run stop的简写 npm test是npm run test的简写 npm restart是npm run stop && npm run restart && npm run start的简写 变量 可以通过process.env 获取到package.json中定义的内容。要加上npmpackage前缀。看下代码 package.json { \"name\": \"npmscripts\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"node start.js\" }, \"author\": \"\", \"license\": \"ISC\" } start.js // 打印process.env对象看下 console.log(process.env); 看下输出的内容部分截图 具体我就不全部截图了，总之可以获取到package.json中的所有数据到 总结：通过本章的学习，让我们对npm scripts 脚本编程有一个入门的了解，再也不会感觉到陌生了。如果还有哪里不清楚的欢迎留言，我们一起探讨学习。 参考文献 npm scripts 使用指南 docs for npm Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:31:17 "},"mac如何升级node.js以及npm.html":{"url":"mac如何升级node.js以及npm.html","title":"mac如何升级node.js以及npm","keywords":"","body":"前言 每次想要更新下node.js都不记得该如何去处理，特此笔记下 步骤 1、查看本机node.js版本 node -v 2、清除node.js的cache sudo npm cache clean -f 3、安装n工具(已安装则可以忽略)，这个工具是专门用来管理node.js版本的 sudo npm install -g n 4、安装最新版本的node.js sudo n stable 5、更新 npm到最新版本 sudo npm install npm@latest -g 6、验证 node -v npm -v 小结 经历上诉步骤一般都是可以安装成功的 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:31:43 "},"npm发线上包npmpublish.html":{"url":"npm发线上包npmpublish.html","title":"npm发线上包(npm publish)","keywords":"","body":"前言 平时我们开发都是直接使用网上的第三方包，例如npm install --save lodash，那么究竟我们这个包是下载的哪里的？我们能不能也自己发一个第三方类库供大家使用呢？今天这边文章我们将一探究竟！ 第三方包 我们先来看看lodash这个我们常用的第三方包。 它的包管理地址：https://www.npmjs.com/package/lodash 当我们执行npm install lodash命令时，实际上npm包管理工具会去搜索这个包。然后下载一个最新版本，下载地址一般都是发包的代码仓库，一般都是git仓库下载的。 如何发包 我们npm publish发布的时候，一定是本地文件发布到远程仓库，并且登录到http://registry.npmjs.org（即npm adduser或npmlogin）之后，才可以进行发布。 一、创建文件关联git git建立文件仓库文件，publish_npm_pkg git clone https://github.com/shiyou00/publish_npm_pkg.git cd publish_npm_pkg npm init 生产package.json文件，里面要注意参数，repository:\"\"一定要填写git仓库地址(默认会自动填上)，因为最后npmjs，会从线上仓库获取。 二、注册包仓库账号 为了维护包，NPM必须要使用仓库账号才允许将包发布到仓库中。注册账号的命令是npm adduser。这也是提问式的交互，按顺序进行即可 npm adduser Username:shiyou Email:(xxx@xxx.com) 如果已经注册账号：则我们用npm login 登录即可证明是否登录成功：npm who am i npm config ls 也可查看npm的配置文件内容 最后就是直接上传了：npm publish 上传成功了 npm包线上地址 【注意】 包名字不能重复，否则上传时候报错 切记要注册登录，然后再上传 仓库地址一定要填写 最后：如果你以后修改了代码，然后想要同步到 npm 上的话请修改 package.json 中的 version 然后再次 publish，更新的版本上传的版本要大于上次 安装自己的包 在其它工作项目中直接npm install publish_npm_pkg 是不是和使用lodash的体验一样了。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:35:35 "},"node基础.html":{"url":"node基础.html","title":"基础","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:35:55 "},"Node.js实战项目学习系列1初识Node.js.html":{"url":"Node.js实战项目学习系列1初识Node.js.html","title":"Node.js实战项目学习系列(1) 初识Node.js","keywords":"","body":"前言 一直想好好学习node.js都是半途而废的状态，这次沉下心来，想好好的学习下node.js。打算写一个系列的文章大概10几篇文章，会一直以实际案例作为贯穿的学习。 什么是node Node.js是一个JavaScript运行平台，其显著特征是它的异步和事件驱动机制，以及小巧精悍的标准库。Node目前有两个活跃版本：长期支持版（LTS）和当前版，由Node.js基金会进行管理并提供支持。这个行业联盟遵循开放式治理模型，如果想了解更多与Node管理相关的信息，可以查阅其官网上的文档。 自2009年Node.js问世以来，JavaScript渐渐变成了能开发所有软件的语言，其地位也越来越重要，不再是只能勉强在浏览器上用一下的鸡肋语言了。这里有ECMAScript 2015的功劳，因为它解决了之前那些ECMAScript标准中遗留下来的几个关键问题。Node所用的Google V8引擎就是基于ECMAScript 2015开发的。ECMAScript 2015是ECMAScript标准的第6个版本，所以有时也被称为ES6，一般简写为ES2015。Node、React和Electron等技术创新成果的功劳也不可小觑，是它们让JavaScript无处不在：从服务器到浏览器，到原生的移动端应用程序。甚至像微软这样的大公司都对JavaScript敞开了怀抱，也为Node的成功起到推波助澜的作用。 Node与V8 node.js是运行在chrome v8引擎上的。V8负责JavaScript代码的解释和执行。 使用特性组 Node包含了V8提供的ES2015特性。这些特性分为shipping、staged和in progress三组。shipping组的特性是默认开启的，staged和in progress组的特性则需要用命令行参数开启。如果你想用staged特性，可以在运行Node时加上参数--harmony，V8团队将所有接近完成的特性都放在了这一组。然而，in progress特性稳定性较差，需要具体的特性参数来开启。Node的文档建议通过grep \"in progress\"来查询当前可用的in progress特性： node --v8-options | grep \"in progress\" 在不同的Node版本中执行这条命令后得到的结果也是不同的。Node自己也有个版本计划，定义了它要提供哪些API。 Node的发布计划 Node的发行版分为长期支持版（LTS）、当前版和每日构建版三组。LTS版有18个月的支持服务，期满后还有12个月的维护性支持服务。版本号是按照语义版本（SemVer）编制的。SemVer给每个版本定义了一个主要、次要和补丁版本号。比如6.9.1的主要版本号是6，次要版本号是9，补丁版本号是1。只要看到主版本号发生变化，那就意味着有些API可能不兼容了，也就是说如果要用这个版本的Node，那么你的项目需要重新测试一下。另外，按Node的发布规则，主版本号增长意味着新的当前版也已经切下来了。每日构建版的构建是自动进行的，每隔24小时一次，包含这24小时内的最新修改，但一般只用来测试Node的最新特性。 用哪个版本取决于你的项目和组织。有些人可能喜欢更新不那么频繁的LTS，对于那些难以管理频繁更新的大公司来说，这个版本可能更好。但如果你想跟上性能和功能的改进，当前版更合适。 Node特性以及应用场景 Node和JavaScript的优势之一是它们的单线程编程模型。Node保留了JavaScript在浏览器中所用的模型。它们都拥有“事件机制” 使其 I/O 密集 的情况下拥有非常好的表现。 我们先来了解几个概念： 【I/O 操作】 文件操作、网络操作、数据库 I/O 操作非常耗时，这样会阻塞程序的进行，导致效率非常低下的。那么Node.js 是如何处理的？ Node用三种技术来解决这个问题：事件、异步API、非阻塞I/O。在Node程序员看来，非阻塞I/O是个底层术语。它的意思是说，你的程序可以在做其他事情时发起一个请求来获取网络资源，然后当网络操作完成时，将会运行一个回调函数来处理这个操作的结果。 【为什么使用node】 web中应用效果良好，使得前端职责范围变大 在处理高并发、I/O密集场景性能优势明显 【使用场景】 web server 本地代码构建：gulp、webpack 之类的 实用工具的开发：爬虫之类 总结 Node是用来搭建JavaScript应用程序的平台，有基于事件和非阻塞的特性。 V8被用作JavaScript运行时。 被称为核心模块的Node标准库很精巧，为JavaScript添加了磁盘I/O。 Node自带了一个调试器和一个依赖管理器（npm）。 Node可以用于搭建Web应用程序、命令行工具，甚至桌面程序。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:37:18 "},"Node.js实战项目学习系列2开发环境和调试工具.html":{"url":"Node.js实战项目学习系列2开发环境和调试工具.html","title":"Node.js实战项目学习系列(2) 开发环境和调试工具","keywords":"","body":"前言 上一节让我们对Node.js有一个初步的了解，那么现在可以开始正式学习下Node.js的开发了，但是任何一门语言要设计到开发，就必须先学习开发环境以及调试。本文将主要讲解这些内容。 本文涉及到的代码全部可在github地址找到>>>node 代码 安装 点击查看>>>node 中文官网地址 【版本选择】 看图发现包含两种版本：长期支持的稳定版本 以及 当前发布版(包含很多最新的特性) 安装的过程就省略了... 开发环境 那么我们如果想要开发一个node程序，需要什么先了解哪些概念呢？ 【1】CommonJS代码规范，如果AMD，CMD一样的代码组织规范（模块管理系统） 【2】global代码运行在浏览器时，我们可以使用浏览器提供的全局对象：window以及DOM,BOM。但是node.js是运行在chrome V8引擎上的。给我们提供了 “global” 全局对象使用 【3】process代表当前执行的进程，这个是挂载在global下面的。在一些高级点的功能需要使用到 下面我们写第一个node.js文件 文件名：01_run.js console.log('hello Node'); 那么我们如何执行文件呢。此时打开命令行工具，执行命令 node 01_run.js 可以看到输出结果： 调试工具 实际开发中我们会使用node提供的一款调试工具 \"inspect\" ，这里先简单的了解下使用，后面会详细学习该工具 1、命令行工具执行 node --inspect-brk 01_run.js 2、使用chrome浏览器,地址栏输入 chrome://inspect 3、点击上图中红色框框里面的 inspect 上图就是实际上在node执行代码时，node底层帮我们把代码进行的封装。我们把封装的代码提取出来分析下： (function(exports, require, module, __filename, __dirname) { console.log('hello Node'); } ); >>> node把我们的代码分装在一个函数中并且添加了5个参数，我们先只看前3个参数：exports ，require，module >>> 其实这个就是CommonJS模块的话规范了。 小结 通过本文我们初步学习了 node的版本分为 长期稳定版本(LTS) 以及 当前新特性版本(current) node的全局变量是global 编写了第一个node代码，简单了解了下inspect调试工具 接下来我们将主要学习 CommonJS规范。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:41:08 "},"Node.js实战项目学习系列3CommonJS模块化规范.html":{"url":"Node.js实战项目学习系列3CommonJS模块化规范.html","title":"Node.js实战项目学习系列(3) CommonJS 模块化规范","keywords":"","body":"前言 想开始编写Node.js代码，那么我们就必须先熟悉它的模块化规范CommonJS，本文将详细讲解CommonJS规范 本文代码 >>> github 地址 CommonJS Node 应用由模块组成，采用 CommonJS 模块规范。 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 【特点】 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 新建文件example.js // example.js var x = 5; var addX = function (value) { return value + x; }; 上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。 如果想在多个文件分享变量，必须定义为global对象的属性。 global.warning = true; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 module.exports CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 新建文件02_module.js console.log('module'); const NUM = 100; function test (){ console.log(NUM); } // 输出常量 module.exports.num = NUM; // 输出函数 module.exports.testFn = test; exports 与 module.exports 它们之间是一层引用关系，exports 引用了 module.exports对象 06_exports.js console.log(exports,module.exports); // {} , {} exports.num = '100'; console.log(exports,module.exports); // { num: '100' } { num: '100' } 看上面的代码的输出可以证明exports 引用了 module.exports。那么之前我们采用module.exports输出的内容，其实可以简写为exports输出 【错误的做法】 exports = { a:1, b:2 }; 上面代码会切断 exports 对 module.exports的引用关系。导致输出的文件，在其它文件是无法使用的 [注意]建议还是使用module.exports规范些，不会产生额外的错误！ require require方法用于加载模块。 新建文件 03_require.js const m1 = require('./02_module'); m1.testFn(); 执行命令： node 03_require.js 运行结果： 【路径】[1] / 表示绝对路径，./ 表示相对于当前文件的路径[2] 不写路径则认为是 build-in模块或者各级 node_modules内的第三方模块 const m1 = require('./02_module.js'); // 这样就会在同级目录中寻找02_module.js文件 const m = require('02_module.js'); // 这样只会去 node_modules去寻找相应的文件 【加载文件】[1]支持js、json、node 拓展名，不写依次尝试加载 const m1 = require('./02_module'); // 这样会在同级目录中寻找 是否有02_module.js 的文件如果有则加载，如果没有则去寻找是否有02_module.json 或者 02_module.node 文件 【特性】[1]module 被加载的时候执行，加载后缓存 创建文件 04_catch.js >>> 当我们连续两次引入同一个文件其实只会执行一次 const m1 = require('./02_module'); const m2 = require('./02_module'); // 同时引入两次 02_module文件 我们执行命令 ：node 04_catch.js，输出结果： [2]一旦出现某个模块被循环加载，就只输出已执行的部分，还未执行的部分不会输出 // 1、创建文件：05_modA.js module.exports.test = 'A'; const modB = require('./05_modB'); console.log('modA: ', modB.test); module.exports.test = 'AA'; // 2、创建文件：05_modB.js module.exports.test = 'B'; const modA = require('./05_modA'); console.log('modB: ', modA.test); module.exports.test = 'BB'; // 3、创建文件：05_main.js const modA = require('./05_modA'); const modB = require('./05_modB'); 我们可以看到 modA中引入modB，modB中也引入了modA，它们形成了循环引用。那么此时执行 node 05_main.js 会输出什么呢？ 其实就是遵循上诉原理：一旦出现某个模块被循环加载，就只输出已执行的部分，还未执行的部分不会输出。大家可以动起手来敲敲代码很好理解的。 [注意]平时写代码的时候切记要避免循环引用 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 07:43:20 "},"Node.js实战项目学习系列4node对象global、process进程、debug调试.html":{"url":"Node.js实战项目学习系列4node对象global、process进程、debug调试.html","title":"Node.js实战项目学习系列(4) node 对象(global、process进程、debug调试)","keywords":"","body":"前言 在之前的课程我们学习了Node的模块化规则，接下来我们将学习下 Node的几个新特性：global ，process进程，debug调试 global 跟在浏览器中的window一样都是全局变量，我们先来熟悉些常用的全局变量 Buffer(二进制数据处理)、process、console timer(setImmediate) 看一段简单的代码： >>> 07_global.js const NUM = 1000; global.NUM = 2000; // 这里输出到全局 module.exports.num = NUM; >>> 07_global_01.js const mod = require('./07_global'); console.log(NUM); // 这里可以打印处全局的常量NUM 【setImmediate】 callback 在当前回合的 Node.js 事件循环结束时调用的函数。 09_setImmediate.js setImmediate(()=>{ console.log('setImmediate'); }); console.log('之后输出'); 结果：我们可以看到，输入setImmediate写在了前面，但是还是先执行了后面的输出。具体牵涉到了Node的event Loop，会在后面进行详细讲解 process 进程 process 对象是一个全局变量，它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 require()。 【argv】process.argv 属性返回一个数组，其中包含当启动 Node.js 进程时传入的命令行参数。 第二个元素将是正在执行的 JavaScript 文件的路径。 其余元素将是任何其他命令行参数。 const {argv} = process; argv.forEach(item => { console.log(item); }); 我们启动node打印出输出内容：第一行输出的是启动的命令第二行输出的是启动的文件路径 【添加参数】 执行命令：node 08_process_argv.js --test a=1 b=2 输出： 可以看到，我们可以看到，命令中的参数全部都打印出来了。 【env】 属性返回包含用户环境的对象 08_process_env.js const { env } = process; console.log(env); 【cwd】 process.cwd() 方法返回 Node.js 进程的当前工作目录。 08_process_cwd.js console.log(`当前工作目录是: ${process.cwd()}`); 【nextTick】 process.nextTick() 方法将 callback 添加到下一个时间点的队列。 一旦当轮的事件循环全部完成，则调用下一个时间点的队列中的所有回调。 这个方法同setImmdiate相似。 08_process_nextTick.js setImmediate(()=>{ console.log('setImmediate'); }); console.log('之后输出'); process.nextTick(()=>{ console.log('nextTick'); }); 看下打印结果：同步的先执行，其次是nextTick，然后是setImmediate [注意]关于nextTick 与 setImmediate 之间的关系，会在之后进行详细讲解的，目前只需要简单的了解下即可 debug 调试 【inspector】其实前面已经稍微提到了如何使用，这里再重复一遍 0、创建文件：10_debug.js function t1(){ const a = parseInt( Math.random() * 10 ); const b = parseInt( Math.random() * 10 ); const c = t2(a,b); } function t2(a,b){ if(a>b){ a += a * 2; }else{ b -= a; } return a + b; } t1(); 1、命令行工具执行 node --inspect-brk 10_debug.js 2、使用chrome浏览器,地址栏输入 chrome://inspect 3、点击上面的红框处的inpect的进入调试界面 该调试界面跟我们平时调试浏览器上的代码一模一样，非常方便，功能也是非常强大，这里就不展开讲解了。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:23:55 "},"Node.js实战项目学习系列5node基础模块path.html":{"url":"Node.js实战项目学习系列5node基础模块path.html","title":"Node.js实战项目学习系列(5) node基础模块 path","keywords":"","body":"前言 前面已经学习了很多跟Node相关的知识，譬如开发环境、CommonJs，那么从现在开始要正式学习node的基本模块了，开始node编程之旅了。 path path 模块提供用于处理文件路径和目录路径的实用工具。 它可以使用以下方式访问： const path = require('path'); 【path.normalize(path)】 path.normalize() 方法规范化给定的 path，解析 '..' 和 '.' 片段。 11_path_normalize.js const { normalize } = require('path'); // 输入两个不规范的路径 console.log( normalize('usr/local//bin') ); console.log( normalize('usr/local/../bin') ); 输出结果： 【path.join([...paths])】 path.join() 方法使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。 11_path_join.js const { join } = require('path'); console.log(join('/usr','local','bin/')); // 传入3个路径，且中间的路径不规则 输出： 【path.resolve([...paths])】 path.resolve() 方法将路径或路径片段的序列解析为绝对路径。如果没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径。 11_path_resolve.js const { resolve } = require('path'); console.log(resolve('./')); // 看下当前的路径的绝对路径 输出： 【basename、extname、dirname】basename: 返回 path 的最后一部分，类似于 Unix 的 basename 命令。 尾部的目录分隔符将被忽略 extname: 返回 path 的扩展名，从最后一次出现 .（句点）字符到 path 最后一部分的字符串结束。 dirname: 返回 path 的目录名，类似于 Unix 的 dirname 命令。 尾部的目录分隔符将被忽略 const { basename, dirname, extname } = require('path'); const filePath = '/usr/local/bin/e.text'; console.log(basename(filePath)); console.log(dirname(filePath)); console.log(extname(filePath)); 输出： 【parse、format】parse: 方法返回一个对象，其属性表示 path 的重要元素。 尾部的目录分隔符将被忽略 format: 从对象返回路径字符串。 与 path.parse() 相反 const { parse, format} = require('path'); const filePath = '/usr/local/node_modules/n/package.json'; console.log(parse(filePath)); console.log(format(parse(filePath))); 输出： 【sep、delimiter、win32、posix】sep：提供平台特定的路径片段分隔符：Windows 上是 \\。POSIX 上是 /。 delimiter：提供平台特定的路径定界符：; 用于 Windows ，: 用于 POSIX win32：属性提供对特定于 Windows 的 path 方法的实现的访问 posix： 属性提供对 path 方法的 POSIX 特定实现的访问。 const { sep, delimiter, win32, posix } = require('path'); console.log('sep: ', sep); console.log('win sep: ', win32.sep); console.log('PATH', process.env.PATH); console.log('delimiter: ', delimiter); console.log('win delimiter: ', win32.delimiter); 输出： 最后对之前接触过的路径做一个总结： dirname , filename 总是返回文件的绝对路径 process.cwd() 总是返回执行node命令所在文件夹 小结 通过本文我们学习了path模块的一些用法，文章只是列举了一些常用的方法，具体可以去node的官方文档查看更多方法。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:27:15 "},"nodehttp.html":{"url":"nodehttp.html","title":"http","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:27:26 "},"数据库.html":{"url":"数据库.html","title":"数据库","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:27:42 "},"登录功能.html":{"url":"登录功能.html","title":"登录功能","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:27:53 "},"日志功能.html":{"url":"日志功能.html","title":"日志功能","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:28:03 "},"安全.html":{"url":"安全.html","title":"安全","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:28:14 "},"框架.html":{"url":"框架.html","title":"框架","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:28:26 "},"上线配置.html":{"url":"上线配置.html","title":"上线配置","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:28:38 "},"实战.html":{"url":"实战.html","title":"实战","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:28:48 "},"网络协议.html":{"url":"网络协议.html","title":"网络协议","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:35:28 "},"HTTP.html":{"url":"HTTP.html","title":"HTTP","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:29:54 "},"HTTP入门学习.html":{"url":"HTTP入门学习.html","title":"HTTP入门学习","keywords":"","body":"概述 Web 的诞生，源于三大技术的诞生，它们都是当年 Web 之父 Tim Berners-Lee 自己 开发的，世界上第一个网站诞生的时间是 1991 年，三大技术的诞生也就是在此之前的不久： 可以指向任何网页的 URL html HTTP 协议 　　 HTTP 是超文本传输协议 Hypertext Transfer Protocol 的缩写。从服务器上到浏览器里，这个过程是基于 HTTP 协议来传输数据的。 　　 Web 内容都是存储在 Web 服务器上的，Web 服务器都是基于 HTTP 协议的，因此也被称为 HTTP 服务器。 　　 HTTP 服务器存储了各种类型的数据，如果 HTTP 的客户端发出请求的话，服务器就会返回数据给客户端，叫做响应 　　 HTTP 的服务器和客户端是万维网（ World Wide Web ）的基本单元。最常见的客户端就是浏览器。浏览一个页面的时候，浏览器会向服务器发出一个 HTTP 请求。等到服务器响应返回之后，浏览器再去处理响应数据，以美观的形式展示给用户 【特性】　　 HTTP 是一个无状态的协议。所谓无状态（ stateless ）意思就是：对于之前的交互没有记录。每次交互能用的信息就只有这次交互所携带的信息 　　 换句话说，HTTP 协议是没有办法记住之前的一次请求的，所以也没有办法根据前一次请求来辅助后一次请求。当一个Web 应用看起来似乎可以记住之前的交互，例如，可以记住你的用户名，其实它采用的技巧已经超出了 HTTP 本身。HTTP 的信息就好像是可以自销毁的，每次读取完毕，立刻就消失了。总之，HTTP 就是无状态的，也就是不能记录或者维持某种状态的。 因此，HTTP 方法具有幂等性，一次和多次请求某一个资源应该具有同样的副作用 HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。 【资源和URL】HTTP 故事的开始是浏览器发出请求。但是请求的是什么呢？是服务器上的资源，英文叫 Resource 对应的每一个资源，都有一个 URL ，也就是统一资源定位地址，指向这个资源。不过资源分两种：一种是静态资源，也就是各种文件了，最常见的就是静态 HTML ，但是也可以是 PDF ，json 文件等等。另外一种，就是动态资源，也就是 URL 指向的地方不是一个文件，而是一段代码的入口，服务器经过运算后，才返回运算结果给客户端。所以， 我们有 https://xxx.com/src/css/main.css ，这个 URL 就是指向一个静态资源的。如果是 https://xxx.com/posts 这个可能就是指向动态资源的，后台对应的可能就是一个 API 请求和响应 【请求】1、请求行第一行的内容被叫做请求行 Request Line ，具体形式如下 GET/POST [url] HTTP/[version] GET / HTTP/1.1 　　 这一行就是以HTTP 方法（ HTTP Method ）打头，一般是 GET 或者 POST ，当然还有其他方法。 当我们用 GET 发请求的时候，一般我们就是想要从服务器上 GET （拿到）一些内容，而不是想去修改服务器数据。POST 正好就是用来修改服务器上的数据的。到底要 GET 或者要修改的资源，就是后面的 URL 这一项来指定了。上面例子中，请求的 URL 是 / 。最后就是跟 HTTP 字样，再跟上到底是使用的哪个版本的 HTTP 协议，目前一般都是 HTTP 1.1 了 2、请求头部 [header 名]：[header 值] > Host: baidu.com > User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36 > Accept: */* 都是以冒号隔开的键值对。上面三项： Host 代表被请求的主机 User-Agent 代表用户使用的客户端 Accept 后面指明客户端可以接受的返回资源的类型，* 代表所有类型都接受 3、负载数据　　 header 之下，一个 request 中还可能包含负载数据（ payload ）。这一项，请求中不一定会包含。GET 请求都是不带负载数据的，POST 请求带负载数据。这个挺好理解，POST 方法的请求都是要改动服务器数据的，当然要在请求中携带数据过去。 比如，页面上有一个表单 form ，填写几项数据，然后一点提交，这个就会发出一个 POST 请求，而填写的数据， 就会作为 payload 成为请求的一部分 【响应】1、状态行对于请求有请求行，响应的第一行也很特别，叫做状态行 （ status line ） ，基本格式如下 HTTP[版本号] [状态码] [状态信息] HTTP/1.1 200 OK 简单介绍一下状态码 20x 的状态码都代表某种成功状态。最常见的 200 ，它的意义，就正如它后面跟的状态信息 一样，代表一切 OK 。 30x 的状态码，意味着资源已经被移动到其他地方了，但是响应中给出了应该跳转到哪里去找到这个资源。这个行为的术语就叫做 redirect （重定向）。 40x 的代码也都是代表一种客户端请求错误 。一个最常见的状态码 404 ，它的意义也跟它后面紧跟的状态信息所说的 一样：Page Not Found （页面未找到）。 50x 的状态吗也很常见。返回的如果是这一系列的状态码，就意味着 服务器端在处理请求的时候出错 。50x 出现，对于开发者，一般意味着服务器端代码出了错误。 2、响应头部 [ header 名]: [ header 值] accept-ranges: bytes age: 11912447 cache-control: max-age=315360000 content-encoding: gzip content-length: 14543 content-type: application/javascript date: Wed, 24 Apr 2019 00:24:43 GMT etag: \"8282-559c0e7235a80\" expires: Mon, 04 Dec 2028 03:23:56 GMT last-modified: Fri, 22 Sep 2017 05:58:50 GMT ohc-response-time: 1 0 0 0 0 0 server: JSP3/2.0.14 status: 304 vary: Accept-Encoding,User-Agent 3、响应主体响应主体，response body ，也可以叫做 payload xiaohuochai ... ... 【查询字符串】GET 请求中携带一些数据到服务器端的方法并不唯一，但是一种非常简单也非常常用的方式就是，使用查询字符串来传递数据，或者叫传递参数 如果打开 chrome 浏览器，打开 chrome 开发者工具的 Network 标签。然后浏览器中访问 www.xxx.com?name=jack&age=18 上面的 ?name=jack&age=18就是查询字符串，这里面传递了两个个参数，name和age 方法 每次发请求的时候，处理请求的 url 之外，还必然有一个请求方法 HTTP方法包括如下 GET ，最常用的一种，用于从服务器上“得到”某个资源 POST，往服务器上写入数据，跟 GET 作用相反 PUT，也是写入数据，通常的用法是 POST 创建新数据，PUT 用来更新已有数据 DELETE，删除服务器上的数据 HEAD，跟 GET 一样，也是请求服务器上的资源，但是只要响应的 Headers ，这个不太常用，不用管 其他的还有 TRACE，OPTIONS，PATCH 等，都不常用 【RestFul】上面的列出的各种 HTTP 方法的使用场合其实没有严格的规定的，如果作为开发者，非要用 GET 请求来写数据到 服务器，也不是不可以做到的。但是尊重 HTTP 方法（有时候也叫做 HTTP 动词）的本来用法，是个好的习惯。 Nodejs 开发领域非常常用的 RESTful 架构，就是尊重 HTTP 方法本意的一个典范： GET /posts # 读取所有文章 GET /posts/:id # 读取一篇文章 POST /posts # 发布一篇文章 PUT /posts/:id # 更新一篇文章 DELTE /posts/:id # 删除一篇文章 在 RESTful 的思路里面，HTTP 的方法的本意和用它真正发出请求执行的行为是非常吻合的 会话 会话就是服务器和浏览器的保有共同的信息的这段时间。换句话，会话开始和结束，就意味着服务器从认识一个浏览器到不再认识这个浏览器 会话可以让无状态的 HTTP 协议保持特定的状态。这种在客户端与服务器之间传递会话 id的机制，能让服务器创建一种各次请求之间的持续连接状态。Web 开发人员利用这种人造的状态，来构建一些”有状态“的应用场景：例如用户处于一直登陆的状态，购物车里面之前添加的商品，后续访问中还有等等。不过即使这样，每一个 HTTP 请求本质上来说还是无状态的，各次请求之间并不知道彼此的存在。 【技术机制】实现会话的方法不唯一，最常见的一个方式是这样：1、准备建立会话的时候，服务器会在自己的内存里创建一个新的变量，例如这个变量叫做 session-3254 2、服务器把这个会话的 id 也就是 3254 发送到浏览器，浏览器会把这个 id 保存到 cookie 中 3、每次浏览器再去访问服务器的时候，都会携带 cookie 中存放的 3254 这个会话 id 值，这样浏览器就认识这个浏览器了 4、服务器端的 session-3254 变量中可以存放任意的会话数据，例如：用户名，购物车里有哪几件商品等等 5、每次浏览器访问服务器，都可以凭借自己的会话 id 去服务器的 session-3254 变量中去认领属于我的信息 每一个请求都会包含这个会话 id ，这样服务器就能唯一确认客户端啦。 这样，直到会话过期，客户端和服务器都是互相认识的 【会话过期】服务器上有多少个浏览器在访问，就会在自己内存中创建多少了类似 session-3254 这样的变量。但是，还有一点非常重要，在一个会话里发出的会话 id 是唯一的，而且有一个很短的过期时间。那什么情况下会话就会过期呢？ 1、手动删掉 cookie 中的会话 id （在 chrome devtools 里，右键 cookies 然后删除它） 2、点一个网站的退出登录按钮 3、关闭网站有时候也通常能结束会话 【会话劫持】会话 id 作为一个唯一的令牌来唯一标识一个会话。通常，会话 id 是作为 cookie 存储在计算机上的一个随机字符串。很多 web 应用的用户认证系统所在做的事情，当用户的用户名和密码匹配之后，会话 id 会存储在用户的浏览器里，这样下一个请求就不用重新认证了 不幸的是，如果一个攻击者拿到了这个会话 id ，他就会跟我共享这一个会话，那服务器就会把他当成我，我的所有权限，他都不需要知道我的用户名密码，都可以获得了 这种情况就需要安全的 HTTP 也就是 HTTPS 来帮忙啦。通过 HTTPS 发送的请求和响应在发送前都会被加密。这意味着如果一个恶意的黑客监听 HTTP 通信，他得到的信息都是加密的，就是截获了也看不懂是个啥 XSS 跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容 如网站上有个评论框，然后恶意访客在里面输入了 Hello World alert('Hello World') 网站的行为被篡改了，或者说网站已经被 XSS 了 恶意用户可以使用 HTML 和 javascript 代码对服务器或者以后访问这个页面的用户发起毁灭性的攻击。举个例子，一个攻击者可以使用 javascript 代码去获取所有在他之后访问这个页面的用户的会话 id ，然后伪装成这个用户 【解决办法】1、消除有问题的输入。比如script标签，或者使用一个更安全的输入格式，比如 Markdown，这样就可以阻止 HTML 和 javascript 同时出现在用户的输入里 2、在显示之前转义用户输入的所有数据 总结起来一句话，总是对用户输入的内容做无害处理 【CSP】CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。 CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机 两种方法可以启用 CSP。一种是通过 HTTP 头信息的Content-Security-Policy的字段 Content-Security-Policy: script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https: 另一种是通过网页的标签 CSRF 跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任 跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的 【防御措施】1、检查Referer字段HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，这时候服务器就能识别出恶意的访问。 这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能 2、添加校验token由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验token的值为空或者错误，拒绝这个可疑请求 3、使用JWT。并将其存储在本地存储localStorage中 DDOS 典型的 DDoS 攻击，全称是 Distributed Denial of Service，翻译成中文就是分布式拒绝服务。一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业 如何应对DDOS攻击？ 1、高防服务器高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵 2、黑名单设置黑名单，但也会封锁正常流量，影响到正常业务 3、DDOS清洗对用户请求数据进行实时监控，及时发现DOS攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量 4、CDN在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃 HTTP2 HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0），简称为h2（基于TLS/1.2或以上版本的加密连接）或h2c（非加密连接），是HTTP协议的的第二个主要版本，使用于万维网。 HTTP/2是HTTP协议自1999年HTTP 1.1发布后的首个更新，主要基于SPDY协议。它由互联网工程任务组（IETF）的Hypertext Transfer Protocol Bis（httpbis）工作小组进行开发。该组织于2014年12月将HTTP/2标准提议递交至IESG进行讨论，于2015年2月17日被批准 HTTP/2标准于2015年5月以RFC 7540正式发表。多数主流浏览器已经在2015年底支持了该协议。此外，根据W3Techs的数据，在2017年5月，在排名前一千万的网站中，有13.7%支持了HTTP/2 HTTP/2的出现，相比于 HTTP 1.x ，大幅度的提升了 web 性能。在与 HTTP/1.1 完全语义兼容的基础上，进一步减少了网络延迟 【多路复用】多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 众所周知 ，在 HTTP/1.1 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。chrome下是6个，这也是为何一些站点会有多个静态资源 CDN 域名的原因之一 而HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息 因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息 【二进制分帧】HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输 这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码 【首部压缩】每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据 【服务器端推送】HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 08:33:45 "},"网络基础.html":{"url":"网络基础.html","title":"网络基础","keywords":"","body":"前言 网络基础一直都是非科班的弱项，今天我们就一起来学习下基础知识 网络 简单地说，网络就是在一定的区域内将两个或两个以上的计算机以一定的方式连接起来，以供用户共享文件、程序、数据等资源。下面就几种常见的网络类型及分类方法做简要介绍 1、按覆盖范围分 局域网(local area network,LAN)：局域网一般在几十米到几千米范围内，一个局域网可以容纳几台到几千台计算机，局域网往往用于某一群体，比如一个公司、一个单位、某一幢楼、某一个学校等 城域网(Metropolis Area Network,MAN)：城域网是规模局限在一座城市范围内的区域性网络，一般来说，覆盖范围介于10~100KM之间 广域网(Wide Area Network,WAN)：广域网是将分布在各地的局域网连接起来的网络，是网络之间的网络。广域网的范围非常大，可以跨越国界、洲界，甚至全球范围。广域网的典型代表是Internet 目前，还有两个比较流行的网络概念：存储区域网(Storage Area Network,SAN)和虚拟专用网(Virtual Private Network,VPN)。SAN是专用的高性能网络，它用于在服务器与存储资源之间传输数据。由于SAN是一个独立的专用网络，从而可以避免在客户机与服务器之间的任何传输冲突。VPN是一种在公共网络上传输私有网络数据的专用网络技术，利用VPN，一个远程用户或分支机构可以与总部之间建立一条安全的隧道，用于传输私有数据 2、按拓扑结构分 网络拓扑(Topology)确定了网络的结构。网络拓扑有两种：一种是物理拓扑，是指实际布线或设备相互连接的几何形式；另一种是逻辑拓扑，它定义了媒体如何存取由主机发送的数据 (1)物理拓扑按照物理拓扑结构的不同，可以将网络分为星型网络、环型网络、总线型网络三种基本类型 a、总线型网络。网络中所有的站点共享一条数据通道，总线的两端有端结点。总线型网络安装简单方便，需要铺设的电缆最短，成本低，某个站点的故障一般不会影响整个网络，但介质的故障会导致网络瘫痪。总线网安全性低、监控比较困难、增加新站点也不如星型拓扑网络容易。所以，总线型网络结构现在基本上已经被淘汰 b、环型拓扑。环型网络结构的各站点通过通信介质连成一个封闭的环形。环形网络容易安装和监控，但容量有限，网络建成后，难以增加新的站点。因此，现在组建局域网已经基本上不使用环形网络结构了 c、星型拓扑。各站点通过点到点的链路与中心站点相连。星型网络很容易在网络中增加新的站点，数据的安全性和优先级容易控制，易实现网络监控，一个站点出了问题，不会影响整个网络的运行，但中心站点的故障会引起整个网络瘫痪，星型网络结构是现在最常用的网络拓扑结构 在这三种类型的网络结构基础上，可以组合出拓展星型、层次型、网状型等其他类型拓扑结构的网络 (2)逻辑拓扑网络逻辑拓扑指各台主机通过传输介质相互通信的方式。最常见的两种逻辑拓扑形式是广播拓扑和令牌拓扑 a、广播拓扑。每台主机都把所要发送数据的目标地址设为网络介质上某个特定网络接口卡的地址、多播地址或广播地址，然后把该数据发送到传输介质中。每台主机使用传输介质时不必遵循某种次序，即先来先服务。现在最常使用的以太网就是采用这种方式来工作的 b、令牌拓扑。令牌拓扑通过向各台主机顺序传递一个电子令牌来控制网络介质的访问。当一台主机接收到令牌时，它就可以把数据发送到网络介质上。如果该主机没有数据要发送，那么就将令牌传递给下一台主机，如此循环。使用令牌传递的主要有令牌环和光纤分布式数据接口(FDDI)，它们都是在物理环形拓扑上使用令牌传递的 3、按传输介质分 按照网络的传输介质分类，可以将计算机网络分为有线网络和无线网络两种。有线网络包括采用同轴电缆、双绞线、光纤等有线介质连接的计算机网络。局域网通常采用单一的传输介质，而城域网和广域网采用多种传输介质 (1)双绞线采用双绞线连网，因价格便宜，安装方便，所以是目前最常见的连接方式。计算机局域网中的双绞线可分为非屏蔽双绞线、铝箔屏蔽的双绞线和屏蔽双绞线 a、非屏蔽双绞线(Unshielded Twisted Paired，UTP)价格低廉、容易安装及重新配置，所以是最常见的传输介质，它由两股线规很细的铜线组成，互相绝缘，以固定间隔彼此绞合在一起，绞合的作用是为抵消电脉冲传输过程中所形成的电磁场。在传输距离(理论上是100m)范围内，五类UTP的数据传输速率可以达到100Mb/s，甚至 1000Mb/s b、铝箔屏蔽的双绞线(Foil Twisted Pair,FTP)带宽较大，抗干扰能力强。相对的，屏蔽线比非屏蔽线价格及安装成本要高一些，线缆弯曲性能稍差。六类线及六类之前的屏蔽系统多采用这种形式 c、屏蔽双绞线(Shielded Twisted-Pair, STP)每一对双绞线都有一个铝箔屏蔽层。四对双绞线合在一起，并且还有一个公共的金属编织屏蔽层，这是七类线的标准结构，它适用于高速网络的应用 [注意]双绞线的制作口诀一般为白橙橙、白绿蓝、白蓝绿、白棕棕 双绞线有3种类型：直通线、交叉线和全反线。直通线(Straight-through)主要用于不同种设备的互连；交叉线(Crossover)主要用于同种设备的互连；全反线(Rollover)用于对路由器和交换机进行初始配置或用于异步传输 (2)同轴电缆与双绞线相比，同轴电缆含有线规较粗的单层实心导体，导体一般由铜或覆以铜的铝制成。中间的导体外面覆以一层绝缘材料，这种绝缘材料有助于把中间的导体和外面的金属铝箔屏蔽层隔开。外面通常会包一层金属网，再包一层保护皮对电缆加以保护。中间的导体可支持高频信号，几乎不会出现困扰UTP及同类电缆的信号衰减问题 以太网及其他LAN技术原先使用同轴电缆是因为它能支持高频信号，而且不受电磁干扰影响。然而，面对迅猛发展的双绞线，成本高昂加上安装困难导致同轴电缆退居其后。现在使用同轴电缆较多的网络是有线电视网 同轴电缆根据粗细程度不同，分为粗缆(10Base5)和细缆(10Base2)。粗缆的传输距离是500m，细缆的传输距离是185m (3)光纤网光导纤维简称光纤，光纤传输距离长，传输速率高，可达数千兆bps，抗干扰性强，不会受到电子监听设备的监听，是高安全性网络的理想选择。光纤是细如头发般的透明玻璃丝，可用来传导光信号。光纤由纤芯和包层组成，由于纤芯的折射率大于包层的折射率，故光波在界面上形成全反射，使光只能在纤芯中传播，实现通信 工程中使用最多的分法是按光纤横截面上折射率来分，有单模光纤和多模光纤。单模光纤纤芯直径较小，采用激光作为光源，传输的方向是沿光纤直径方向，因此单模光纤数据传输速率较快，传输距离较远，价格相对较贵；多模光纤纤芯直径较大，采用发光二极管作为光源，传输的方向是全反射，因此多模光纤数据传输速率较慢，传输距离较近，价格相对较便宜 (4)无线网无线网采用微波、红外线、无线电等传输，由于无线网络的连网方式灵活方便，是一种很有前途的组网方式 4、按服务方式分 按照网络的服务方式分类，可以将计算机网络分为客户机/服务器网和对等网两种 a、客户机/服务器(Client/Server)网服务器是指专门提供服务的高性能计算机或专用设备，客户机是指用户计算机。这是客户机向服务器发出请求并获得服务的一种网络形式，多台客户机可以共享服务器提供的各种资源，这是最常用、最重要的一种网络类型，不仅适合于同类计算机联网，也适合于不同类型的计算机联网。这种网络安全性容易得到保证，计算机的权限、优先级易于控制，监控容易实现，网络管理能够规范化。网络性能在很大程度上取决于服务器的性能和客户机的数量。目前针对这类网络有很多优化性能的服务器，称为专用服务器 b、对等网(Peer-to-Peer)对等网不要求专用服务器，每台客户机都可以与其他客户机对话，共享彼此的信息资源和硬件资源，组网的计算机一般类型相同。这种网络方式灵活方便，但是较难实现集中管理与监控，安全性也低，较适合于部门内部协同工作的小型网络 另外还有一些非正规的分类方法，如企业网、校园网，根据名称便可理解。从不同的角度对网络有不同的分类方法，每种网络名称都有特殊的含义。了解网络的分类方法和类型特征，是熟悉网络技术的重要基础之一 OSI OSI和ISO容易混淆。ISO是国际标准化组织(International Standard Organization)。而OSI是ISO提出的关于计算机网络的一个开放式系统互连参考模型(Open System Interconnection/Reference Model) 要想让两台计算机进行通信，必须使它们采用相同的信息交换规则。我们把在计算机网络中用于规定信息的格式，以及如何发送和接收信息的一套规则称为网络协议(Network Protocol)或通信协议(Communication Protocol) 为了减少网络协议设计的复杂性，网络设计者并不是设计一个单一、巨大的协议来为所有形式的通信规定完整的细节，而是采用把通信问题划分为许多个小问题，然后为每个小问题设计一个单独的协议的方法，绝大多数网络采用分层设计方法。所谓分层设计方法，就是按照信息的流动过程将网络的整体功能分解为一个个的功能层，不同机器上的同等功能层之间采用相同的协议，同一机器上的相邻功能层之间通过接口进行信息传递 OSI模型是一个开放体系结构，它规定将网络分为7层，并规定每层的功能 【物理层】 物理层的主要功能是完成相邻结点之间原始比特流的传输，控制数据怎样被放置到通信介质上。物理层协议关心的典型问题是使用什么样的物理信号来表示数据“1”和“0”；一位持续的时间多长；数据传输是否可同时在两个方向上进行；最初的连接如何建立和完成，通信后连接如何终止；物理接口(插头和插座)有多少针以及各针的用处等。物理层的设计主要涉及物理层接口的机械、电气、功能和过程特性，以及物理层连接的传输介质等问题，物理层的设计还涉及通信工程领域内的一些问题 1、中继器(Repeater) 中继器是连接网络线路的一种装置，常用于两个网络结点之间物理信号的双向转发工作。中继器是最简单的网络互联设备，主要完成物理层的功能，负责在两个结点的物理层上按位传递信息，完成信号的复制、调整和放大功能，以此来延长网络的长度。由于存在损耗，在线路上传输的信号功率会逐渐衰减，衰减到一定程度时将造成信号失真，因此会导致接收错误。中继器就是为解决这一问题而设计的，它完成物理线路的连接，对衰减的信号进行放大，保持与原数据相同 双绞线理论上的最大传输距离是100m，如果超过100m，由于信号的衰减，很难保证信息传输的正确性，可以使用中继器来延长传输的距离。中继器仅适用于以太网，可将两段或两段以上(使用多个中继器)的以太网互连起来 2、集线器(Hub) 集线器相当于多端口的中继器，也可以把信号整形、放大后发送到所有结点上。在环型网络中只存在一个物理信号传输通道，都是通过一条传输介质来传输的，这样就存在各结点争抢信道的矛盾，传输效率较低。引入集线器这一网络设备后，每一个工作站是用它自己专用的传输介质连接到集线器的，各结点间不再只有一个传输通道，各结点发回来的信号通过集线器集中，集线器再把信号整形、放大后发送到所有结点。这样至少在上行通道上不再出现碰撞现象。但基于集线器的网络仍然是一个共享介质的局域网，这里的“共享”其实就是集线器内部总线，所以当上行通道与下行通道同时发送数据时仍然会存在信号碰撞现象。当集线器在其内部端口检测到碰撞时，产生碰撞强化信号向集线器所连接的所有端口进行传送，这时所有数据都将不能发送成功 　　正因为集线器的这一不足之处，所以它不能单独应用于较大网络中(通常是与交换机等设备一起分担小部分的网络通信负荷)，就像在大城市中心不能有单车道一样，因为网络越大，出现网络碰撞现象的机会就越大。也正因如此，集线器的数据传输效率是比较低的，因为它在同一时刻只能有一个方向的数据传输，也就是所谓的“半双工”方式。如果网络中要选用集线器作为单一的连接设备，那么网络的规模最好在10台以内，而且集线器带宽应为10/100Mb/s以上 　　集线器除了共享带宽这一不足之处外，还有另一个方面的不足必须要考虑，那就是它的广播工作方式。因为集线器属于OSI七层模型的物理层，基本上不具有“智能”的能力，更别说“学习”功能了。它也不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说，当它要向某结点发送数据时，不是直接把数据发送到目的结点，而是把数据包发送到与集线器相连的所有结点 　　这里引入两个概念：冲突域(CollisionDomain)和广播域(BroadcastDomain)。当两个比特在同一介质上同时传输时就会产生冲突。所谓冲突域就是指发送数据给一个单一目标所影响的范围；所谓广播域是指发送数据给一个不明确目标所影响的范围，集线器将把该广播包转发到除接收端口以外的所有端口，集线器上的所有设备属于同一个广播域 所有通过集线器(不管有多少个集线器)互连的网络中只有一个广播域、一个冲突域。这种广播式发送数据有两方面不足：一、用户数据包向所有结点发送，很可能带来数据通信的不安全因素，一些别有用心的人很容易就能截获他人的数据包：二、由于所有数据包都是向所有结点同时发送，可能造成网络拥塞现象，降低网络执行效率 【数据链路层】 数据链路层的主要功能是如何在不可靠的物理线路上进行数据的可靠传输。数据链路层完成的是网络中相邻结点之间可靠的数据通信。为了保证数据的可靠传输，发送方把用户数据封装成帧(Frame)，并按顺序传送各帧。由于物理线路的不可靠，因此发送方发出的数据帧有可能在线路上出错或丢失，从而导致接收方不能正确接收到数据帧。为了保证能让接收方对接收到的数据进行正确性判断，发送方为每个数据分块计算出CRC(循环冗余检验)，并把CRC添加到帧中，这样接收方就可以通过重新计算CRC来判断数据接收的正确性。一旦接收方发现接收到的数据有错，则发送方必须重传这一帧数据。然而，相同帧的多次传送也可能使接收方收到重复的帧。比如，接收方给发送方的“确认帧”被破坏后，发送方也会重传上一帧，此时接收方就可能接收到重复帧。数据链路层必须解决由于帧的损坏、丢失和重复所带来的问题 数据链路层要解决的另一个问题是防止高速发送方的数据把低速接收方“淹没”。因此，需要某种信息流量控制机制使发送方得知接收方当前还有多少缓存空间。为了控制的方便，流量控制常常和差错处理一同实现 在最普遍的以太网中，数据链路层通过MAC(Media Access Control,媒体访问控制)地址负责主机之间数据的可靠传输。数据链路层的设备必须能够识别出数据链路层的地址，即MAC地址。一个设备如果能识别MAC地址，该设备至少是数据链路层以上的设备。数据链路层的网络设备主要有网卡、网桥和交换机 1、网卡(NIC) 网卡(Network Interface Card，NIC)也叫网络适配器，是连接计算机与网络的硬件设备。网卡的主要工作原理是整理计算机上发往网线上的数据，并将数据分解为适当大小的数据帧之后向网络上发送出去。对于网卡而言，每块网卡都有一个唯一的网络结点地址， 它是网卡生产厂家在生产时烧入ROM(Read Only Memory,只读存储芯片)中的，叫做MAC地址，且保证绝对不会重复 网卡插在计算机或服务器扩展槽中，通过网络线(如双绞线、同轴电缆或光纤)与网络交换数据、共享资源。计算机对接收到的数据帧进行比较，如果数据帧中的目标MAC地址与本机网卡的MAC地址相同，或者目标MAC地址是广播MAC地址，即 “FFFFFFFFFFFF”，则计算机对数据帧进行处理；否则，计算机丢弃该数据帧 可以在DOS窗口中使用“ipconfig/all”命令査看计算机网卡的MAC地址，网卡的MAC地址用十六进制表示，占用48个比特，前24个比特表示厂商，后24个比特为设备编号 2、网桥(Bridge) 网桥工作在数据链路层，用于将两个LAN连接在一起并按MAC地址转发帧。物理层的集线器可以扩展网络的规模，但所有通过集线器相连的主机属于同一个冲突域，任何时刻只能有一台主机发送数据，如果有两台主机同时发送数据就会发生冲突，导致数据发送失败。当同一个冲突域中的主机数据量非常多时，数据发生冲突的可能性大大增加，此时可以使用网桥来分隔冲突域 　　网桥可以用来分隔冲突域，把一个冲突域分隔成两个冲突域，通过增加冲突域的数量，减小每个冲突域的大小，减少冲突发生的可能。连接两个网段的网桥能从一个网段向另一个网段传送完整而且正确的帧，不会传送干扰或有问题的帧 　　网桥主要用于互联以太网分段，传输需在两个不同分段间传输的信息，但是阻断局部分段内的信息，因此网桥减少了网络上的通信总量 因为网桥能检査出一些故障，所以比中继器使用更广泛。两个通过中继器相连的网段，如果由于闪电而导致其中一个网段上有电干扰，中继器会把它传送到另一个网段。相反，如果干扰发生在通过网桥连接的网段中，网桥接收到一个不正确的帧，丢弃该帧。类似地，网桥不会把从一个网段传送来的冲突信号传送到另一个网段。因此，网桥会把故障控制在一个网段中而不会影响到另一个网段 　　网桥比中继器和集线器对数据包做更多的处理，延时也相对增加，一个双端口的网桥包括两个冲突域和一个广播域 3、交换机(Switch)　　与网桥的工作过程类似，交换机也根据源MAC学习，根据目的MAC进行转发，按每一个数据帧中的MAC地址决策信息转发地址表 　　交换机转发方式分为3种情况：情况一、交换机对己知的单播帧，只往对应的端口转发；情况二、交换机对未知的单播帧，即交换机还没有学到数据帧中的目的MAC地址，交换机泛洪数据包，即发往除接收端口以外的所有端口；情况三、交换机对组播帧和广播帧进行泛洪转发，即发往除接收端口以外的所有端口 　　类似网桥，交换机提供了网络互联功能。交换机的每个端口都是一个独立的冲突域， 可以为每个工作站提供更高的带宽。因为交换机可以使用现有的电缆、中继器、集线器和工作站的网卡，不必做高层的硬件升级；交换机对工作站是透明的，这样管理开销低廉，简化了网络结点的增加、移动和网络变化的操作；并且交换机的价格与集线器所差无几，所以在当今的网络中，交换机被普遍使用 　　可以简单地把交换机看成是多端口的网桥，但二者有一些区别。网桥一般只有2个端口，而一般交换机最少也有4个端口，还有24端口、48端口，甚至更多口的交换；网桥采用软件进行转发，而交换机采用专门设计的集成电路，基于硬件进行数据转发，交换机以线路速率在所有的端口并行转发信息，提供了比传统网桥高得多的操作性能，操作接近单个局域网性能，远远超过普通网桥互联网络之间的转发性能；而且，交换机的端口造价远低于网桥 【网络层】　　网络层(Network)的主要功能是完成网络中主机间的报文传输。在广域网中，这包括产生从源端到目的端的路由，根据采用的路由协议，选择最优的路径 　　网络层涉及的协议有IP、IPX等，网络层的设备必须能识别出网络层的地址，比如路由器、三层交换机等都可以根据IP地址做路径选择，它们都属于网络层设备 　　路由器是一种连接多个网络或网段的网络层设备，它能将不同网络或网段之间的数据信息进行“翻译”，以使它们能够相互“读懂”对方的数据，从而构成一个更大的网络。它不是应用于同一网段的设备，而是应用于不同网段或不同网络之间的设备。路由器之所以能在不同网络之间起到“翻译”的作用，是因为它不再是一个纯硬件设备，而是支持相当丰富路由协议的软、硬结合的设备，支持的协议有RIP、OSPF、EIGRP等，这些路由协议就是用来实现连通不同网段或网络的 　　路由器有两大典型功能，即数据通道功能和控制功能。数据通道功能包括转发决定、背板转发，以及输出链路调度等，一般由特定的硬件来完成；控制功能一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等 　　路由器具有判断网络地址和选择路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网。路由器属于网络层的一种互联设备，有隔离广播的作用，它的每个端口都是一个单独的广播域，也是一个单独的冲突域 　　在局域网接入广域网的众多方式中，通过路由器接入互联网是最为普遍的方式。使用路由器互联网络的最大优点是：各互联子网仍保持各自独立，每个子网可以采用不同的拓扑结构、传输介质和网络协议，网络结构层次分明。通过路由器与互联网相连，则可完全屏蔽公司内部网络。有些路由器内部还集成了入侵防御和防火墙功能，因此使用路由器可以用来防御攻击，保护内部网络的安全 【传输层】　　传输层(Transport Layer)是整个网络的关键部分，实现两个用户进程间端到端(End-to-End)的可靠通信，处理数据包错误、数据包次序，以及其他一些关键传输问题。向下提供通信服务的最高层，弥补通信子网的差异和不足，向上是用户功能的最低层。与数据链路层有相似之处，不同的地方在于前者是端到端的，后者是点到点的，而且比数据链路层协议复杂得多 　　传输层的主要功能有：提供建立、维护和拆除传输层连接，向网络层提供合适的服务，提供端到端的错误恢复和流量控制，向会话层提供独立于网络层的传送服务和可靠的透明数据传输 　　传输层相关的协议有TCP (Transmission Control Protocol,传输控制协议)、UDP (User Datagram Protocol,用户数据报协议)，它们涉及服务使用的端口号，主机根据端口号识别服务(常用的WWW服务端口号是80, Telnet服务端口号是23等)，区分会话(源IP、源端口号、目标IP、目标端口号，四者共同唯一标识一个会话) 【会话层】　　会话层(Session Layer)允许不同机器上的用户之间建立会话关系，会话层提供的服务之一是管理对话控制。会话层允许信息同时双向传输，或任一时刻只能单向传输。如果属于后者，类似于物理信道上的半双工模式，会话层将记录此时该轮到哪一方。一种与对话控制有关的服务是令牌管理，有些协议保证双方不能同时进行同样的操作，这一点很重要。为了管理这些活动，会话层提供了令牌，令牌可以在会话双方之间移动，只有持有令牌的一方可以执行某种关键性操作 　　另一种会话层服务是同步，如果在平均每小时出现一次大故障的网络上，两台机器间要进行一次两小时的文件传输，想想会出现什么样的问题？每一次传输中途失败后，都不得不重新传送这个文件。当网络再次出现大故障时，可能又会半途而废。为了解决这个问题，会话层提供了一种方法，即在数据中插入同步点。每次网络出现故障后，仅仅重传最后一个同步点以后的数据 【表示层】　　表示层(Presentation Layer)完成某些特定的功能，对这些功能人们常常希望找到普遍的解决办法，而不必由每个用户自己来实现。值得一提的是，表示层以下各层只关心从源主机到目标主机可靠地传送比特，而表示层关心的是所传送的信息的语法和语义 　　表示层服务的一个典型例子是用一种大家一致选定的标准方法对数据进行编码 　　网络上计算机可能采用不同的数据表示，所以需要在数据传输时进行数据格式的转换。例如在不同的机器上常用不同的代码来表示字符串(ASCII和EBCDIC)、整型数(二进制反码或补码)，以及机器字的不同字节顺序等。为了让采用不同数据表示法的计算机之间能够相互通信并交换数据，在通信过程中使用抽象的数据结构来表示传送的数据，而在机器内部仍然采用各自的标准编码。管理这些抽象数据结构，并在发送方将机器的内部编码转换为适合网上传输的传送语法，以及在接收方做相反的转换等，都是由表示层来完成的 　　此外，表示层还涉及数据压缩和解压、数据加密和解密等工作 【应用层】　　联网的目的在于支持运行于不同计算机上的进程进行通信，而这些进程则是为用户完成不同任务而设计的。可能的应用是多方面的，不受网络结构的限制。应用层(Application Layer)包含大量人们普遍需要的协议，如HTTP(Hyper text Transfer Protocol,超文本传输协议)，该应用默认使用的是TCP的80端口；FTP(File Transfer Protocol, 文件传输协议)，多用于因特网上的文件传输，该应用管理端口默认使用的是TCP的21号端口；SMTP(Simple Mail Transfer Protocol,简单邮件传输协议)，用于邮件的发送，该应用默认使用的是TCP的25号端口；POP3(Post Office Protocol Version 3,邮局协议版本3)，用于邮件的接收，该应用默认使用的是TCP的110号端口；DNS(Domain Name System,域名系统)，用于因特网上域名的解析；Telnet(远程登录)是一种字符模式的终端服务，它可以使用户通过网络进入远程主机或网络设备，然后对远程主机或网络设备进行操作，这种连通可以发生在局域网里面，也可以通过互联网进行，该应用默认使用的是TCP的23号端口 　　对于需要通信的不同应用来说，应用层的协议都是必需的。比如，当某个用户想要获得远程计算机上的一个文件拷贝时，他要向本机的文件传输软件发出请求，这个软件与远程计算机上的文件传输进程通过文件传输协议进行通信，这个协议主要处理文件名、用户许可状态和其他请求细节的通信。远程计算机上的文件传输进程使用其他特征来传输文件内容 TCP/IP 　　TCP/IP是目前最成功、使用最频繁的互联网协议。TCP/IP参考模型是四层结构，分别是网络访问层(NetworkAccess)，包括OSI模型的物理层和数据链路层，在这一层可以看到数据帧的源和目的MAC地址；网际层(Internet)，相当于OSI模型中的网络层，在这一层可以看到数据包的源和目的IP地址；传输层(Transport)，和OSI模型中的传输层一致，在这一层可以看到数据分段源和目的的端口，以及所使用的协议；应用层(Application)，包括OSI模型的上三层，即会话层、表示层和应用层 　　ISO/OSI参考模型是在其协议被开发之前设计出来的。这意味着ISO/OSI模型并不是基于某个特定的协议集而设计的，因而它更具有通用性。但另一方面，也意味着ISO/OSI模型在协议实现方面存在某些不足。而TCP/IP模型正好相反。先有协议，模型只是现有协议的描述，因而协议与模型非常吻合。问题在于TCP/IP模型不适合其他协议栈。因此，它在描述其他非TCP/IP网络时用处不大 【网络访问层】　　网络访问层(Network Access)的功能包括IP地址与物理硬件地址的映射，以及将IP分组封装成帧。基于不同硬件类型的网络接口，网络访问层定义了和物理介质的连接。网络访问层包含了数据链路层的地址，如用在以太网上就是MAC地址。此层是TCP/IP模型的最底层，负责接收从IP层传来的IP数据报，并将IP数据报通过低层物理网络发送出去，或者从低层物理网络上接收物理帧，解封装出IP数据报，交给IP层处理 【网际层】　　网际层(Internet)的主要功能包括三个方面： 1、处理来自传输层的分组发送请求：将分组装入IP数据报，填充报头，选择去往目的结点的路径，然后将数据报发往适当的网络接口； 2、处理输入数据报：首先检查数据报的合法性，然后进行路由选择，假如该数据报己到达目的结点(本机)，则去掉报头，将IP报文的数据部分交给相应的传输层协议；假如该数据报尚未到达目的结点，则转发该数据报； 3、处理ICMP(Internet Control Message Protocol，网际控制信息协议)报文： 即处理网络的路由选择、流量控制和拥塞控制等问题 　　TCP/IP网络模型的网际层在功能上非常类似于ISO/OSI参考模型中的网络层。网际层上的协议包括IP协议、ICMP协议、Proxy协议、ARP协议、RARP协议、BOOTP协议和DHCP协议 1、IP协议　　IP的责任就是把数据从源传送到目的地。它不负责保证传送可靠性、流控制、包顺序和其他对于主机到主机协议来说很普通的服务。IP实现两个基本功能：寻址和分段。IP可以根据数据报报头包括的目的地址将数据报传送到目的地址，在此过程中IP负责选择传送的路线，这种选择路线功能称为路由功能。如果有些网络内只能传送小数据报，IP可以将数据报重新组装并在报头域内注明 构成IP报头的字段如下图所示 　　括号中的数值表示该字段所占用的比特数。其中，优先级和服务类型字段一般用于QoS(Quality of Service,服务质量)；存活期(Time To Live, TTL)是数据报可以生存的时间上限，它由发送者设置，每经过一次路由，TTL至少减1，如果未到达目的地时，生存时间减为零，则抛弃此数据报；源和目的IP地址用于表示数据从哪来，到哪去 　　IP不提供可靠的传输服务，它不提供端到端的或结点到结点的确认，对数据没有差错控制，它只使用报头的校验码，不提供重发和流量控制。如果出错可以通过ICMP报告，ICMP在IP模块中实现 2、ICMP　　ICMP(Internet Control Message Protocol, Internet 控制消息协议)是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用 　　在网络体系结构的各层次中，都需要控制，而不同的层次有不同的分工和控制内容，IP层的控制功能是最复杂的，主要负责差错控制、拥塞控制等，任何控制都是建立在信息的基础之上的。在基于IP数据报的网络体系中，IP协议自身没有内在机制来获取差错信息并处理。为了处理这些错误，TCP/IP设计了ICMP协议，当某个网关发现传输错误时，立即向信源主机发送ICMP报文，报告出错信息，让信源主机采取相应处理措施，它是一种差错和控制报文协议，不仅用于传输差错报文，还传输控制报文 　　经常使用的用于检査网络通不通的Ping命令，这个“Ping”的过程实际上就是ICMP协议工作的过程。发送主机首先发送一个ICMP Echo Request的包，包含64字节数据，它被发送后，接收方会返回一个ICMP Echo Reply的包，返回的数据中包含了接收到的数据的拷贝。还有其他网络命令，如跟踪路由的Tracert命令也基于ICMP协议 　　ICMP报文包含在IP数据报中，属于IP的一个用户，IP头部就在ICMP报文的前面，所以一个ICMP报文包括IP头部、ICMP头部和ICMP报文，IP头部的Protocol值为1就说明这是一个ICMP报文，ICMP头部中的类型(Type)域用于说明ICMP报文的作用及格式，此外还有一个代码(Code)域用于详细说明某种ICMP报文的类型，所有数据都在ICMP头部后面 RFC定义了13种ICMP报文格式 [注意]代码为15、16的信息报文已经作废 下面是几种常见的ICMP报文 　　a、响应请求。我们日常使用最多的ping，就是响应请求(Type=8)和应答(Type=0)，一台主机向一个结点发送一个Type=8的ICMP报文，如果途中没有异常(例如被路由器丢弃、目标不回应ICMP或传输失败)，则目标返回Type=0的ICMP报文，说明这台主机存在，更详细的tracert通过计算ICMP报文通过的结点来确定主机与目标之间的网络距离 　　b、目标不可到达、源抑制和超时报文。这三种报文的格式是一样的，目标不可到达报文(Type=3)在路由器或主机不能传递数据报时使用，例如要连接对方一个不存在的系统端口(端口号小于1024)时，将返回Type=3、Code=3的ICMP报文，它提示的意思就是目标不可到达。常见的不可到达类型还有网络不可到达(Code=0)、主机不可到达(Code=1)、协议不可到达(Code=2)等。源抑制则充当一个控制流量的角色，它通知主机减少数据报流量，由于ICMP没有恢复传输的报文，所以只要停止该报文，主机就会逐渐恢复传输速率。最后，无连接方式网络的问题就是数据报会丢失，或者长时间在网络游荡而找不到目标，或者拥塞导致主机在规定时间内无法重组数据报分段，这时就要触发ICMP超时报文的产生。超时报文的代码域有两种取值：Code=0表示传输超时，Code=1表示重组分段超时 　　c、时间戳。时间戳请求报文(Type=13)和时间戳应答报文(Type=14)用于测试两台主机之间数据报来回一次的传输时间。传输时，主机填充原始时间戳，接收方收到请求后填充接收时间戳后以Type=14的报文格式返回，发送方计算这个时间差 3、ARP 　　ARP(Address Resolution Protocol,地址解析协议)负责将某个IP地址解析成对应的MAC地址。在局域网中，网络中实际传输的是 “帧”，帧里面是有目标主机的MAC地址的。在以太网中，一个主机要和另一个主机进行直接通信，必须要知道目标主机的MAC地址。但这个目标MAC地址是如何获得的呢？它就是通过地址解析协议获得的，所谓“地址解析”就是主机在发送帧前根据目标IP地址得出目标MAC地址的过程。ARP协议的基本功能就是通过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行 　　如果源主机在本地缓存中找到目标主机对应的MAC地址，则源主机用此MAC地址封装帧，并发送出去；如果没有找到，则源主机发送一个ARP的查询包(ARP Request)。ARP查询包中的源IP地址是源主机的IP地址，目标IP地址是目标主机的IP地址，源MAC地址是源主机的MAC地址，ARP査询包中的目的MAC地址是广播MAC地址FF-FF-FF-FF-FF-FF。源主机封装完成后，把ARP查询包以广播的形式发送出去，广播域内的所有主机均收到此广播包，如果目标IP地址不是本机IP，则放弃继续处理该数据包，并在本地缓存增加或更新源主机对应的MAC地址。如果目标IP地址与本机相同，也在本地缓存中增加或更新源主机对应的MAC地址，然后发回ARP应答包(ARP Reply) 　　因此，ARP请求包是广播包，而ARP应答包是单播包 　　使用“arp -a”命令可以查看本机的ARP缓存表；使用“arp -d”命令删除本机的ARP缓存，使用“arp -s”命令把IP地址和MAC地址进行绑定 4、ProxyARP 　　前面介绍的ARP协议可以帮助主机或路由器获知局域网上某个IP地址对应的MAC地址，可却无法获知一台远程主机对应的IP地址，因为ARP査询包是广播包，路由器有隔离广播的作用，致使ARP查询包无法穿越路由器而到达远端的目的主机。局域网内的主机可以配置默认网关来访问远端主机，可主机不允许配置多个默认网关。如果某个默认网关(一般是路由器)因故障停机，即使该局域网还有另一台出口路由器，主机也不会向其他的路由器发送数据，此时需要重新配置主机的网关。而代理ARP则可以在这种情况下自动帮助那些在某个子网中的主机，在不重新配置路由甚至默认网关的情况下，发送数据到远端主机 　　使用ProxyARP(代理 ARP)可以在网络中单独增加一台路由器，而不会影响其他路由器的路由表。但是使用代理ARP也带来严重不足：使用代理ARP将会明显增加网络分段中的传输业务量，并且网络中的主机也将会保持比正常时大许多的ARP表，并以此来处理全部的IP到MAC的地址映射 5、RARP 　　前面介绍的ARP是己知其他计算机的IP地址，查询其他计算机的MAC地址。而RARP(Reverse Address Resolution Protocol,反向地址转换协议) 是己知本机的MAC地址，询问本机的IP地址。典型用在无盘工作站上，当一台无盘工作站启动时，它没有办法在其初始化时了解自己的IP地址，但是，它可以知道自己的MAC地址。无盘工作站可以通过发送RARP的包来询问与此MAC地址相对应的IP地址，网络上会指定一个被称为RARP服务器的计算机来响应这个请求，这样无盘工作站就会得到自己的IP地址 　　RARP是早期提供的通过硬件地址获取IP的解决方案，但它有自身的局限性。比如，RARP客户与RARP服务器不在同段，中间有路由器等设备连接，这时候利用RARP就显得无能为力，因为RARP请求报文不能通过路由器。BOOTP(BootstrapProtocol,引导协议)提供了很好的解决方法，同样，在今天的大中型网络中，DHCP(Dynamic Host Configuration Protocol,动态主机配置协议)协议也是常用协议之一 6、BOOTP 　　BOOTP(BootstrapProtocol,引导协议)也是一种客户/服务器的协议，可以为无盘操作系统或配置成动态获取的计算机提供IP地址、子网掩码、网关(路由器地址)，以及DNS信息。实现过程分两种情况：1、这与RARP工作环境一样，即客户与服务器在同一网段，BOOTP服务器被动打开UDP端口67，客户端通过UDP端口68发送请求，因为客户端不知道自己的IP地址，也不知道服务器的IP地址，客户机使用全0的源地址与全1的目标地址，服务器通过单播或广播方式响应；2、客户与服务器在不同网段，实现的方法是，每个网段中设置一个中继代理，中继代理知道服务器的地址，其收到目标端端口为67的广播报文，就将该报文封装成单播数据报，然后发送给BOOTP服务器，服务器知道该报文来自于中继代理，因为在中继代理发送的报文中有其IP地址，中继代理收到BOOTP服务器的回应后，把它发送给BOOTP请求客户 7、DHCP 　　DHCP(Dynamic Host Configuration Protocol,动态主机配置协议)与BOOTP协议差不多，但DHCP功能更强，不仅可以通过租期方便地实现动态分配，而且还可以提供除IP地址、子网掩码、网关及DNS以外的几十个网络参数 　　[注意]ARP、ProxyARP和RARP也属于网络访问层，可以说ARP协议跨越OSI七层模型的二层和三层。正因为如此，一些处在网络层的防火墙对低层的ARP攻击显得无能为力 【传输层】　　在TCP/IP网络中，IP采用无连接的数据报机制，对数据进行“尽力而为的传递”，即只管将报文尽力传送到目的主机，无论传输正确与否，不做验证，不发确认，也不保证报文的顺序。TCP/IP的可靠性体现在传输层，传输层协议之一的TCP协议提供面向连接的服务(传输层的另一个协议UDP是无连接的)。传输层的主要功能是可靠而又准确地传输并控制源主机与目的主机之间的信息流，提供端到端的控制，通过滑动窗口机制提供流控制，通过序列号和确认机制来保证可靠性。TCP传输控制协议发送数据分段时，可以保证数据的完整性。流控制可以避免发送数据的主机使接收主机的缓存溢出的问题，缓存溢出会导致数据的丢失。可靠的传输可以通过下列方法实现：1、接收方对收到的数据分段向发送方进行确认；2、发送方向接收方重传所有未被确认的数据分段；3、在目的端将数据分段按正确的顺序重组，并删除重复的数据分段；4、提供避免和控制拥塞的机制 1、TCP 　　TCP (Transmission Control Protocol,传输控制协议)是一种面向连接的传输层协议，能提供可靠的数据传输。在面向连接的环境中，开始传输数据之前，端点之间先要建立连接。TCP负责将消息拆分成数据分段，重传丢失的数据分段井将数据分段在目的主机重组成消息 　　了解TCP报头中的源端口、目的端口、序列号、确认号和窗口，有助于理解TCP传输的可靠性和TCP的滑动窗口机制 　　TCP/IP协议组常用的协议如图所示，其中使用TCP的应用层协议有FTP、HTTP、SMTP、POP3、Telnet和DNS等，使用UDP的协议有DNS和TFTP等 2、UDP 　　UDP(User Datagram Protocol,用户数据报协议)是TCP/IP协议栈中无连接的传输协议，它是一种简单协议，它交换数据报而没有确认机制或传输保证，错误处理和重传机制必须由上层协议来完成。从TCP和UDP的数据分段格式中可以看出，UDP的简单性非常明显。UDP协议主要面向请求/应答式的交易型应用，一次交易往往只有一来一回两次报文交换，假如为此而建立连接和撤销连接，开销是相当大的，这种情况下使用UDP就非常有效。另外，UDP协议也应用于那些对可靠性要求不高，但要求网络的延迟较小的场合，如话音和视频数据的传送 　　组播一般使用的都是UDP协议，很多广播教学软件使用的就是组播地址和UDP协议，教师机只需要发送一份数据到组播地址，所有的学生机加入这个组播地址，接收教师机的广播教学，学生机的多少对教师机的性能影响不大 3、三次握手 　　TCP协议是面向连接的，所以它在开始传输数据之前需要先建立连接。要建立或初始化一个连接，两端主机必须同步双方的初始序号。同步是通过交换连接建立数据分段和初始序号来完成的，在连接建立数据分段中包含一个SYN(同步)的控制位。同步需要双方都发送自己的初始序号，并且发送确认的ACK。此过程就是三次握手 　　第一次握手：主机A发往主机B，主机A的初始序号是X，设置SYN位，未设置ACK位 　　第二次握手：主机B发往主机A，主机B的初始序号是Y，确认号(ACK)是X+1，X+1确认号暗示己经收到主机A发往主机B的同步序号。设置SYN位和ACK位 　　第三次握手：主机A发往主机B，主机A的序号是X+1，确认号是Y+1，Y+1确认号暗示已经收到主机B发往主机A的同步序号。设置ACK位，未设置SYN位 　　三次握手解决的不仅仅有序号问题，还解决了包括窗口大小、MTU(Maximum Transmission Unit,最大传输单元)，以及所期望的网络延时等其他问题 4、滑动窗口 　　在大多数可靠、面向连接的数据传输中，数据分组必须以与发送时相同的顺序传输到接收端。任何数据分组丢失、损坏、重复或接收时乱序都将导致协议出错。最基本的解决方法是让接收方在接收到每一个数据分段后都确认 　　如果发送方在发送每一个数据分段后都要等候确认，吞吐量是很低的， 因此大多数面向连接、可靠的协议都允许一次发送多个数据分段。因为发送方在发送完数据分组之后和处理完接收到的确认之前是有一段时间间隔的，这段间隔可以用来传输更多的数据。在没有收到确认的情况下，窗口是允许发送方发送数据分组的个数的 　　TCP使用期待确认，即确认号就是所期待接收的下一个字节。滑动窗口是指在TCP会话中窗口大小是动态协商的。滑动窗口是一种流控机制，允许源设备在向目的设备发送一定数量的数据之后接收一个确认 　　假设窗口大小为3，源设备可以发送3个字节到目的设备，然后需要等待一个确认。目的设备接收到这3个字节之后，向源设备返回一个确认，这时候源设备就可以继续传输下面3个字节了。如果目的设备没有收到这3个字节，它就不会返回确认，源设备没有接收到确认，它就知道这些字节需要重传 5、确认机制 　　TCP在传输前，需要对每个数据分段进行编号。接收端主机将数据分段重组成完整信息，TCP必须恢复由Internet通信系统导致的数据损坏、丢失、重复或乱序。TCP通过为传输的每个字节指定序号，并且要求接收端TCP的主动确认(ACK)来实现 　　如上图所示，1、源主机A远程登录目的主机B，源主机使用一个本地的随机端口1058，访问目的主机的23号服务端口。源主机初始序号是100，没有确认号；2、主机B收到主机A的数据包进行响应，返回的数据包源端口是23，目的端口是1058，主机B返回的包中的端口号和主机A发过来的端口号中的源和目的端口刚好相反。主机B的初始序号是1，确认号101表示已经收到主机A的序号100，希望接收序号101的包；3、主机A对主机B发过来的包进行响应，发送的序号是101，确认号2表示已经收到主机B的序号1 应用层 　　应用层包括所有的高层协议，与OSI的应用层协议相差不大，包括HTTP(超文本传输协议，使用TCP的端口80)、Telnet(远程登录协议，使用TCP的端口23)、FTP(文件传输协议，使用TCP的端口21和一个不确定的数据传输端口）、SMTP(简单邮件传输协议，使用TCP的端口25)、POP3(邮局3协议，使用TCP的端口110)、DNS(域名服务，使用UDP和TCP的端口53)等 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:20:48 "},"websocket.html":{"url":"websocket.html","title":"websocket","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:22:06 "},"nginx.html":{"url":"nginx.html","title":"Nginx","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:22:22 "},"TypeScript.html":{"url":"TypeScript.html","title":"TypeScript","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:35:46 "},"ydd.html":{"url":"ydd.html","title":"移动端","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:35:58 "},"【移动端】300ms延迟以及点透事件原因以及解决方案.html":{"url":"【移动端】300ms延迟以及点透事件原因以及解决方案.html","title":"【移动端】300ms延迟以及点透事件原因以及解决方案","keywords":"","body":"产生原因 移动端会有双击缩放的这个操作，因此浏览器在click之后要等待300ms，看用户有没有下一次点击，也就是这次操作是不是双击 说完移动端点击300ms延迟的问题，还不得不提一下移动端点击穿透的问题。可能有人会想，既然click点击有300ms的延迟，那对于触摸屏，我们直接监听touchstart事件不就好了吗？ 使用touchstart去代替click事件有两个不好的地方。 第一：touchstart是手指触摸屏幕就触发，有时候用户只是想滑动屏幕，却触发了touchstart事件，这不是我们想要的结果； 第二：使用touchstart事件在某些场景下可能会出现点击穿透的现象。 点透是什么? 假如页面上有两个元素A和B。B元素在A元素之上。我们在B元素的touchstart事件上注册了一个回调函数，该回调函数的作用是隐藏B元素。我们发现，当我们点击B元素，B元素被隐藏了，随后，A元素触发了click事件。 点透产生的原因？ 这是因为在移动端浏览器，事件执行的顺序是touchstart > touchend > click。而click事件有300ms的延迟，当touchstart事件把B元素隐藏之后，隔了300ms，浏览器触发了click事件，但是此时B元素不见了，所以该事件被派发到了A元素身上。如果A元素是一个链接，那此时页面就会意外地跳转。 点透的解决根本方案就是解决300ms延迟的问题 300ms延迟解决方案 【禁用缩放】 既然双击缩放仅对那些可被缩放的页面来说有存在意义，那对于不可缩放的页面，直接去掉点击延迟，何乐而不为呢？这里所说的不可缩放，是指使用了下述 标签的页面。 缺点：你必须完全禁用缩放来达到目的，而从移动端站点的可用性和可访问性来看，缩放是相当关键的一环。你很可能已经遇到过这个问题，即你想要放大一张图片或者一段字体较小的文本，却发现无法完成操作。 【width=device-width】 除了双击缩放的约定外，iPhone 诞生时就有的另一个约定是，在渲染桌面端站点的时候，使用 980 像素的视口宽度，而非设备本身的宽度（iPhone 是 320 像素宽）。 // 告诉浏览器 视口宽度 = 设备宽度 那么设置这个跟300ms有什么关系呢？ 在 Chrome 32 这一版中，他们将在包含 width=device-width 或者置为比 viewport 值更小的页面上禁用双击缩放。当然，没有双击缩放就没有 300 毫秒点击延迟。 除了浏览器开发商提供的方案外，还有一个更加通用的方案FastClick fastClick FastClick 是 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库。 【使用】 window.addEventListener( \"load\", function() { FastClick.attach( document.body ); }, false ); attach() 方法虽可在更具体的元素上调用，直接绑定到 上可以确保整个应用都能受益。当 FastClick 检测到当前页面使用了基于 标签或者 touch-action 属性的解决方案时，会静默退出。可以说，这是真正的跨平台方案出来之前一种很好的变通方案。 【原理】移动浏览器的事件触发顺序：touchstart -> touchend -> click FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟 click 事件，并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。 小结 由于现在浏览器一直在进步，所以针对自己的开发需求，选择合适的方案。时代在变，技术在变，尤其是这种因为浏览器所导致的bug，每一个时期的解决方案是不一致的。具体也可以看看fastClick README.md 中有这么一段话。 As of late 2015 most mobile browsers - notably Chrome and Safari - no longer have a 300ms touch delay, so fastclick offers no benefit on newer browsers, and risks introducing bugs into your application. Consider carefully whether you really need to use it. 截至2015年底，大多数移动浏览器——尤其是Chrome和Safari——不再有300ms的触摸延迟，因此，在较新的浏览器上，fastclick没有任何好处，而且可能会给应用程序带来bug。仔细考虑是否真的需要使用它。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:14:07 "},"数据结构.html":{"url":"数据结构.html","title":"数据结构","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:36:15 "},"设计模式.html":{"url":"设计模式.html","title":"设计模式","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:36:27 "},"算法.html":{"url":"算法.html","title":"算法","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:36:40 "},"代码管理.html":{"url":"代码管理.html","title":"代码管理","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:36:52 "},"git个人学习总结.html":{"url":"git个人学习总结.html","title":"git个人学习总结","keywords":"","body":"什么是git 代码管理工具，分布式管理，每个人电脑都是一个完整的版本库。并且有中央服务器(gitHub,gitLab)提供代码交换修改 git基础概念 工作区：自己的项目(有一个隐藏目录 \".git\" 的文件) stage暂存区(git add .之后就进入暂存区) 本地仓库(包含了本地的各种分支) 远程仓库(默认：origin) 分支：默认每个仓库都有一个master分支，也是我们的工作的一条线，git仓库则是由无数个分支组成 在git中HEAD表示当前版本指针 常用git指令 git add name(单个) || git add .（全部） : 工作区 ==> 暂存区 git commit -m \"message\" : 暂存区 ==> 本地分支 git push origin branchName : 本地分支 ==> 远程分支 git pull : 拉取关联了本地分支的远程分支的最新内容 git status : 用于显示工作目录和暂存区的状态 git rm file : 删除一个文件 git clone 项目地址 : 克隆一个项目 git remote 查看远程仓库信息 get remote -v 显示可以拉取和推送的origin的地址。如果没有推送权限，就看不到push地址 查看git操作信息 git log 查看log git log 显示log详细信息 git log --pretty=oneline(更加简洁清晰的显示) git reflog 记录了所有命令变更状态 git log --graph --pretty=oneline --abbrev-commit 查看分支合并图 分支 基础操作 git checkout -b 本地分支名 origin 远程分支名 ：创建分支 git branch -a : 查看本地分支和远程分支 git branch -r : 查看远程分支 git branch : 查看本地分支 git branch -d 分支名 : 删除本地分支 git push origin --delete 远程分支名 合并分支操作 假设develop为最新分支，我们需要更新当前分支为最新的develop 1. git fetch origin develop:develop 更新develop为最新 2. git merge develop 把最新的develop更新到当前分支中 3. 如果有冲突就解决冲突后重新commit push等操作 缓存区操作 假设我们现在编写了很多代码，但是又不愿意commit，但是这个时候又需要切换到其它分支进行操作，那么此时就可以用上stash了 1、把我们写的内容保存起来，执行命令git stash 2、然后切换到其它分支去工作，工作完成后切换到当前分支来 3、执行 git stash list 查看缓冲区有哪些内容 4、恢复之前的工作内容：git stash apply(恢复最后一条stash里面的工作内容，并且stash中还保存着) 5、或者使用 git stash pop 恢复最后一条stash的工作内容，且stash中不再保存了 6、也可以执行 git stash apply stash@{0} 来恢复指定的stash工作内容 最后再介绍一条：git stash drop stash@{0} 来移除指定的stash里面已经没有用的内容。 rebase操作流程 假设develop为最新分支，我们所在的分支名为cur分支，现在我们想要把develop的最新内容更新到cur分支上。 条件：我们现在所处的分支是cur分支 1. 拉取最新develop：git fetch origin develop:develop 2. git rebase develop 3. 如果有冲突的话，处理好冲突 4. git add . 5. git rebase --continue 6. git push -f （这里必须要强制推送） cherry-pick操作 假设我们现有release/1.0分支，我们所在的分支为cur分支，按照git flow 的分支管理方式，我们需要把cur分支合并到develop分支上的同时，我们还需要cherry-pick一份到release/1.0 1、git log 找到我们即将要cp的 commitID 假设(4b16df9cdf46159ceac7a5489b3da8eb5486034b) 2、切换到release/1.0分支上（git checkout release/1.0） 3、执行命令: git cherry-pick 4b16df9cdf46159ceac7a5489b3da8eb5486034b 4、查看是否有冲突，如果有冲突就解决冲突（假设有冲突）如果没有冲突的话就直接git push结束 5、解决完冲突后，git add . 6、git cherry-pick --continue 7、git push 操作 后悔药 暂存区后悔 git reset HEAD 这个是把暂存区的修改返回到工作区 git checkout --filename 丢弃工作区，回到上一次commit的状态 本地仓库后悔 git reset --hard origin/分支名 : 放弃所有修改，同步远程仓库 git reset --hard HEAD^ : 回退到上一次commit的状态 git reset --hard commitId : 回退到任意commitId 修改最后一次提交的msg git commit --amend 修改多个提交信息 再次记住这是一个变基命令 - 在 HEAD~3..HEAD 范围内的每一个提交都会被重写，无论你是否修改信息。 不要涉及任何已经推送到中央服务器的提交 - 这样做会产生一次变更的两个版本，因而使他人困惑。 git rebase -i HEAD~3 常见问题 1、当我们在gitLab上面创建了一个新分支，为什么使用命令行是看不到的？ 需要先git fetch 更新一下 小结 本文让我们初步了解了git是什么，且理解了git的四个核心的概念：工作区，暂存区，本地仓库，远程仓库。其实我们对于git的操作无非就是分支，把分支在这4个区中不断的变更位置，做错了就回退位置，做完了就合并到其它分支上去的一个过程。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 11:47:13 "},"git多人协作式开发时分支管理策略.html":{"url":"git多人协作式开发时分支管理策略.html","title":"git多人协作式开发时分支管理策略","keywords":"","body":"什么是 git-flow？ Git Flow是一套使用Git进行源代码管理时的一套行为规范 主分支Master 首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。 开发分支Develop 主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop 这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行\"合并\"（merge）。 临时性分支 前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。 但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： * 功能（feature）分支 * 预发布（release）分支 * 修补bug（fixbug）分支 这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 【功能分支】它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。 创建一个功能分支： git checkout -b feature-x develop 开发完成后，将功能分支合并到develop分支: git checkout develop git merge --no-ff feature-x 删除feature分支： git branch -d feature-x 【预发布分支】它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。 预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 【修补bug分支】最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。 修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 以上就是分支管理的一些策略。 特性开关 以下则是实际项目中有用的一个点：就是当我们在开发一个大型项目的时候，并且是多人进行协作。假设开发者A在开发大型项目中的一个特性。这个特性大概要开发一个月的时间，才能完全开发结束。那么我们不可能把开发到一半的内容展示到测试网站上吧。这个时候我们可以引入“特性开关”。就是创建一个配置文件对这个特性增加一个开关。当我们正在开发中的时候，只在本地配置该开关打开，我们就可以把开发的代码都合并develop分支上去。其他人是看不见的。当我们全部开发测试完成后。就可以在测试服务器上打开相应的开关。那么测试就可以进行测试了。该特性就对外公布了。 特性开关在多人协作开发的过程中是非常有用的。一般中大型团队都在使用。 参考文献 git分支管理 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:17:49 "},"pullRequest操作.html":{"url":"pullRequest操作.html","title":"github上如何进行PR(pullRequest)操作","keywords":"","body":"前言 Github 的一大特色就是 Pull Request 功能（简写为 PR）。 对于多人合作的项目，该功能简直必不可少。 Pull Request 是什么？ \"Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。\" Pull Request 本质上是一种软件的合作方式，是将涉及不同功能的代码，纳入主干的一种流程。这个过程中，还可以进行讨论、审核和修改代码。 Pull Request 的流程 第一步，你需要把别人的代码，克隆到你自己的仓库，Github 的术语叫做 fork。 git clone 刚刚fork下来的代码进行编写修改 第二步，在你仓库的修改后的分支上，按下\"New pull request\"按钮。 这时，会进入一个新页面，有Base 和 Head 两个选项 Base 是你希望提交变更的目标 Head 是目前包含你的变更的那个分支或仓库 第三步，填写说明，帮助别人理解你的提交，然后按下\"create pull request\"按钮即可。 PR 创建后，管理者就要决定是否接受该 PR。对于非代码变更（比如文档），单单使用 Web 界面就足够了。但是，对于代码变更，Web 界面可能不够用，需要命令行验证是否可以运行。 git am git am命令用于将一个 patch 文件，合并进入当前代码。 Github 对每个 PR 会自动生成一个 patch 文件。我们下载该文件，合并进本地代码，就可以在本地查看效果了。 $ curl -L http://github.com/cbeust/testng/pull/17.patch | git am 上面代码中，curl的-L参数表示，如果有302跳转，curl会自动跟进。后面网址里面的/cbeust/testng是目标仓库，pull/17表示该仓库收到的第17个 PR。 如果 PR 只包含一个 commit，那么也可以直接下载这个 commit 的 patch 文件。 $ curl https://github.com/sclasen/jcommander/commit/bd770141029f49bcfa2e0d6e6e6282b531e69179.patch | git am 上面代码中，网址里面的/sclasen/jcommander是代码变更所在的那个仓库。 创建远程仓库 另一种方法是为 PR 创建一个远程分支，追踪提交者的仓库。 # 创建远程仓库，指向 PR 提交者的仓库 $ git remote add nullin git://github.com/nullin/testng.git # 从该远程仓库拉取代码 $ git fetch nullin # 将该仓库的某个分支合并到当前分支 $ git merge kneath/error-page # 推送到自己的仓库 $ git push origin master cherry-pick 有时，PR 里面包含好几个 commit，但是你只想合并其中的一个或几个。 这时可以使用cherry-pick命令，挑出你感兴趣的 commit。 # 建立远程分支，追踪提交者的仓库 $ git remote add nullin git://github.com/nullin/testng.git # 从该远程仓库拉取代码 $ git fetch nullin # 只将感兴趣的 commit 加入当前代码 $ git cherry-pick commit1 $ git cherry-pick commit2 # 推送到自己的仓库 $ git push origin master Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-11 06:04:16 "},"浏览器.html":{"url":"浏览器.html","title":"浏览器","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:37:06 "},"zc浏览器基础.html":{"url":"zc浏览器基础.html","title":"深入理解浏览器工作原理","keywords":"","body":"前言 浏览器（browser application）是专门用来访问和浏览万维网页面的客户端软件，也是现代计算机系统中应用最为广泛的软件之一，其重要性不言而喻。前端工程师作为负责程序页面显示的工程师，需要直接与浏览器打交道。本文将详细介绍浏览器的工作原理 组成 浏览器的组成如下图所示 内核 浏览器内核分成两部分：渲染引擎和js引擎，由于js引擎越来越独立，内核就倾向于只指渲染引擎，负责请求网络页面资源加以解析排版并呈现给用户 默认情况下，渲染引擎可以显示html、xml文档及图片，它也可以借助插件显示其他类型数据，例如使用PDF阅读器插件，可以显示PDF格式 【渲染引擎】firefox使用gecko引擎 IE使用Trident引擎，2015年微软推出自己新的浏览器，原名叫斯巴达，后改名edge，使用edge引擎 opera最早使用Presto引擎，后来弃用 chrome\\safari\\opera使用webkit引擎，13年chrome和opera开始使用Blink引擎 UC使用U3引擎 QQ浏览器和微信内核使用X5引擎，16年开始使用Blink引擎 【js引擎】老版本IE使用Jscript引擎，IE9之后使用Chakra引擎，edge浏览器仍然使用Chakra引擎 firefox使用monkey系列引擎 safari使用的SquirrelFish系列引擎 Opera使用Carakan引擎 chrome使用V8引擎。nodeJs其实就是封装了V8引擎 渲染流程 从资源的下载到最终的页面展现，渲染流程可简单地理解成一个线性串联的变换过程的组合，原始输入为URL地址，最终输出为页面Bitmap，中间依次经过了Loader、Parser、Layout和Paint模块 渲染引擎的核心流程如下所示 【加载资源阶段：Loader】Loader模块负责处理所有的HTTP请求以及网络资源的缓存，相当于是从URL输入到Page Resource输出的变换过程。HTML页面中通常有外链的JS/CSS/Image资源，为了不阻塞后续解析过程，一般会有两个IO管道同时存在，一个负责主页面下载，一个负责各种外链资源的下载 注意：虽然大部分情况下不同资源可以并发下载异步解析（如图片资源可以在主页面解析显示完成后再被显示），但JS脚本可能会要求改变页面，因此有时保持执行顺序和下载管道后续处理的阻塞是不可避免的 【解析DOM阶段：Parser】 1、解析HTML Parser模块主要负责解析HTML页面，完成从HTML文本到HTML语法树再到文档对象树（Document Object Model Tree，DOM Tree）的映射过程 HTML语法树生成是一个典型的语法解析过程，可以分成两个子过程：词法解析和语法解析 词法解析按照词法规则（如正则表达式）将HTML文本分割成大量的标记（token），并去除其中无关的字符如空格。语法解析按照语法规则（如上下文无关文法）匹配Token序列生成语法树，通常有自上而下和自下而上两种匹配方式 浏览器内核中对HTML页面真正的内部表示并不是语法树，而是W3C组织规范的文档对象模型(Document Object Model，DOM)。DOM也是树形结构，以Document对象为根。DOM节点基本和HTML语法树节点一一对应，因此在语法解析过程中，通常直接生成最终的DOM树 2、解析CSS 页面中所有的CSS由样式表CSSStyleSheet集合构成，而CSSStyleSheet是一系列CSSRule的集合，每一条CSSRule则由选择器CSSStyleSelector部分和声明CSSStyleDeclaration部分构成，而CSSStyleDeclaration是CSS属性和值的Key-Value集合 CSS解析完毕后会进行CSSRule的匹配过程，即寻找满足每条CSS规则Selector部分的HTML元素，然后将其Declaration部分应用于该元素。实际的规则匹配过程会考虑到默认和继承的CSS属性、匹配的效率及规则的优先级等因素 3、解析Javascript JavaScript一般由单独的脚本引擎解析执行，它的作用通常是动态地改变DOM树（比如为DOM节点添加事件响应处理函数），即根据时间（timer）或事件（event）映射一棵DOM树到另一棵DOM树。 简单来说，经过了Parser模块的处理，内核把页面文本转换成了一棵节点带CSS Style、会响应自定义事件的Styled DOM树 【排列阶段：layout】 Layout过程就是排版，它包含两大过程 1、创建渲染树 布局树（或者叫做渲染树、Render Tree）和DOM树大体能一一对应，两者在内核中同时存在但作用不同。DOM树是HTML文档的对象表示，同时也作为JavaScript操纵HTML的对象接口。Render树是DOM树的排版表示，用以计算可视DOM节点的布局信息（如宽、高、坐标）和后续阶段的绘制显示 注意：并非所有DOM节点都可视，也就是并非所有DOM树节点都会对应生成一个Render树节点。例如head标签（HTMLHeadElement节点）不表示任何排版区域，因而没有对应的Render节点。同时，DOM树可视节点的CSS Style就是其对应Render树节点的Style 2、计算布局布局就是安排和计算页面中每个元素大小位置等几何信息的过程。HTML采用流式布局模型，基本的原则是页面元素在顺序遍历过程中依次按从左至右、从上至下的排列方式确定各自的位置区域 一个HTML元素对应一个以CSS盒子模型描述的方块区域，HTML元素分成两个基本类型，Inline和Block。Inline元素不会换行，按从左到右来布局。Block元素的出现意味着需要从上至下换到下一行来布局。除了这种基本的顺序按照元素的Inline和Block来进行流式布局之外，还有特殊指定的一些布局方式，如Absolute/Fixed/Relative三种定位布局以及Float浮动布局 简单情况下，布局可以顺序遍历一次Render树完成，但也有需要迭代的情况。当祖先元素的大小位置依赖于后代元素或者互相依赖时，一次遍历就无法完成布局，如Table元素的宽高未明确指定而其下某一子元素Tr指定其高度为父Table高度的30%的情况 经过了Layout阶段的处理，把带Style的DOM树变换成包含布局信息和绘制信息的Render树，接下来的显示工作就交由Paint模块进行操作了 【绘制阶段：Paint】 Paint模块负责将Render树映射成可视的图形，它会遍历Render树调用每个Render节点的绘制方法将其内容显示在一块画布或者位图上，并最终呈现在浏览器应用窗口中成为用户看到的实际页面。每个节点对应的大小位置等信息都已经由Layout阶段计算好了，节点的内容取决于对应的HTML元素，或是文本，或是图片，或是UI控件 通常情况下，布局和绘制是相当耗时的操作。如果DOM树每次略有改动都要重新布局和绘制一次，效率会相当低下。因此，一般浏览内核都会实现一种增量布局和增量绘制的方式。当一个DOM树节点（或者它的子节点）内容或者样式发生变化时，内核会确定其影响范围，在布局阶段会标记出受该节点布局影响的其他节点（比如可能是子节点），在绘制阶段则会标记出一个Dirty区域并通知系统重绘 [注意] 这里其实可以理解成 virtual DOM 按照HTML相关规范，页面元素的CSS属性也规定了其绘制顺序，如根据不同Layer必须按顺序绘制，否则覆盖叠加效果会出现错误，如元素的边框轮廓和内容背景的绘制次序也有规定 资源加载 缓存在浏览器中也得到了广泛的应用，对提高用户体验起到了重要作用。在浏览器中，主要存在三种类型的缓存：Page Cache、Memory Cache、Disk Cache。这三类Cache的容量都是可以配置的，比如限制Memory Cache最大不超过30MB，Page Cache缓存的页面数量不超过5个等 Page Cache：是将浏览的页面状态临时保存在缓存中，以加速页面返回等操作 Memory Cache：浏览器内部的缓存机制，对于相同url的资源直接从缓存中获取，不需重新下载 Disk Cache：资源加载缓存和服务器进行交互，服务器端可以通过HTTP头信息设置网页要不要缓存。 【内存缓存】Memory Cache，顾名思义内存缓存，其主要作用为缓存页面使用各种派生资源。在使用浏览器浏览网页时，尤其是浏览一个大型网站的不同页面时，经常会遇到网页中包含相同资源的情况，应用Memory Cache可以显著提高浏览器的用户体验，减少无谓的内存、时间以及网络带宽开销 【页面缓存】Page Cache，即页面缓存。用来缓存用户访问过的网页DOM树、Render树等数据。设计页面缓存的意图在于提供流畅的页面前进、后退浏览体验。几乎所有的现代浏览器都支持页面缓存功能 如果浏览器没有页面缓存，用户点击链接访问新页面时，原页面的各种派生资源、JavaScript对象、DOM树节点等占据的内存统统被回收，此后当用户点击后退按钮以浏览原页面时，浏览器必须先要重新从网络下载相关资源，然后进行解码、解析、布局、渲染一系列操作，最后才能为用户呈现出页面，这无疑增加了用户的等待时间，影响了用户的使用体验 所有的派生资源加载时都会与Memory Cache关联，如果Memory Cache中有资源的备份且条件合适，则可以直接从Memory Cache中加载。而Page Cache只会在用户点击前进或后退按钮时才会被查询，如果页面符合缓存条件并被缓存了，则直接从Page Cache中加载。即使某个需要被加载的页面在Page Cache中有备份，但若触发加载的原因是用户在地址栏输入url或点击链接，则页面仍然是通过网络加载。也就是说Page Cache并不是主资源的通用缓存 【磁盘缓存】 Disk Cache，即磁盘缓存。现代的浏览器基本都有磁盘缓存机制，为了提升用户的使用体验，浏览器将下载的资源保存到本地磁盘，当浏览器下次请求相同的资源时，可以省去网络下载资源的时间，直接从本地磁盘中取出资源即可 磁盘缓存即我们常说的Web缓存，分为强缓存和协商缓存，它们的区别在于强缓存不发请求到服务器，协商缓存会发请求到服务器 网页解析 可以将浏览器整体看作一个网页处理模块，这个模块的输入是网络上接收到的字节流形式的网页内容。输出是三棵树型逻辑结构：DOM树、Render树及RenderLayer树 浏览器的解析过程就是将字节流形式的网页内容构建成DOM树、Render树及RenderLayer树的过程 浏览器的解析对象是网页内容，网页内容包括以下三个部分： 　　1、HTML文档：超文本标记语言，制作Web页面的标准语言 　　2、CSS样式表（Cascading Style Sheet）：级联样式表，用来控制网页样式，并允许样式信息与网页内容相分离的一种标记性语言 　　3、JavaScript脚本：JavaScript是一种无类型的解释型脚本语言。常用于为网页添加动态功能 HTML文档决定了DOM树及Render树的结构。CSS样式表决定了Render树上节点的排版布局方式。JavaScript代码可以操作DOM树，改变DOM树的结构，也可以用来给页面添加更丰富的动态功能 HTML文档被解析生成DOM树，由DOM节点创建Render树节点时，会触发CSS匹配过程，CSS匹配的结果是RenderStyle实例，这个实例由Render节点持有，保存了Render节点的排版布局信息。CSS的解析过程即是CSS语法在浏览器的内部表示过程，解析的结果是得到一系列的CSS规则。CSS的匹配过程主要依据CSS选择器的不同优先级进行，高优先级选择器优先适用。根据网页上定义的JavaScript脚本的不同属性，JavaScript脚本的下载和执行时机会有所不同。JavaScript脚本的执行是由渲染引擎转交给JS引擎执行的。下面分别看一下HTML、CSS、JavaScript的具体解析和执行 【DOM树构建】 DOM（Document Object Model，文档对象模型），是中立于平台和语言的接口。它允许程序和脚本动态地访问和更新文档的内容结构和样式。DOM是页面上数据和结构的一个树形表示，使用DOM接口可以对DOM树结构进行操作。DOM规范只是定义了编程接口，没有对文档的表示方式做任何限制。以树状结构表示DOM文档是比较普遍的实现方式。这个树状结构就称为DOM树。DOM树是DOM文档中的节点按照层次组织构成的。以HTML文档为例，每一个标签都对应着DOM树上的一个节点。由于是树形结构表示，这些节点之间的关系也是通过父子或兄弟维系的 渲染引擎解析HTML文档的过程就是将字节流形式的网页内容解析成DOM Tree、Render Tree、Render Layer Tree三棵树的过程。这个过程可以分为解码、分词、解析、建树四个步骤 　　1、解码：将网络上接收到的经过编码的字节流，解码成Unicode字符 　　2、分词：按照一定的切词规则，将Unicode字符流切成一个个的词语(Tokens) 　　3、解析：根据词语的语义，创建相应的节点(Node) 　　4、建树：将节点关联到一起，创建DOM树、Render树和RenderLayer树 【Render树构建】Render树用于表示文档的可视信息，记录了文档中每个可视元素的布局及渲染方式。Render树与DOM树是同时创建的 HTML页面通过CSS控制页面布局，所以RenderObject需要知道自身的CSS属性，CSSStyleSelector负责为元素提供RenderStyle。RenderObject包含自身的RenderStyle的引用。CSSStyleSelector是在CSS解析过程中生成的。Render节点创建后，就会被attach到Render树上 当前Render节点的父节点负责将当前Render节点插入到合适的位置，当父Render节点设置好当前Render节点的前后兄弟节点后，当前Render节点就attach到了Render树上 RenderObject是Render树所有节点的基类，作用类似于DOM树的Node类。这个类存储了绘制页面可视元素所需要的样式及布局信息，RenderObject对象及其子类都知道如何绘制自己。事实上绘制Render树的过程就是RenderObject按照一定顺序绘制自身的过程。DOM树上的节点与Render树上的节点并不是一一对应的。只有DOM树的根节点及可视节点才会创建对应的RenderObject节点 【Render Layer树构建】 RenderLayer树以层为节点组织文档的可视信息，网页上的每一层对应一个RenderLayer对象。RenderLayer树可以看作Render树的稀疏表示，每个RenderLayer树的节点都对应着一棵Render树的子树，这棵子树上所有Render节点都在网页的同一层显示 RenderLayer树是基于RenderObject树构建的，满足一定条件的RenderObject才会建立对应的RenderLayer节点。下面是RenderLayer节点的创建条件： 　　1、网页的root节点 　　2、有显式的CSS position属性（relative，absolute，fixed） 　　3、元素设置了transform 　　4、元素是透明的，即opacity不等于1 　　5、节点有溢出（overflow）、alpha mask或者反射（reflection）效果。 　　6、元素有CSS filter（滤镜）属性 　　7、2D Canvas或者WebGL 　　8、Video元素 当满足这些条件之一时，RenderLayer实例被创建。RenderObject节点与RenderLayer节点是多对一的关系，即一个或多个RenderObject节点对应一个RenderLayer节点。这一点可以理解为网页的一层中可包含一个或多个可视节点。RenderLayer树的根节点是RenderView实例 RenderLayer的一个重要用途是可以在绘制时实现合成加速，即每一个RenderLayer对应系统的一块后端存储，这样在网页内容发生更新时，可以只更新有变化的RenderLayer，从而提高渲染效率 【CSS解析】CSS解析过程即是将原始的CSS文件中包含的一系列CSS规则表示成渲染引擎中相应规则类的实例的过程 解析选择器和解析属性值的过程都可能执行多次。渲染引擎为解析出来的选择器创建一个CSSSelector实例，由于可能存在多个选择器，渲染引擎使用CSSSelectorList类保存所有的选择器，并为解析出来的每个属性值对创建CSSProperty实例 CSS文件解析完成后，CSS规则都保存在了CSSRuleList实例中，这些规则会在创建Render节点的过程中使用到。Node节点通过调用CSSStyleSelector实例的StyleForElement()函数为Render节点创建RenderStyle实例。有了RenderStyle实例才可以创建RenderObject实例。RenderStyle描述了RenderObject的排版布局信息，也就是匹配后的样式信息 CSS规则匹配过程就发生在CSSStyleSelector创建RenderStyle实例的过程中。CSSStyleSelector负责从CSSRuleList中找出所有匹配相应元素的样式属性的Property-Value对 CSS规则匹配是按照选择器类型的优先级进行的，不同类型的选择器具有不同的优先级。常用选择器类型的优先级如下： ID选择器 > 类型选择器 > 标签选择器 > 相邻选择器 > 子选择器 > 后代选择器 所有匹配上元素的CSSStyleRule都会放入一个结果数组中。渲染引擎会对所有存入结果数组中的规则按照选择器的优先级进行排序，高优先级规则优先使用，最终使用的规则会用来创建RenderStyle实例。RenderStyle实例由RenderObject对象持有，RenderObject就是根据RenderStyle中包含的信息，进行自身排版绘制 【JS执行】 JavaScript是一种解释型的动态脚本语言，需要由专门的JavaScript引擎执行。Android 4.2版本的WebKit采用的JavaScript执行引擎为V8，V8是由Google支持的开源项目。它的设计目的就是追求更高的性能，最大限度地提高JavaScript的执行效率。与JavaScriptCore等传统引擎不同，V8把JavaScript代码直接编译成机器码运行，比起传统“中间代码+解释器”的引擎，性能优势非常明显。JS代码通常保存在独立的JS文件中，通过script标签引用到HTML文档中 DOM树创建过程中遇到script标签时会创建HTMLScriptElement实例。HTMLScript-Element的父类ScriptElement中包含了对JS脚本的所有处理，包括下载、缓存、执行等。根据script标签的不同属性，JS脚本加载后的执行时机会有所不同。如果script标签中使用了async属性，JS脚本加载过程不会阻塞文档解析，脚本加载完成后会立即执行。如果script标签中使用了defer属性，JS脚本加载过程不会阻塞文档解析，当脚本的执行要等得到文档解析完成之后。对于外部引用的脚本文件，从脚本下载到脚本执行完，文档解析过程会一直被阻塞 硬件加速 WebKit渲染引擎的渲染方式分为软件渲染和硬件渲染，这两种渲染方式都可以分成两个大的过程：一是得到网页的绘制信息；二是将网页绘制信息转换成像素并上屏 得到网页绘制信息的过程需要遍历RenderLayer树，将RenderLayer树包含的网页绘制信息先记录下来，等到渲染时使用。记录网页绘制信息这一步对渲染引擎而言，就是绘制的过程，渲染引擎本身并不知道绘制命令是否有被真正执行 【软件渲染】软件渲染的流程可概括为以下三步： 1、从SurfaceFlinger获得一块图形缓冲区 2、在封装这块图形缓冲区的SkCanvas上执行网页绘制命令 3、将绘制好的图形缓冲区归还SurfaceFlinger 软件渲染实现简单，网页内容直接绘制到一块图形缓冲区上，内存占用更少。不足之处在于，由于网页内容绘制在同一块图形缓冲区上，更新网页内容时需要全部更新，无法局部更新 【硬件渲染】相较于软件渲染，硬件渲染实现比较复杂，网页内容需要先绘制到一块SkBitmap上，再通过图形缓冲区上传给GPU，需要更多内存 硬件渲染是指网页各层的合成是通过GPU完成的，它采用分块渲染的策略，分块渲染是指：网页内容被一组Tile覆盖，每块Tile对应一个独立的后端存储，当网页内容更新时，只更新内容有变化的Tile。分块策略可以做到局部更新，渲染效率更高 　　硬件渲染的过程分为以下5步： 　　1、在一块封装了SkBitmap的SkCanvas上执行一个Tile覆盖的网页信息的绘制命令； 　　2、将每个Tile对应的SkBitmap copy到从SurfaceFlinger获得的一块图形缓冲区中； 　　3、将所有Tile对应的图形缓冲区上传GPU进行合成； 　　4、将合成好的网页内容blit到Tile对应的与OnScreen FrameBuffer相关联的Texture； 　　5、通过GPU对Tile对应的Texture进行硬件绘制 　　开启硬件渲染，即合成加速，会为需要单独绘制的每一层创建一个GraphicsLayer 合成加速情况下，每一层网页内容都对应一个后端存储，这块后端存储由平台实现，Android 4.2平台提供的后端存储是GraphicsLayerAndroid。开始记录网页绘制命令时，RenderLayerCompositor负责控制RenderLayer的遍历，RenderLayer包含的绘制信息最终记录在其后端存储上，即GraphicsLayerAndroid包含的PicturePile实例中 一个RenderLayer对象如果需要后端存储，它会创建一个RenderLayerBacking对象，该对象负责Renderlayer对象所需要的各种存储。理想情况下，每个RenderLayer都可以创建自己的后端存储，事实上不是所有RenderLayer都有自己的RenderLayerBacking对象。如果一个RenderLayer对象被像样的创建后端存储，那么将该RenderLayer称为合成层（Compositing Layer） 　　哪些RenderLayer可以是合成层呢？如果一个RenderLayer对象具有以下的特征之一，那么它就是合成层： 　　1、RenderLayer具有CSS 3D属性或者CSS透视效果。 　　2、RenderLayer包含的RenderObject节点表示的是使用硬件加速的视频解码技术的HTML5 ”video”元素。 　　3、 RenderLayer包含的RenderObject节点表示的是使用硬件加速的Canvas2D元素或者WebGL技术。 　　4、RenderLayer使用了CSS透明效果的动画或者CSS变换的动画。 　　5、RenderLayer使用了硬件加速的CSSfilters技术。 　　6、RenderLayer使用了剪裁(clip)或者反射(reflection)属性，并且它的后代中包括了一个合成层。 　　7、RenderLayer有一个Z坐标比自己小的兄弟节点，该节点是一个合成层 所以，进行硬件加速的渲染流程如下所示 重绘回流 重绘和回流是在页面渲染过程中非常重要的两个概念。页面生成以后，脚本操作、样式表变更，以及用户操作都可能触发重绘和回流 【回流】 回流reflow是firefox里的术语，在chrome中称为重排relayout 回流是指窗口尺寸被修改、发生滚动操作，或者元素位置相关属性被更新时会触发布局过程，在布局过程中要计算所有元素的位置信息。由于HTML使用的是流式布局，如果页面中的一个元素的尺寸发生了变化，则其后续的元素位置都要跟着发生变化，也就是重新进行流式布局的过程，所以被称之为回流 前面介绍过渲染引擎生成的3个树：DOM树、Render树、Render Layer树。回流发生在Render树上。常说的脱离文档流，就是指脱离渲染树Render Tree 　　触发回流包括如下操作： 　　1、DOM元素的几何属性变化 　　2、DOM树的结构变化 　　3、获取下列属性 offsetTop\\offsetLeft\\offsetWidth\\offsetHeight\\scrollTop\\scrollLeft\\scrollWidth\\scrollHeight\\clientTop\\clientLeft\\clientWidth\\clientHeight\\getComputedStyle()\\currentStyle() 　　4、改变元素的一些样式 　　5、调整浏览器窗口大小 触发回流一定会触发后续的重绘操作，而且对一个元素的回流，可能会影响到父级元素。比如子元素浮动后，父元素会出现高度塌陷的情况。所以，性能优化的重点在于尽量只触发小规模的重绘，尽量不触发回流 【重绘】重绘是指当与视觉相关的样式属性值被更新时会触发绘制过程，在绘制过程中要重新计算元素的视觉信息，使元素呈现新的外观 由于元素的重绘repaint只发生在渲染层 render layer上。所以，如果要改变元素的视觉属性，最好让该元素成为一个独立的渲染层render layer 下面以元素显示为例，进行说明。实现元素显示隐藏的方式有很多 display: none/block，会引起回流，从而引起重绘，性能较差 visibility: visibile/hidden，只引起重绘，但由于没有成为一个独立的渲染层，会引起整个页面（或当前渲染层）的重绘，性能较好 opacity: 0/1，opacity小于1时，会产生render layer。所以opacity在0、1的变化中，引起了render layer的生成和销毁，因此，也会引起回流，从而引起重绘，性能较差。如果opacity: 0/0.9，则只会引起重绘 如果对一个元素使用硬件加速渲染，如具有CSS 3D属性，则不会进行重绘和回流。但如果使用硬件渲染的元素过多，会造成GPU的传输压力 【性能优化】 　　下面列举一些减少回流次数的方法 　　1、不要一条一条地修改DOM样式，而是修改className或者修改style.cssText 　　2、在内存中多次操作节点，完成后再添加到文档中去 　　3、对于一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示 　　4、在需要经常获取那些引起浏览器回流的属性值时，要缓存到变量中 　　5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间 此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围；对于一些进行动画的元素，可以进行硬件渲染，从而避免重绘和回流 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-29 16:43:22 "},"Linux.html":{"url":"Linux.html","title":"Linux","keywords":"","body":"学习资料 鸟哥的Linux私房菜：基础学习篇 第四版 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-29 22:18:39 "},"Linux系统中用户组、文件权限浅解.html":{"url":"Linux系统中用户组、文件权限浅解.html","title":"Linux系统中用户组、文件权限浅解","keywords":"","body":"用户组 在linux中的每个用户必须属于一个组，不能独立于组外。在Linux中每个文件有所有者、所在组、其它组的概念。 【所有者】一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用”ls ‐ahl”命令可以看到文件的所有者，也可以使用”chown 用户名 文件名”来修改文件的所有者。 【所在组】当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组，用”ls ‐ahl”命令可以看到文件的所有组，也可以使用”chgrp 组名 文件名”来修改文件所在的组。 【其它组】除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。 文件权限 在某个有文件的目录执行如下命令 ls -l -rw-r--r-- 展示了不同用户对这个文件的权限信息 第一位有三种取值：文件（-）、目录（d），链接（l），这个例子是-代表是一个文件。 其余9位每3位一组，分别对应所有者，所在组，其他组；读（r）、写（w）、执行（x） 第一组rw-：文件所有者的权限是读、写 第二组r–：与文件所有者同一组的用户拥有读权限 第三组r–：不与文件所有者同组的其他用户拥有读权限 也可用数字表示为：r=4，w=2，x=1 因此rwx=4+2+1=7 -rw-r--r-- 数字表示就是 644 修改文件的权限 chmod 777 mysql.log // 把mysql.log权限修改为777 小结 本文简单的了解下Linux系统下用户 用户组 权限的一些规则。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:19:01 "},"Linux常用bash命令.html":{"url":"Linux常用bash命令.html","title":"Linux常用bash命令","keywords":"","body":"基础操作 export 显示所有环境变量 whereis 使用系统自动构建的数据库来搜索可执行文件，源文件和手册页面。 whereis java which 它在环境变量PATH指定的目录中搜索可执行文件。此命令将打印可执行文件的完整路径。 which php clear 清除窗口 文件操作 ls 列出文件常用选项-l 列出文件详情-a 列出所有文件，包含隐藏文件 touch 创建文件 touch filename cat 列出指定文件的内容 cat filename more 显示文件的第一部分（用空格移动并键入q以退出） more filename head 输出文件的前10行 head filename tail 输出最后10行文件。 tail filename mv 将文件从一个位置移动到另外一个位置 mv f1 f2 // f1 文件的原路径， f2是目标路径 cp 将文件从一个位置移动到另外一个位置 cp f1 f2 // f1 文件的原路径， f2是目标路径 rm 删除文件 rm filename 删除文件 rm -f dirname 删除目录 -d：直接把欲删除的目录的硬连接数据删除成0，删除该目录； -f：强制删除文件或目录； -i：删除已有文件或目录之前先询问用户； -r或-R：递归处理，将指定目录下的所有文件与子目录一并处理； --preserve-root：不对根目录进行递归操作； -v：显示指令的详细执行过程。 diff 比较文件 diff f1 f2 chmod 更改文件的读取，写入和执行权限 chmod -options filename gzip 压缩文件 gzip filename => fi.gz gunzip 解压缩gzip压缩的文件 gunzip filename gzcat 查看gzip压缩文件，而不需要gunzip lpr 打印文件 lpq 查看打印机队列 lprm 从打印队列移除某些内容 lprm jobnumbers 文本操作 awk awk是处理文本文件最有用的命令。它一行一行的在整个文件上运行，默认情况下，它使用空格分隔字段。awk命令最常用的语法是 常用命令 awk '/search_pattern/ { action_to_take_if_pattern_matches; }' file_to_parse 实例：新建一个文件内容是 root:x:0:0:root:/root:/usr/bin/zsh daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync 文件路径：/Users/shiyou/Desktop/temp/awk_test 执行命令 awk -F':' '{ print $1 }' /Users/shiyou/Desktop/temp/awk_test 输出了： 解释：-F 指定在我们要基于哪个分隔字段。在我们代码里面是使用冒号 ':'{print $1} 是指打印出第一个匹配字段 grep 查找文件内的文本。您可以使用grep搜索与一个或多个正则表达式匹配的文本行，并仅输出匹配的行。 grep pattern filename 例如文件还是上面创建的文件，我们执行以下命令 grep -r nologin /Users/shiyou/Desktop/temp/awk_test -i 选项强制grep忽略单词大小写-r 可以用于搜索指定目录下的所有文件 输出： wc 一个文件有多少行，多少单词和多少字符 wc filename sort 排序文本文件的行 sort filename uniq 省略重复的行 uniq filename sort example.txt | uniq // 先排序再去重复 echo 显示一行文字 echo output echo -ne \"Hello\\nWorld\\n\" // 输出换行 tr 把所有小写字母变成大写 cat example.txt | tr 'a-z' 'A-Z' nl 显示文件的行数 nl -s\". \" filename 目录操作 mkdir 生成一个新目录 mkdir dirname cd 一个目录跳转到另外一个目录 cd dirname pwd 告诉你你目前所在的目录 SSH&系统信息&网络操作 ssh ssh 是一个用来登录到远程机器并执行命令的程序 ssh user@host //登录到的机器地址 ssh -p port user@host // 连接到特定端口的选项 whoami 返回当前登录用户名 quota 显示磁盘配额 date 显示当前日期和时间 cal 显示月份的日历 uptime 显示当前的正常运行时间 w 显示谁在线 finger 显示有关用户的信息 finger username uname 显示内核信息 man 显示指定命令的手册 man command df 显示磁盘使用情况 du 显示文件名中文件和目录的磁盘使用情况（du -s只给出一个总数）。 du filename last 列出最后登录的指定用户 last username ps 列出您的进程 ps -u yourusername kill 使用您所提供的ID杀死进程 kill PID killall 用名称杀死所有进程 killall processname top 显示当前活动的进程 bg 列出停止的或后台工作的Job; 恢复在后台停止的Job。 fg 前台化最近的Job ping Pings主机并输出结果 whois 获取域的whois信息。 whois www.baidu.com dig 获取域的DNS信息 dig www.baidu.com wget 下载文件 scp 在本地主机和远程主机之间或两台远程主机之间传输文件。 从本地主机复制到远程主机 scp source_file user@host:directory/target_file 从远程主机复制到本地主机 scp user@host:directory/source_file target_file scp -r user@host:directory/source_folder farget_folder curl 发送一个http请求 curl www.baidu.com 发送一个http请求 curl -v www.baidu.com 详细信息 passwd 允许当前登录的用户更改其密码。 参考文献 bash-guide Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-06 17:32:19 "},"计算机基础.html":{"url":"计算机基础.html","title":"计算机基础","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:37:18 "},"base64.html":{"url":"base64.html","title":"base64原理及引用","keywords":"","body":"前言 base-64作为常见的编码函数，在基本认证、摘要认证以及一些HTTP扩展中得到了大量应用。在前端领域，也常常把图片转换为base-64编码在网络中传输。 原理 Base-64编码可以将任意一组字节转换成较长的常见文本字符序列，从而可以合法地作为首部字段值。Base-64编码将用户输入或二进制数据，打包成一种安全格式，将其作为HTTP首部字段的值发送出去，而无须担心其中包含会破坏HTTP分析程序的冒号、换行符或二进制值 Base-64编码是作为MIME多媒体电子邮件标准的一部分开发的，这样MIME就可以在不同的合法电子邮件网关之间传输富文本和任意的二进制数据了。Base-64编码与将二进制数据文本化表示的uuencode和BinHex标准在本质上很类似，但空间效率更高 【拆分】　　Base-64编码将一个8位字节序列拆散为6位的片段，并为每个6位的片段分配一个字符，这个字符是Base-64字母表中的64个字符之一。这64个输出字符都是很常见的，可以安全地放在HTTP首部字段中。这64个字符中包含大小写字母、数字、+和/，还使用了特殊字符= 下表Base-64的字母表 0 　　A 　 8 　　 I 　 16 　 Q 　　24 　　Y 　 32 　 g 　　40 　 o 　　48 　　w 　 56 　 4 1 B 9 J 17 R 25 Z 33 h 41 p 49 x 57 5 2 C 10 K 18 S 26 a 34 i 42 q 50 y 58 6 3 D 11 L 19 T 27 b 35 j 43 r 51 z 59 7 4 E 12 M 20 U 28 c 36 k 44 s 52 0 60 8 5 F 13 N 21 V 29 d 37 l 45 t 53 1 61 9 6 G 14 O 22 W 30 e 38 m 46 u 54 2 62 + 7 H 15 P 23 X 31 f 39 n 47 v 55 3 63 / [注意]由于Base64编码用8位字符表示信息中的6个位，所以Base-64编码字符串大约比原始值扩大了 33% 【编码实现】下图是一个简单的Base-64编码实例。在这里，三个字符组成的输入值“Ow!”是Base-64编码的，得到的是4个字符的Base-64编码值“T3ch”。它是按以下方式工作的 1、字符串“Ow!”被拆分成3个8位的字节(0x4F、0x77、0x21) 2、这3个字节构成了一个24位的二进制值010011110111011100100001 3、这些位被划分为一些6位的序列010011、110111、01110、100001 4、每个6位值都表示了从0-63之间的一个数字，对应Base-64字母表中64个 字符之一。得到的Base-64编码字符串是个4字符的字符串“T3ch”，然后就可 以通过线路将这个字符串作为“安全的”8位字符传送出去，因为只用了一些 移植性最好的字符(字母、数字等) 【填充】 Base-64编码收到一个8位字节序列，将这个二进制序列流划分成6位的块。二进制序列有时不能正好平均地分成6位的块，在这种情况下，就在序列末尾填充零位，使二进制序列的长度成为24的倍数(6和8的最小公倍数) 对已填充的二进制串进行编码时，任何完全填充(不包含原始数据中的位)的6位组都由特殊的第65个符号“=”表示。如果6位组是部分填充的，就将填充位设置为0 下表显示了一些填充实例 初始输入字符串“a:a”为3字节(24位)。24是6和8的倍数，因此无需填充，得到的Base-64编码字符串为“YTph” 然而，再增加一个字符，输入字符串会变成32位长。而6和8的下一个公倍数是48，因此要添加16位的填充码。填充的前4位是与数据位混合在一起的。得到的6位组01xxxx，会被当作010000、十进制中的16，或者Base-64编码的Q来处理。剩下的两个6位组都是填充码，用“=”表示 应用 网页上的每一个图片，都需要消耗一个http请求下载而来的。所以，才有了雪碧图技术 无论如何，图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，而可以随着HTML的下载同时下载到本地那就太好了，而base64正好能解决这个问题 前面提到过Base-64编码字符串大约比原始值扩大了33%。所以，不是所有的图片使用base-64编码都合适 但是，如果图片足够小且因为用处的特殊性(如需要平铺等)无法被制作成雪碧图，在整个网站的复用性很高且基本不会被更新。那么此时使用base64编码传输图片就可谓好钢用在刀刃上 比如，一个只有50字节的2px*2px的背景图。将其转化成base64编码，只有100多个字符，相比一个http请求，这种转换无疑更值得推崇 字符串编码 对于字符串来说，在javaScript中，有2个函数分别用来处理解码和编码base64字符串：atob()和btoa() btoa()函数能够从二进制数据“字符串”创建一个base-64编码的ASCII字符串；相反地，atob()函数能够解码通过base-64编码的字符串数据。 btoa('abc') //'YWJj' // 字符串 -> base64 atob('YWJj') //'abc' // base64 -> 字符串 [注意]IE9-浏览器不支持 但是，以上方法有局限性，就是无法转换中文 这时，就需要使用编码方法，先转换为btoa()识别的字符，再进行base64编码，如可以使用encodeURI()方法 btoa(encodeURI('小狮子')); // 字符串 -> base64 decodeURI(atob(str)); // base64 -> 字符串 图片编码 使用文件File API的readAsDataURL()方法，可以将文件以数据URI(进行Base64编码)形式保存在result属性中 //base64转换函数 function base64(file){ if(file){ if(/image/.test(file.type)){ var reader = new FileReader(); reader.readAsDataURL(file); reader.onload = function(){ fileData.innerHTML = reader.result; } }else{ alert(\"You must select a valid image file!\"); } } } 更多关于图片上传的问题可以参考文章>>> 前端上传文件的理解 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 11:34:34 "},"前端框架.html":{"url":"前端框架.html","title":"前端框架","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:38:03 "},"react.html":{"url":"react.html","title":"react","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:22:44 "},"react实战项目开发1搭建react开发环境初始化项目（Create-react-app）.html":{"url":"react实战项目开发1搭建react开发环境初始化项目（Create-react-app）.html","title":"react实战项目开发(1) 搭建react开发环境初始化项目（Create-react-app）","keywords":"","body":"前言 Create React App npm install -g create-react-app create-react-app my-app cd my-app npm start 执行命令后新建项目：study-react可以看下项目基本目录： 工程目录介绍 【node_modules】 项目依赖的包文件都在这里 【package.json】 { \"name\": \"study-react\", // 项目名称 \"version\": \"0.1.0\", // 当前版本(默认是0.1.0) \"private\": true, // 项目是否私有 \"dependencies\": { // 项目依赖哪些模块 \"react\": \"^16.8.6\", \"react-dom\": \"^16.8.6\", \"react-scripts\": \"2.1.8\" }, \"scripts\": { // 项目的脚本命令,我们执行 npm run start 等于执行 react-scripts start \"start\": \"react-scripts start\", \"build\": \"react-scripts build\", \"test\": \"react-scripts test\", \"eject\": \"react-scripts eject\" }, \"eslintConfig\": { \"extends\": \"react-app\" // 使用 JavaScript、JSON 或者 YAML 文件为整个目录（处理你的主目录）和它的子目录指定配置信息。可以配置一个独立的 .eslintrc.* 文件，或者直接在 package.json 文件里的 eslintConfig 字段指定配置，ESLint 会查找和自动读取它们。 }, \"browserslist\": [ // 这代表这个项目的浏览器兼容情况 \">0.2%\", \"not dead\", \"not ie 【public目录】favicon.ico：页面左上角的图标 index.html：入口的HTML页面 manifest: PWA相关，做离线使用(这里不展开讲解) 【src目录】 项目的代码存放目录 整个项目的入口文件：index.js(主要用于把入口组件挂载到HTML上) import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; // 自定义的组件 // 当项目部署到https协议的服务上，第一次访问需要网络，一旦加载完成后如果此时断网，还是可以访问刚刚的页面 import * as serviceWorker from './serviceWorker'; ReactDOM.render(, document.getElementById('root')); // 将组件App 挂载HTML的 root元素下，这样界面就可以显示App组件的内容了 serviceWorker.unregister(); App.js：App组件的定义文件 import React, { Component } from 'react'; import logo from './logo.svg'; import './App.css'; class App extends Component { render() { // jsx 相关内容 return ( Edit src/App.js and save to reload. Learn React ); } } export default App; // 提供对外的引用 App.test.js： 组件单元测试文件 App.css：组件样式文件 小结 通过本文我们学习了 初始化react环境 初始化项目文件的介绍 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:27:34 "},"react实战项目开发2react几个重要概念以及JSX语法.html":{"url":"react实战项目开发2react几个重要概念以及JSX语法.html","title":"react实战项目开发(2) react几个重要概念以及JSX语法","keywords":"","body":"前言 前面我们已经学习了利用官方脚手架搭建一套可以应用在生产环境下的React开发环境。那么今天这篇文章主要先了解几个react重要的概念，以及讲解本文的重要知识JSX语法 React重要概念 【思想】React 的核心思想是：封装组件，各个组件维护自己的状态和 UI，当状态变更，自动重新渲染整个组件。如果我们使用react编写的话，会把他拆分成一个一个的小组件进行编写方便管理复用性高，例如我们把登录拆分成一个组件编写，如果以后公司其它地方需要用到，那么就可以直接使用。 看一段代码感受下： import React, { Component } from 'react'; import { render } from 'react-dom'; class HelloMessage extends Component { render() { return Hello {this.props.name}; } } // 加载组件到 DOM 元素 mountNode render(, mountNode); 【组件】React 应用都是构建在组件之上。 上面的 HelloMessage 就是一个 React 构建的组件，最后一句 render 会把这个组件显示到页面上的某个元素 mountNode 里面，显示的内容就是 \\Hello John\\。 props 是组件包含的两个核心概念之一，另一个是 state（这个组件没用到）。可以把 props 看作是组件的配置属性，在组件内部是不变的，只是在调用这个组件的时候传入不同的属性（比如这里的 name）来定制显示这个组件。 【JSX】从上面的代码可以看到将 HTML 直接嵌入了 JS 代码里面，这个就是 React 提出的一种叫 JSX 的语法，这应该是最开始接触 React 最不能接受的设定之一，因为前端被“表现和逻辑层分离”这种思想“洗脑”太久了。但实际上组件的 HTML 是组成一个组件不可分割的一部分，能够将 HTML 封装起来才是组件的完全体，React 发明了 JSX 让 JS 支持嵌入 HTML 不得不说是一种非常聪明的做法，让前端实现真正意义上的组件化成为了可能。 好消息是你可以不一定使用这种语法，后面会进一步介绍 JSX，到时候你可能就会喜欢上了。现在要知道的是，要使用包含 JSX 的组件，是需要“编译”输出 JS 代码才能使用的。 【Virtual DOM】当组件状态 state 有更改的时候，React 会自动调用组件的 render 方法重新渲染整个组件的 UI。 当然如果真的这样大面积的操作 DOM，性能会是一个很大的问题，所以 React 实现了一个Virtual DOM，组件 DOM 结构就是映射到这个 Virtual DOM 上，React 在这个 Virtual DOM 上实现了一个 diff 算法，当要重新渲染组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以实际上不是真的渲染整个 DOM 树。这个 Virtual DOM 是一个纯粹的 JS 数据结构，所以性能会比原生 DOM 快很多。 【Data Flow】“单向数据绑定”是 React 推崇的一种应用架构的方式。当应用足够复杂时才能体会到它的好处，虽然在一般应用场景下你可能不会意识到它的存在，也不会影响你开始使用 React，你只要先知道有这么个概念。 JSX语法 看如下变量的定义：如果是字符串应该添加引号，但是却直接把DOM结构赋值给一个变量？什么操作？这就是JSX const element = Hello, world!; 它被称为 JSX， 一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 JSX 来描述用户界面。JSX 看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。 【语法糖】本质上讲JSX只是为React.createElement(component, props, ...children) 方法提供的语法糖 Click Me 等同于下面 React.createElement( MyButton, {color: 'blue', shadowSize: 2}, 'Click Me' ) 使用上篇文章搭建好的项目，并进行瘦身，然后新建一个组件JsxCom.js 并且引入到App.js中，代码如下： App.js import React, { Component } from 'react'; import JsxCom from './JsxCom'; class App extends Component { render() { return ( ); } } export default App; JsxCom.js import React, { Component } from 'react'; class JsxCom extends Component { render() { return ( ); } } export default JsxCom; JSX 规则 以下几点是刚开始写React时比较容易忽视的规则 【制定React元素】 首字母大写的类型表示 JSX 标签引用到一个 React 组件。这些标签将会被编译为直接引用同名变量，所以如果你使用了 JSX 表达式，则 JsxCom 必须在作用域中。 【React 必须在作用域中】由于 JSX 编译成React.createElement方法的调用，所以在你的 JSX 代码中，React库必须也始终在作用域中。也就是最上面必须引入React 【用户定义组件必须首字母大写】当元素类型以小写字母开头时，它表示一个内置的组件，如 或 ，将导致字符串 'div' 或 'span' 传递给 React.createElement。 以大写字母开头的类型，如 编译为 React.createElement(Foo)，并且它正对应于你在 JavaScript 文件中定义或导入的组件。 【在运行时选择类型】 const components = { photo: PhotoStory, video: VideoStory }; function Story(props) { // 错误！JSX 标签名不能为一个表达式。 return ; } 如下方式才是正确的： function Story(props) { // 正确！JSX 标签名可以为大写开头的变量。 const SpecificStory = components[props.storyType]; return ; } JSX 语法 【JSX的属性(Props)表达式】你可以传递JavaScript 表达式作为一个属性，再用大括号{}括起来。例如，在这个 JSX 中： 【在 JSX 中使用表达式】 直接看代码 class JsxCom extends Component { user = { firstName: 'Harper', lastName: 'Perez' }; formatName(user) { return user.firstName + ' ' + user.lastName; } render() { return ( Hello, {this.formatName(this.user)}! ); } } 分析：定义了一个字面量对象user，定义了一个函数formatName，输出一个字符串。最后我们在render函数中{this.formatName(this.user)} 使用该函数 【JSX中if语句和for语句的应用】 if 语句和 for 循环在 JavaScript 中不是表达式，因此它们不能直接在 JSX 中使用，但是你可以将它们放在周围的代码中。例如： function NumberDescriber(props) { let description; if (props.number % 2 == 0) { description = even; } else { description = odd; } return {props.number} is an {description} number; } 【字符串常量】 【JSX 属性】 // 使用引号来定义以字符串为值的属性 const element = ; // 使用表达式 const element = ; 因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。 例如，class 变成了 className，而 tabindex 则对应着 tabIndex。 【属性默认为“True”】如果你没有给属性传值，它默认为 true。 等价于 【展开属性】如果你已经有了个 props 对象，并且想在 JSX 中传递它，你可以使用 ... 作为“展开(spread)”操作符来传递整个属性对象。下面两个组件是等效的： function App1() { return ; } function App2() { const props = {firstName: 'Ben', lastName: 'Hector'}; return ; } 【JSX中的子代】在既包含开始标签又包含结束标签的 JSX 表达式中，这两个标签之间的内容被传递为专门的属性：props.children。 [1]字符串字面量你可以在开始和结束标签之间放入一个字符串，则 props.children 就是那个字符串。这对于许多内置 HTML 元素很有用。 Hello world! 这是有效的 JSX，并且 MyComponent 的 props.children 值将会直接是 \"hello world!\" [2]嵌套React组件 [3]JavaScript 表达式作为子代你可以将任何 {} 包裹的 JavaScript 表达式作为子代传递。例如，下面这些表达式是等价的： foo {'foo'} [4]函数作为子代通常情况下，插入 JSX 中的 JavaScript 表达式将被认作字符串、React 元素或这些的一个列表。然而，props.children 可以像其它属性一样传递任何种类的数据，而不仅仅是 React 知道如何去渲染的数据种类。例如，如果你有一个自定义组件，你能使其取一个回调作为props.children： // Calls the children callback numTimes to produce a repeated component function Repeat(props) { let items = []; for (let i = 0; i {items}; } function ListOfTenThings() { return ( {(index) => This is item {index} in the list} ); } 传递给自定义组件的子代可以是任何东西，只要该组件在 React 渲染前将其转换成 React 能够理解的东西。这个用法并不常见，但当你想扩展 JSX 时可以使用。 【布尔值、Null 和 Undefined 被忽略】false、null、undefined 和 true 都是有效的子代，只是它们不会被渲染。下面的JSX表达式将渲染为相同的东西： {false} {null} {undefined} {true} 相反，如果你想让类似 false、true、null 或 undefined 出现在输出中，你必须先把它转换成字符串 : My JavaScript variable is {String(myVariable)}. 【JSX 防注入攻击】 const title = response.potentiallyMaliciousInput; // 直接使用是安全的： const element = {title}; React DOM 在渲染之前默认会 过滤 所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:31:17 "},"angular.html":{"url":"angular.html","title":"angular","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 11:50:43 "},"Angular项目初始化.html":{"url":"Angular项目初始化.html","title":"Angular 项目初始化","keywords":"","body":"下载所需依赖 【安装node】官网下载 安装angular/cli npm install -g angular/cli 安装好后：ng --version 创建一个项目 ng new taskmgr 样式默认使用less: --style less 启动一个项目 ng serve 启动开发服务器 几个常用的指令 npm i --save 软件依赖 npm i --save-dev 开发依赖(例如单元测试的包) ng new packageName 新建Anuglar项目 ng build -prod 生成环境编译 ng serve 启动开发服务器 npm cache clean 清除缓存 json-server json-server可以直接把一个json文件托管成一个具备全RESTful风格的API,并支持跨域、jsonp、路由订制、数据快照保存等功能的 web 服务器。 安装：npm install -g json-server Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 09:22:47 "},"ng常用命令.html":{"url":"ng常用命令.html","title":"ng 常用命令","keywords":"","body":"常用指令 创建一个工程：ng new projectName 创建一个模块：ng generate module app-routing || ng g m moduleName 创建一个组件：ng generate component componentName || ng g c componentName 创建一个指令：ng g d directiveName 创建一个路由：ng generate module app-routing --flat --module=app || ng g m app-routing --flat --module=app 启动服务：ng serve 构建一个项目：ng build -prod（生产环境打包） 查询ng版本：ng -v 生成一个测试文件：ng g class message/message --spec=true 通用后缀 测试文件不创建：--spec=false 创建的组件的样式文件为scss：—style=scss --inline-style(ng generate component hero-app --inline-style) 创建组件时，cli会自动顶一个空的styles数组 不安装依赖：--skip-install 简写：-si 把文件放进了src/app中，而不是单独的目录中：--flat 告诉CLI把它注册到AppModule的imports数组中 --module=app Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:32:31 "},"Angular模板语法.html":{"url":"Angular模板语法.html","title":"Angular 模板语法","keywords":"","body":"常见用法 如果必须读取目标元素上的属性或调用它的某个方法，得用另一种技术。 参见 API 参考手册中的 ViewChild 和 ContentChild。 动态改变样式和类名，请使用NgClass和NgStyle 插值表达式 => {{...}} Angular 对所有双花括号中的表达式求值，把求值的结果转换成字符串，并把它们跟相邻的字符串字面量连接起来。最后，把这个组合出来的插值结果赋给元素或指令的属性。 {{ hero.name }} // 插入标签 //插入属性 {{i+1}} //可以是表达式 {{getVal()+i}} //可以调用组件方法 模板表达式 模板表达式产生一个值。 Angular 执行这个表达式，并把它赋值给绑定目标的属性，这个绑定目标可能是 HTML 元素、组件或指令。 [property]=\"expression\" //isUnchanged的引用的是组件的变量 表达式上下文 典型的表达式上下文就是这个组件实例，它是各种绑定值的来源 {{hero.name}} // hero 是模板输入变量 {{heroInput.value}} // #heroInput 是模板引用变量 表达式上下文变量由三者组成 模板变量(如：let hero) 上下文变量(如：#heroInput) 组件成员变量 优先级：模板变量 > 上下文变量 > 组件成员变量 表达式指南 模板表达式能成就或毁掉一个应用，请遵循下列指南 1、没有可见的副作用 模板表达式除了目标属性的值以外，不应该改变应用的任何状态 2、执行迅速 Angular 会在每个变更检测周期后执行模板表达式。 它们可能在每一次按键或鼠标移动后被调用。 3、非常简单 虽然也可以写出相当复杂的模板表达式，但不要那么写。 4、幂等性 最好使用幂等的表达式，因为它没有副作用，并且能提升 Angular 变更检测的性能。幂等的表达式应该总是返回完全相同的东西，直到某个依赖值发生改变。 模板语句 用来响应由绑定目标触发的事件 代码展示 特别之处在于它支持基本赋值 (=) 和表达式链 (; 和 ,)。 某些语法还是不适用： new操作符 ++ -- 操作并赋值 +=和-= 位操作符 |和& 模板的 $event 对象、模板输入变量 (let hero)和模板引用变量 (#heroForm)传给了组件中的一个事件处理器方法 实际项目中，就是通过这样传递和组件进行交互的 Save // 传入$event对象 {{hero.name}} //传入模板输入变量，而不是组件中hero属性 ... 特别注意：模板语句不能引用全局命名空间的任何东西。比如不能引用window或document,也不能使用console.log或math.max 数据绑定语法 根据数据流向分三类 从数据源到视图 从视图到数据源 从视图到数据源再到视图 从数据源到视图 {{expression}} [target] = \"expression\" bind-target = \"expression\" //同上面一种写法一样，一般不这样写 从视图到数据源的单向绑定(事件绑定) (target)=\"statement\" ; (click)=\"add($event)\" on-target = \"statement\" ; // 一般不这样写 双向数据绑定 [(target)]=\"expression\" bindon-target=\"expression\" 综上可以有这个简单的记忆方法 bind = [] on = () bindon = [()] 理解HTML attribute 与 DOM property的对比 想要理解Angular绑定如何工作，重点就是搞清楚 HTML attribute和DOM property 之间的区别 attribute是由HTML定义的。property是由DOM(Document Object Model) 少量HTML attribute 和 property 之间有着1:1的映射，如id 有些HTML attribute 没有对应的 property , 如 colspan 有些DOM property 没有对应的 attribute，如 textContent 大量HTML attribute 看起来映射到了 property 但却不像你想的那样 attribute初始化DOM property,然后它们的任务就完成了。property的值可以改变；attribute的值不能改变 例如 attribute指定了初始值bob property则是当前值 重点：模板绑定是通过property和事件来工作的，而不是attribute 在Angular的世界中，attribute唯一的作用是用来初始化元素和指令的状态。当进行数据绑定时，只是在与元素和指令的property和事件打交道，而attribute就完全靠边站了。 绑定目标 属性绑定 //绑定src属性 //组件注入hero属性 // class属性 //插入HTML 事件绑定 //元素的事件 //组件的事件传递 子=>父的传递 //指令的事件 双向数据绑定 它是属性绑定和事件绑定的语法糖 Resizable Text | | //如果能在想这样的HTML元素上使用双向数据绑定就更好了，可惜，原生HTML元素不遵循x值和xChange事件的模式。Angular以NgModel指令为桥梁，允许在表单元素上使用双向数据绑定 Attribute（attribute例外情况,一般情况下是不会使用到attribute绑定的，但是当一个元素没有属性可绑定的时候，就必须使用attribute绑定，例如table中的colspan/rowspan属性） help //会报模板解析错误 //会正确展示 css类,以下方法可以使用ngClass替代，一次性可以判断多个 special //如果isSpecial为真就会添加special 样式 带单位的绑定，如font-size Big 使用属性绑定([xx]=\"\")还是插值表达式{{}} //插值表达式 //属性绑定 正常来说用谁都是可以达到同样的效果，项目中还是选择一种统一的风格进行 有一个特殊情况：数据类型不是字符串时，就必须使用属性绑定 插入安全内容 angular数据绑定对危险HTML有防备，不管是插值表达式还是属性绑定，都不会允许带有script标签的HTML泄露到浏览器 内置指令 内置属性指令 属性指令会监听和修改其它HTML元素或组件的行为、元素属性(attribute)、DOM属性(property).它们通常会作为HTML属性的名称而应用在元素上 NgClass - 添加或移除一组css类 NgStyle - 添加或移除一组css样式 NgModel - 双向绑定到HTML表单元素 NgClass 通过绑定NgClass，可以同时添加或移除多个类 模板代码： 组件代码： this.currentClasses = { 'saveable': this.canSave, 'modified': !this.isUnchanged, 'special': this.isSpecial }; // 它将会根据三个其它组件的状态为true或false而添加或移除三个类 NgStyle 模板代码： 组件代码： currentStyles: {}; setCurrentStyles() { // CSS styles: set per current state of component properties this.currentStyles = { 'font-style': this.canSave ? 'italic' : 'normal', 'font-weight': !this.isUnchanged ? 'bold' : 'normal', 'font-size': this.isSpecial ? '24px' : '12px' }; } NgModel 使用[(ngModel)]双向绑定到表单元素，必须导入 FormsModule并把它添加到Angular模块的imports列表中。 代码展示： import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { FormsModule } from '@angular/forms'; // 使用如下： 同样可以使用以下代码 ngModel指令通过自己的输入属性ngModel和输出属性ngModelChange 隐藏了那些细节 使用这种ngModel展开形式有什么作用呢？例如： 你不能把 [(ngModel)]用到非表单类的原生元素或第三方自定义组件上，除非写一个合适的值访问器 内置结构型指令 结构型指令的职责是HTML布局。它们塑造或重塑DOM的结构，这通常是通过添加、移除和操纵它们所附加到的宿主元素来实现的。 要点 结构型指令的名字前加上 “*”前缀 当没有合适的宿主元素放置指令时，可用 对元素进行分组 只能往一个元素上应用一个结构型指令 3个结构型指令 NgIf 根据条件把一个元素添加到DOM中或从DOM移除 NgSwitch一组指令，用来在多个可选视图之间切换 NgForOf 对列表中的每个条目重复套用同一个模板 NgIf else写法 这和显示/隐藏不是一回事,如果需要显示隐藏可以控制类 NgForOf NgFor是一个重复器指令 {{hero.name}} 带trackBy的*ngFor ngFor 指令有时候会性能较差，特别是在大型列表中。 对一个条目的一丁点改动、移除或添加，都会导致级联的 DOM 操作。 组件中 trackByHeroes(index:number,hero:Hero):number{ return hero.id; } 模板中 ({{hero.id}}) {{hero.name}} 相当于使用id对列表进行标记，这样对列表进行删除时，可以不用全部替换DOM了 NgSwitch指令 NgSwitch指令类似于js的switch语句，它可以从多个可能的元素中根据switch条件来显示某一个。Angular只会把选中的元素放进DOM中。 ng-template 它是一个Angular元素，用来渲染HTML，它永远不会直接显示出来，事实上，在渲染视图之前，Angular会把 ng-template 及其内容替换为一个注释。 如果没有结构型指令，而仅仅把一些别的元素包装进 ng-template 中，那些元素就是不可见的 Hip! Hip! Hooray! Hip! 是不显示的 ng-container 把一些兄弟元素归为一组 通常都要有一个根元素作为结构型指令的数组。列表元素（）就是一个典型的供NgFor使用的宿主元素 模板引用变量(#var) 通常用来引用模板中的某个DOM元素，它还可以引用Angular组件或指令或Web Component //#phone的意思就是声明一个名叫phone的变量来引用input元素 可以使用ref替代# 我们可以在模板中的任何地方引用模板引用变量 输入和输出属性 输入属性：@Input 当它通过“属性绑定”的形式被绑定时，值会“流入”这个属性 输出属性：@Output 这个属性几乎总是返回EventEmitter。当它通过“事件绑定”的形式被绑定时，值会“流出”这个属性 组件中的书写方式 @Input() hero:Hero; @Output() deleteRequest = new EventEmitter(); //定义别名 @Output('myClick') clicks = new EventEmitter(); 指令中的书写方式 @Component({ inputs:['hero'], outputs:['myDelete:deleteRequest'],//这个myDelete是别名 }) 管道操作符 uppercase管道操作符 Title through uppercase pipe:{{title | uppercase}} 多个管道操作符并行使用 Title through uppercase pipe:{{title | uppercase | lowercase}} 使用参数的管道 Birthdate:{{currentHero?.birthdate | date:'longDate'}} json管道对调试绑定特别有用： {{currentHero | json}} 安全导航操作符(?.)和空属性路径 用来保护出现在属性路径中 null 和 undefined 值。 The current hero's name is {{currentHero.name}} 假设currentHero中没有name属性，则会报错，整个视图错误 使用安全导航操作符,就可以避免视图错误，但是如果是必须存在的值，还是不应该使用安全导航操作符 The current hero's name is {{currentHero?.name}} 使用NgIf代码环绕它来解决这个问题 The null hero's name is {{nullHero.name}} 亦或使用 && 来解决 The null hero's name is {{nullHero && nullHero.name}} 非空断言操作符(!) 在 TypeScript 2.0 中，你可以使用 --strictNullChecks 标志强制开启严格空值检查。TypeScript 就会确保不存在意料之外的 null 或 undefined。 这种模式下，有类型的变量默认是不允许 null 或 undefined 值的，如果有未赋值的变量，或者试图把 null 或 undefined 赋值给不允许为空的变量，类型检查器就会抛出一个错误。 如果类型检查器在运行期间无法确定一个变量是 null 或 undefined，那么它也会抛出一个错误。 你自己可能知道它不会为空，但类型检查器不知道。 所以你要告诉类型检查器，它不会为空，这时就要用到非空断言操作符。 The hero's name is {{hero!.name}} 在Angular编译器把你的模板转换成TypeScript代码时，这个操作符会防止TypeScript报告\"hero.name\"可能为null或undefined的错误 类型转换函数 $any ($any()) 有时候，绑定表达式可能会报类型错误、并且它不能或很难指定类型。要消除这种报错，你可以使用 $any 转换函数来把表达式转换成 any 类型 The hero's marker is {{$any(hero).marker}} 当 Angular 编译器把模板转换成 TypeScript 代码时，$any 表达式可以防止 TypeScript 编译器报错说 marker 不是 Hero 接口的成员。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:37:29 "},"Angular生命周期.html":{"url":"Angular生命周期.html","title":"Angular 生命周期","keywords":"","body":"每个组件都有一个被Angular管理的生命周期 Angular创建它，渲染它，创建并渲染它的子组件，在它被绑定的属性发生变化时检查它，并在它从DOM中被移除前销毁它。 声明周期的顺序 钩子 用途及时机 ngOnChanges() 当被绑定的输入属性的值发生变化时调用,首次调用一定会发生在ngOnInit（）之前 ngOnInit() 在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件 ngDoCheck() 检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个 Angular 变更检测周期中调用，ngOnChanges() 和 ngOnInit() 之后。 ngAfterContentChecked 每次完成被投影组件内容的变更检测之后调用。 ngAfterViewInit() 初始化完组件视图及其子视图之后调用。 ngAfterViewChecked() 每次做完组件视图和子视图的变更检测之后调用 ngOnDestory() 当Angular每次销毁指令/组件之前调用并清除。在这儿反订阅可观察对象和分离事件处理器，以防内存泄露 OnInit()钩子 这里是放置复杂初始化逻辑的好地方 在构造函数之后马上执行复杂的初始化逻辑 在Angular设置完输入属性之后，对该组件进行准备 OnChanges()钩子 一旦检测到该组件(或指令)的输入属性(@Input)发生了变化，Angular就会调用它的ngOnChanges()方法。 ngOnChanges(changes: SimpleChanges) { for (let propName in changes) { let chng = changes[propName]; let cur = JSON.stringify(chng.currentValue); let prev = JSON.stringify(chng.previousValue); this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`); } } DoCheck()钩子 使用DoCheck钩子来检测那些Angular自身无法捕获的变更并采取行动 虽然 ngDoCheck() 钩子可以可以监测到英雄的 name 什么时候发生了变化。但其开销很恐怖。 这个 ngDoCheck 钩子被非常频繁的调用 —— 在每次变更检测周期之后，发生了变化的每个地方都会调它。 在这个例子中，用户还没有做任何操作之前，它就被调用了超过二十次。 AfterView钩子 AfterView例子展示了AfterViewInit()和AfterViewChecked钩子，Angular会在每次创建了组件的子视图后调用它们。 AfterViewChecked钩子也是会被频繁调用 AfterContent钩子 AfterContent钩子和AfterView相似。关键的不同点是子组件的类型不同。 AfterView钩子所关心的是ViewChildren，这些子组件的元素标签会出现在该组件的模板里面 AfterContent钩子所关心的是ContentChildren，这些子组件被Angular投影进该组件中。 代码展示： export class AfterContentComponent implements AfterContentChecked, AfterContentInit { private prevHero = ''; comment = ''; // 获取子组件的内容 @ContentChild(ChildComponent) contentChild: ChildComponent; // 子组件的内容初始化 ngAfterContentInit() { // contentChild is set after the content has been initialized this.logIt('AfterContentInit'); this.doSomething(); } // 子组件内容发生变化时 ngAfterContentChecked() { // contentChild is updated after the content has been checked if (this.prevHero === this.contentChild.hero) { this.logIt('AfterContentChecked (no change)'); } else { this.prevHero = this.contentChild.hero; this.logIt('AfterContentChecked'); this.doSomething(); } } // ... } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:38:48 "},"Angular组件交互.html":{"url":"Angular组件交互.html","title":"Angular 组件交互","keywords":"","body":"父 -> 子 通过输入型把数据从父组件传到子组件 父组件 子组件 export class HeroChildComponent { @Input() hero: Hero; @Input('master') masterName: string; } 给master属性起了一个别名masterName 通过setter截听输入属性值的变化 父组件 子组件 export class NameChildComponent { private _name = ''; @Input() set name(name: string) { this._name = (name && name.trim()) || ''; } get name(): string { return this._name; } } 通过ngOnChanges()来截听输入属性值得变化 使用OnChanges生命周期钩子接口的ngOnChanges()方法来监测输入属性值得变化并做出回应。 父组件 import { Component } from '@angular/core'; @Component({ selector: 'app-version-parent', template: ` Source code version New minor version New major version ` }) export class VersionParentComponent { major = 1; minor = 23; newMinor() { this.minor++; } newMajor() { this.major++; this.minor = 0; } } 子组件 export class VersionChildComponent implements OnChanges { @Input() major: number; @Input() minor: number; changeLog: string[] = []; ngOnChanges(changes: {[propKey: string]: SimpleChange}) { let log: string[] = []; for (let propName in changes) { let changedProp = changes[propName]; let to = JSON.stringify(changedProp.currentValue); if (changedProp.isFirstChange()) { log.push(`Initial value of ${propName} set to ${to}`); } else { let from = JSON.stringify(changedProp.previousValue); log.push(`${propName} changed from ${from} to ${to}`); } } this.changeLog.push(log.join(', ')); } } 子 -> 父 父组件监听子组件的事件 子组件 export class VoterComponent { @Input() name: string; @Output() voted = new EventEmitter();//==>1 声明EventEmitter didVote = false; vote(agreed: boolean) { this.voted.emit(agreed); //==>2 向外发射事件 this.didVote = true; } } 父组件 import { Component } from '@angular/core'; @Component({ selector: 'app-vote-taker', template: ` Should mankind colonize the Universe? Agree: {{agreed}}, Disagree: {{disagreed}} //1==>父组件使用onVoted($event)进行接收 ` }) export class VoteTakerComponent { agreed = 0; disagreed = 0; voters = ['Mr. IQ', 'Ms. Universe', 'Bombasto']; //2==>定义接收函数以及参数 onVoted(agreed: boolean) { agreed ? this.agreed++ : this.disagreed++; } } 父组件与子组件通过“本地变量”互动 父组件不能使用数据绑定来读取子组件的属性或调用子组件的方法。但可以在父组件模板里，新建一个本地变量来代表子组件，然后利用这个变量来读取子组件的属性和调用子组件的方法 子组件 import { Component, OnDestroy, OnInit } from '@angular/core'; @Component({ selector: 'app-countdown-timer', template: '{{message}}' }) export class CountdownTimerComponent implements OnInit, OnDestroy { intervalId = 0; message = ''; seconds = 11; clearTimer() { clearInterval(this.intervalId); } ngOnInit() { this.start(); } ngOnDestroy() { this.clearTimer(); } start() { this.countDown(); } stop() { this.clearTimer(); this.message = `Holding at T-${this.seconds} seconds`; } private countDown() { this.clearTimer(); this.intervalId = window.setInterval(() => { this.seconds -= 1; if (this.seconds === 0) { this.message = 'Blast off!'; } else { if (this.seconds 父组件 import { Component } from '@angular/core'; import { CountdownTimerComponent } from './countdown-timer.component'; @Component({ selector: 'app-countdown-parent-lv', template: ` Countdown to Liftoff (via local variable) Start//2==>引用子组件方法 Stop//3==>引用子组件方法 {{timer.seconds}}//4==>引用子组件变量 //1==>定义变量 `, styleUrls: ['../assets/demo.css'] }) export class CountdownLocalVarParentComponent { } 父组件调用@ViewChild() “本地变量”方法是个简单便利的方法。但是它有局限性。因为父组件-子组件的连接必须全部在父组件的模板中进行。父组件本身的代码对子组件没有访问权 如果父组件的类需要读取子组件的属性值或调用子组件的方法，就不能使用“本地变量”方法 当父组件类需要这种访问时，可以把子组件作为ViewChild，注入到父组件里面 子组件代码同上面一样 父组件代码 import { AfterViewInit, ViewChild } from '@angular/core';//1==>引入对象 import { Component } from '@angular/core'; import { CountdownTimerComponent } from './countdown-timer.component'; @Component({ selector: 'app-countdown-parent-vc', template: ` Countdown to Liftoff (via ViewChild) Start Stop {{ seconds() }} `, styleUrls: ['../assets/demo.css'] }) export class CountdownViewChildParentComponent implements AfterViewInit {//2==>挂上AfterViewInit生命周期的钩子 @ViewChild(CountdownTimerComponent)//2==>把子组件注入到父组件中 private timerComponent: CountdownTimerComponent;//3==>定义相应的变量接收 seconds() { return 0; } ngAfterViewInit() { //5==> ngAfterViewInit() 生命周期钩子是非常重要的一步。被注入的计时器组件只有在 Angular 显示了父组件视图之后才能访问，所以它先把秒数显示为 0. 然后 Angular 会调用 ngAfterViewInit 生命周期钩子，但这时候再更新父组件视图的倒计时就已经太晚了。Angular 的单向数据流规则会阻止在同一个周期内更新父组件视图。应用在显示秒数之前会被迫再等一轮。 使用 setTimeout() 来等下一轮，然后改写 seconds() 方法，这样它接下来就会从注入的这个计时器组件里获取秒数的值。 setTimeout(() => this.seconds = () => this.timerComponent.seconds, 0); } start() { this.timerComponent.start(); }//4==>直接调用子组件的方法 stop() { this.timerComponent.stop(); } } 父组件和子组件通过服务来通讯(rxjs) 引用message组件的代码 message.service.ts import { Injectable } from \"@angular/core\"; import { Subject } from \"rxjs\"; import { IType } from \"./IMessage\"; @Injectable({ providedIn: \"root\" }) export class MessageService { private messages = new Subject(); messages$ = this.messages.asObservable(); constructor() {} // 主要是负责对外提供接口方法，当外部调用时，传入了相应值，子组件只需要监听该流即可 success(content: string) { this.next(content, IType.success); } info(content: string) { this.next(content, IType.info); } error(content: string) { this.next(content, IType.error); } private next(content: string, type: IType) { this.messages.next( JSON.stringify({ content, type }) ); } } message-container.component.ts import { Component, OnDestroy, OnInit } from \"@angular/core\"; import { IMessage, IType } from \"../IMessage\"; import { MessageService } from \"../message.service\"; import { Subscription } from \"rxjs\"; @Component({ selector: \"message-container\", templateUrl: \"./message-container.component.html\", styleUrls: [\"./message-container.component.scss\"] }) export class MessageContainerComponent implements OnInit, OnDestroy { messages: IMessage[] = []; constructor(private messageService: MessageService) {} subscription: Subscription; ngOnInit() { //1==> 子组件进行监听流的数据，当有数据推送到流中，即往数组中推送增加一条信息，并展示到界面中，这样就实现了，通过service服务来通讯 this.subscription = this.messageService.messages$.subscribe(val => { this.create(content, type); }); } ngOnDestroy() { this.subscription.unsubscribe();//退订订阅非常重要，防止内存泄露 } create(content: string, type: IType) { } removeMessage(messageId: number) { } _generateMessageId() { } } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:42:19 "},"Angular样式.html":{"url":"Angular样式.html","title":"Angular 样式","keywords":"","body":"组件样式 Angular 应用使用标准的 CSS 来设置样式。这意味着你可以把关于 CSS 的那些知识和技能直接用于 Angular 程序中，例如：样式表、选择器、规则以及媒体查询等 另外，Angular 还能把组件样式捆绑在组件上，以实现比标准样式表更加模块化的设计。 使用组件样式 对你编写的每个Angular组件来说，除了定义HTML模板之外，还要定义用于模板的css样式、指定任意的选择器、规则和媒体查询 范围化样式 在@Component的元数据中指定的样式只会对该组件的模板生效 它们既不会被模板中嵌入的组件继承，也不会被通过内容投影(ng-content)嵌进来的组件集成，这种范围限制就是所谓的样式模块化特性 可以使用对每个组件最有意义的css类名和选择器 类名和选择器是仅属于组件内部的，它不会和应用中其它地方的类名和选择器出现冲突 组件的样式不会因为别的地方修改了样式而被意外改变 你可以让每个组件的css代码和它的TypeScript、HTML代码放在一起，这将促成清爽整洁的项目结构 将来你可以修改或移除组件的css代码，而不用遍历整个应用来看它有没有被别处用到，只要看看当前组件就可以了 特殊的选择器 :host选择器(YW:没有完全理解清楚如何使用) 使用 :host 伪类选择器，用来选择组件宿主元素中的元素 :host(.active){ border:1px solid #ddd; } 只有当宿主元素同时带有 active css类的时候才会生效 :host-context选择器 有时候，基于某些来自组件视图外部的条件应用样式是很有用的。例如，在文档的元素上可能有一个用于表示样式主题(theme)的css类，你应当基于它来决定组件的样式。 :host-context(.theme-light) h2 { background-color: #eef; } 它在当前组件宿主元素的祖先节点中查找CSS类，直到文档的根节点为止，在与其它选择器组合使用时，它非常有用 上面例子：只有当某个祖先元素有CSS类 theme-light时，才会把background样式应用到组件内部的所有元素中 把样式加载进组件中 设置 styles 或 styleUrls元数据 内联在模板的HTML中 通过css文件导入 元数据中的样式 @Component({ selector: 'app-root', template: ` Tour of Heroes `, styles: ['h1 { font-weight: normal; }'] // 直接写入样式 styleUrls: ['./hero-app.component.css'] // 元数据中引入样式文件 }) export class HeroAppComponent { /* . . . */ } 可以指定多个样式文件，也可以组合使用 style和styleUrls 模板内联样式 @Component({ selector: 'app-hero-controls', template: ` button { background-color: white; border: 1px solid #777; } Controls Activate ` }) 直接模板中使用 或者直接使用 link标签 css中 @import 语法 @import './hero-details-box.css'; css中通过@import导入其它css文件，相对路径 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:45:59 "},"Angular指令.html":{"url":"Angular指令.html","title":"Angular 指令","keywords":"","body":"属性型指令 属性型指令用于改变一个DOM元素的外观或行为。 在Angular中有三种类型的指令： 组件 - 拥有模板的指令 结构型指令 - 通过添加和移除DOM元素改变DOM布局的指令 属性型指令 - 改变元素、组件或其他指令的外观和行为的指令 拖拽指令(属性型指令) import { Directive, HostListener, ElementRef, Renderer2, Input, EventEmitter, Output } from \"@angular/core\"; @Directive({ selector: \"[app-draggable][draggedClass][dragData]\" // 外部传递进来的数据 }) export class DragDirective { private _isDraggable = false; @Input(\"app-draggable\") set isDraggable(val: boolean) { this._isDraggable = val; this.rd.setAttribute(this.el.nativeElement, \"draggable\", `${val}`); // 设置元素是否支持拖拽 } get isDraggable() { return this._isDraggable; } @Input() draggedClass: string; // 传递进入的数据 @Input() dragData: string; // 传递进入的数据 @Input() dragEnterClass: string; // 传递进入的数据 @Output() startData = new EventEmitter(); // 输出的事件 @Output() dropData = new EventEmitter(); // 输出的事件 constructor(private el: ElementRef, private rd: Renderer2) {} @HostListener(\"dragstart\", [\"$event\"]) // @HostListener 装饰器引用属性型指令的宿主元素 onDragStart(ev: Event) { // 通过this.el来访问DOM元素 if (this.el.nativeElement === ev.target) { // 通过this.rd来对DOM进行安全操作 this.rd.addClass(this.el.nativeElement, this.draggedClass); this.startData.emit(this.dragData); } } @HostListener(\"dragend\", [\"$event\"]) onDragEnd(ev: Event) { if (this.el.nativeElement === ev.target) { this.rd.removeClass(this.el.nativeElement, this.draggedClass); } } @HostListener(\"dragenter\", [\"$event\"]) onDragEnter(ev: Event) { ev.preventDefault(); ev.stopPropagation(); if (this.el.nativeElement.className.indexOf(\"drag-start\") > -1) { return false; } this.rd.addClass(this.el.nativeElement, this.dragEnterClass); } @HostListener(\"dragover\", [\"$event\"]) onDragOver(ev: Event) { ev.preventDefault(); ev.stopPropagation(); } @HostListener(\"dragleave\", [\"$event\"]) onDragLeave(ev: Event) { ev.preventDefault(); ev.stopPropagation(); this.rd.removeClass(this.el.nativeElement, this.dragEnterClass); } @HostListener(\"drop\", [\"$event\"]) onDrop(ev: Event) { ev.preventDefault(); ev.stopPropagation(); this.rd.removeClass(this.el.nativeElement, this.dragEnterClass); this.dropData.emit(this.dragData); } } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:46:22 "},"Angular管道.html":{"url":"Angular管道.html","title":"Angular 管道","keywords":"","body":"管道 通过引入Angular管道，你可以把这种简单的“显示-值”转换器声明在HTML中，管道把数据作为输入，然后转换它，给出期望的输出。 使用管道 the hero birthday is {{birthday | date}} 内置管道 所有管道 DatePipe 日期转换 UpperCasePipe 单词大写 LowerCasePipe 单词小写 CurrencyPipe 货币 PercentPipe 百分数 AsyncPipe 接收一个promise或Observable作为输入，并且自动订阅这个输入，最终返回它们给出的值 管道参数化 The hero's birthday is {{ birthday | date:\"MM/dd/yy\" }} HH大写时是24小时制 链式管道 The chained hero's birthday is {{ birthday | date:'fullDate' | uppercase}} 自定义管道 import { Pipe, PipeTransform } from '@angular/core'; /* * Raise the value exponentially * Takes an exponent argument that defaults to 1. * Usage: * value | exponentialStrength:exponent * Example: * {{ 2 | exponentialStrength:10 }} * formats to: 1024 */ @Pipe({name: 'exponentialStrength'}) export class ExponentialStrengthPipe implements PipeTransform { transform(value: number, exponent: string): number { let exp = parseFloat(exponent); return Math.pow(value, isNaN(exp) ? 1 : exp); } } 自定义管道请注意以下几点： 你使用自定义管道的方式和内置管道完全相同。 你必须在 AppModule 的 declarations 数组中包含这个管道。 管道与变更检测 Angular 通过变更检测过程来查找绑定值的更改，并在每一次 JavaScript 事件之后运行：每次按键、鼠标移动、定时器以及服务器的响应。 这可能会让变更检测显得很昂贵，但是 Angular 会尽可能降低变更检测的成本。 当使用管道时，Angular 会选用一种更简单、更快速的变更检测算法。 引用是Angular所关心的一切。从Angular的角度来看，这是同一个数组，没有变换，也就不需要更新显示 纯pure管道与非纯(impure)管道 有两类管道：纯的与非纯的。 默认情况下，管道都是纯的。以前见到的每个管道都是纯的。 通过把它的 pure 标志设置为 false，你可以制作一个非纯管道 【纯管道】Angular只有在它检测到输入值发生了纯变更时才会执行纯管道。纯变更是指对原始类型值(String,Number,Boolean,Symbol)的更改，或者对对象引用的更改 Angular 会忽略(复合)对象内部的更改。 如果你更改了输入日期(Date)中的月份、往一个输入数组(Array)中添加新值或者更新了一个输入对象(Object)的属性，Angular 都不会调用纯管道 【非纯管道】Angular会在每个组件的变更检测周期中执行非纯管道。非纯管道可能会被调用很多次，和每个按键或每次鼠标移动一样频繁。必须小心翼翼的实现非纯管道。 一个昂贵、迟钝的管道将摧毁用户体验 纯管道-->非纯管道 纯管道 import { Pipe, PipeTransform } from '@angular/core'; import { Flyer } from './heroes'; @Pipe({ name: 'flyingHeroes' }) export class FlyingHeroesPipe implements PipeTransform { transform(allHeroes: Flyer[]) { return allHeroes.filter(hero => hero.canFly); } } 非纯管道 @Pipe({ name: 'flyingHeroesImpure', pure: false // 通过这个值得改变，改变了angular变更检测的方式 }) export class FlyingHeroesImpurePipe extends FlyingHeroesPipe {} 非纯AsyncPipe Angular 的 AsyncPipe 是一个有趣的非纯管道的例子。 AsyncPipe 接受一个 Promise 或 Observable 作为输入，并且自动订阅这个输入，最终返回它们给出的值 import { Component } from '@angular/core'; import { Observable, interval } from 'rxjs'; import { map, take } from 'rxjs/operators'; @Component({ selector: 'app-hero-message', template: ` Async Hero Message and AsyncPipe Message: {{ message$ | async }} Resend`, }) export class HeroAsyncMessageComponent { message$: Observable; private messages = [ 'You are my hero!', 'You are the best hero!', 'Will you be my hero?' ]; constructor() { this.resend(); } resend() { this.message$ = interval(500).pipe( map(i => this.messages[i]), take(this.messages.length) ); } } 这个 Async 管道节省了组件的样板代码。 组件不用订阅这个异步数据源，而且不用在被销毁时取消订阅(如果订阅了而忘了反订阅容易导致隐晦的内存泄露)。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:47:42 "},"Angular事件处理.html":{"url":"Angular事件处理.html","title":"Angular 事件处理","keywords":"","body":"点击事件 Click me!通过$event对象取得用户输入 template: ` {{values}} ` 从一个模板引用变量中获得用户输入 @Component({ selector: 'app-loop-back', template: ` {{box.value}} ` }) export class LoopbackComponent { } 按键事件过滤 keyup.enter --> 只有当用户敲回车键时，才会调用事件处理器 @Component({ selector: 'app-key-up3', template: ` {{value}} ` }) export class KeyUpComponent_v3 { value = ''; onEnter(value: string) { this.value = value; } } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:48:24 "},"NgModule.html":{"url":"NgModule.html","title":"NgModule","keywords":"","body":"NgModule 用于描述应用的各个部分如何组织在一起。每个应用有至少一个Angular模块、根模块就是你用来启动此应用的模块。按照惯例，它通常命名为AppModule AppModule /* JavaScript imports */ import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { AppComponent } from './app.component'; /* the AppModule class with the @NgModule decorator */ @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, FormsModule, HttpClientModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } declarations -- 该应用所拥有的组件。 imports -- 导入BrowserModule以获取浏览器特有的服务，比如DOM渲染、无害化处理和位置(location) providers -- 各种服务提供商 bootstrap -- 根组件，Angular创建它并插入index.html宿主页面 【declarations】该模块的 declarations 数组告诉 Angular 哪些组件属于该模块。 当你创建更多组件时，也要把它们添加到 declarations 中。 每个组件都应该（且只能）声明（declare）在一个 NgModule 类中。 如果你使用了未声明过的组件，Angular 就会报错。 能包含的类型： 组件 component 指令 directive 管道 pipe 【imports】模块的imports数组只会出现在@NgModule元数据中。它告诉Angular该模块想要正常工作，还需要哪些模块 【providers】providers 数组中列出了该应用所需的服务。当直接把服务列在这里时，它们是全应用范围的。当你使用特性模块和惰性加载时，它们是范围化的。 【bootstrap】放入根组件中 常用模块 NgModule 导入自 为何使用 BrowserModule @angular/platform-browser 当你要在浏览器中运行应用时 CommonModule @angular/common 当你想要使用 NgIf 和 NgFor 时 FormsModule @angular/forms 当要构建模板驱动表单时（它包含 NgModel 特性模块的分类 下面是特性模块的五个常用分类 领域特性模块 带路由的特性模块 路由模块 服务特性模块 可视部件特性模块 路由到的入口组件 所有路由组件都必须是入口组件。这需要你把同一个组件添加到两个地方（路由中和 entryComponents 中），但编译器足够聪明，可以识别出这里是一个路由定义，因此它会自动把这些路由组件添加到 entryComponents 中。 entryComponents 数组 虽然 @NgModule 装饰器具有一个 entryComponents 数组，但大多数情况下你不用显式设置入口组件，因为 Angular 会自动把 @NgModule.bootstrap 中的组件以及路由定义中的组件添加到入口组件中。 虽然这两种机制足够自动添加大多数入口组件，但如果你要用其它方式根据类型来命令式的引导或动态加载某个组件，你就必须把它们显式添加到 entryComponents 中了。 entryComponents 和编译器 对于生产环境的应用，你总是希望加载尽可能小的代码。 这些代码应该只包含你实际使用到的类，并且排除那些从未用到的组件。因此，Angular 编译器只会为那些可以从 entryComponents 中直接或间接访问到的组件生成代码。 这意味着，仅仅往 @NgModule.declarations 中添加更多引用，并不能表达出它们在最终的代码包中是必要的。 服务提供商 import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root', // 指定该服务应该在根注入器中提供 }) export class UserService { } 【提供商的作用域】 当你把服务提供商添加到应用的根注入器中时，它就在整个应用程序中可用了。 另外，这些服务提供商也同样对整个应用中的类是可用的 —— 只要它们有供查找用的服务令牌。 【provideIn 与 NgModule】 也可以规定某个服务只有在特定的 @NgModule 中提供。比如，如果你你希望只有当消费方导入了你创建的 UserModule 时才让 UserService 在应用中生效，那就可以指定该服务要在该模块中提供 import { Injectable } from '@angular/core'; import { UserModule } from './user.module'; @Injectable({ providedIn: UserModule, }) export class UserService { } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:49:49 "},"模板驱动表单.html":{"url":"模板驱动表单.html","title":"[表单]模板驱动表单","keywords":"","body":"表单 表单是商业应用的支柱，用来数据录入任务 如何编写表单 第一步：导入FormsModule import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { FormsModule } from '@angular/forms'; import { AppComponent } from './app.component'; import { HeroFormComponent } from './hero-form/hero-form.component'; @NgModule({ imports: [ BrowserModule, FormsModule 第二步：创建初始HTML表单模板 Hero Form Name Alter Ego Submit NgForm指令 什么是NgForm指令？但你明明没有添加过NgForm指令啊! Angular 替你做了。Angular会在 标签上自动创建并附加一个NgForm指令。 NgForm指令为form增补了一些额外特性。它会控制那些带有ngModel指令和name属性的元素，监听它们的属性。它还有自己的valid属性，这个属性只有在它包含的每个空间都有效时才是真 在表单中使用[(ngModel)]时，必须要定义name属性 双向数据绑定 变更检测 通过ngModel跟踪修改状态与有效性验证 NgModel指令不仅仅跟踪状态，它还使用特定的Angular CSS类来更新控件，以反映当前状态，可以利用这些css类修改控件的外观，显示或隐藏消息 状态 为真时css 为假时css类 控件被访问过 ng-touched ng-untouched 控件的值变化了 ng-dirty ng-pristine 空间值有效 ng-valid ng-invalid Name Name is required reset方法 调用表单的reset方法可以清楚所有标记(例如：ng-touched ng-dirty之类的标记) New Hero submit 提交表单 Submit Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:51:02 "},"响应式表单.html":{"url":"响应式表单.html","title":"[表单]响应式表单","keywords":"","body":"快速起步 【注册ReactiveFormsModule】 import { ReactiveFormsModule } from '@angular/forms'; @NgModule({ imports: [ ReactiveFormsModule ], }) export class AppModule { } 表单控件分组 【创建FormGroup】 import { Component } from '@angular/core'; import { FormGroup, FormControl } from '@angular/forms'; @Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'] }) export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), }); } 【关联FormGroup的模型和视图】 这个FormGroup还能跟踪其中每个控件的状态及其变化，所以如果其中的某个控件的状态或值变化了，父控件也会发出一次新的状态变更或值变更事件。 First Name: Last Name: 嵌套的表单组 import { Component } from '@angular/core'; import { FormGroup, FormControl } from '@angular/forms'; @Component({ selector: 'app-profile-editor', templateUrl: './profile-editor.component.html', styleUrls: ['./profile-editor.component.css'] }) export class ProfileEditorComponent { profileForm = new FormGroup({ firstName: new FormControl(''), lastName: new FormControl(''), address: new FormGroup({ street: new FormControl(''), city: new FormControl(''), state: new FormControl(''), zip: new FormControl('') }) }); } 在模板中分组内嵌的表单 Address Street: City: State: Zip Code: 模型更新 【setValue】 注意：在这个例子中，你只使用单个控件，但是当调用 FormGroup 或 FormArray 的 setValue() 方法时，传入的值就必须匹配控件组或控件数组的结构才行。 【patchValue】 updateProfile() { this.profileForm.patchValue({ firstName: 'Nancy', address: { street: '123 Drew Street' } }); } 使用FormBuilder来生成表单控件 当需要与多个表单打交道时，手动创建多个表单控件实例会非常繁琐。FormBuilder服务提供了一些便捷方法来生成表单控件。 【步骤1 - 导入FormBuilder类】 【步骤 2 - 注入 FormBuilder 服务】 【步骤 3 - 生成表单控件】 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:51:32 "},"自定义表单验证器.html":{"url":"自定义表单验证器.html","title":"[表单]自定义表单验证器","keywords":"","body":"模板驱动验证 Name is required. Name must be at least 4 characters long. Name cannot be Bob. 响应式表单验证 【验证器函数】 同步验证器函数接收一个控件实例，然后返回一组验证错误或null。你可以在实例化一个 FormControl时把它作为构造函数的第二个参数传进去 异步验证器函数接收一个控件实例，并返回一个承诺promise 或可观察对象Observable , 它们稍后会发出一组验证错误或null。你可以在实例化一个FormControl时把它作为构造函数的第三个参数传进去 【内置验证器】 this.heroForm = new FormGroup({ 'name': new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i) // 自定义验证器 由于内置验证器无法适用于所有应用场景，有时候需要建立自定义验证器 export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn { return (control: AbstractControl): {[key: string]: any} | null => { const forbidden = nameRe.test(control.value); return forbidden ? {'forbiddenName': {value: control.value}} : null; }; } 【添加响应式表单】 this.heroForm = new FormGroup({ 'name': new FormControl(this.hero.name, [ Validators.required, Validators.minLength(4), forbiddenNameValidator(/bob/i) // 【添加到模板驱动表单】建立一个指令来包装这个自定义验证器 @Directive({ selector: '[appForbiddenName]', providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}] }) export class ForbiddenValidatorDirective implements Validator { @Input('appForbiddenName') forbiddenName: string; validate(control: AbstractControl): {[key: string]: any} | null { return this.forbiddenName ? forbiddenNameValidator(new RegExp(this.forbiddenName, 'i'))(control) : null; } } 表示控件状态的css类 通过以下类空值表单的css样式 ng-valid 验证通过 ng-invalid 验证不通过 ng-pending 在等待...期间 ng-pristine 原始状态 ng-dirty 被动过的 ng-untouched 没有被触碰的 ng-touched 被触碰之后的 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:52:42 "},"自定义表单控件.html":{"url":"自定义表单控件.html","title":"[表单]自定义表单控件","keywords":"","body":"步骤： 编写正常子组件一样，先编写好 实现相应的接口 调用相应表单控件 import {ChangeDetectionStrategy, Component, EventEmitter, forwardRef, Input, Output} from '@angular/core'; //引入相应的表单文件 import {ControlValueAccessor, FormControl, NG_VALIDATORS, NG_VALUE_ACCESSOR} from '@angular/forms'; @Component({ selector: 'app-image-list-select', templateUrl: './image-list-select.component.html', styleUrls: ['./image-list-select.component.scss'], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => ImageListSelectComponent),//向前引用 multi: true, //多对一 }, { provide: NG_VALIDATORS, //验证器注册 useExisting: forwardRef(() => ImageListSelectComponent), multi: true, } ], changeDetection: ChangeDetectionStrategy.OnPush, }) export class ImageListSelectComponent implements ControlValueAccessor { selected: string; @Input() title = '选择封面：'; @Input() items: string[] = []; @Input() cols = 8; @Input() rowHeight = '64px'; @Input() itemWidth = '80px'; @Input() useSvgIcon = false; @Output('itemChange') itemChange = new EventEmitter(); // 这里是做一个空函数体，真正使用的方法在 registerOnChange 中 // 由框架注册，然后我们使用它把变化发回表单 // 注意，和 EventEmitter 尽管很像，但发送回的对象不同 private propagateChange = (_: any) => {}; // 写入控件值，调用者通过setValue写入的位置 public writeValue(obj: any) { if (obj && obj !== '') { this.selected = obj; } } // 当表单控件值改变时，函数 fn 会被调用 // 这也是我们把变化 emit 回表单的机制 public registerOnChange(fn: any) { this.propagateChange = fn; } // 验证表单，验证结果正确返回 null 否则返回一个验证结果对象 public validate(c: FormControl) { return this.selected ? null : { imageListSelect: { valid: false, }, }; } // 这里没有使用，用于注册 touched 状态 public registerOnTouched() { } // 列表元素选择发生改变触发 onChange(i) { this.selected = this.items[i]; // 更新表单，这样表单通过get可以获取到最新值 this.propagateChange(this.items[i]); this.itemChange.emit(this.items[i]); } } 调用控件代码展示 IpList表单控件模板 import { Component, Input, OnInit, forwardRef } from \"@angular/core\"; import { compact, concat, uniq, difference } from \"lodash\"; import { ControlValueAccessor, NG_VALIDATORS, NG_VALUE_ACCESSOR } from \"@angular/forms\"; @Component({ selector: \"agent-install-iplist\", templateUrl: \"./agent-install-iplist.component.html\", styleUrls: [\"./agent-install-iplist.component.scss\"], providers: [ { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => AgentInstallIplistComponent), // 向前引用 multi: true // 多对一 }, { provide: NG_VALIDATORS, // 验证器注册 useExisting: forwardRef(() => AgentInstallIplistComponent), multi: true } ] }) export class AgentInstallIplistComponent implements OnInit, ControlValueAccessor { @Input() allAgentIPArray; // agent 安装 ip 列表 @Input() inputIpList; allIpList: string[] = []; // 全部Ip列表 trueIpList: string[] = []; // 正确Ip列表 falseIpList: string[] = []; // 错误IP列表 hasFalseIp = false; // 控制是否有错误IP，如果有的话，隐藏安装按钮 IpReg = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/; constructor() {} ngOnInit() { this.ipCheck(this.allAgentIPArray); } // 这里是做一个空函数体，真正使用的方法在 registerOnChange 中 // 由框架注册，然后我们使用它把变化发回表单 // 注意，和 EventEmitter 尽管很像，但发送回的对象不同 private propagateChange = (_: any) => {}; // 写入控件值，调用者通过setValue写入的位置 public writeValue(obj: string | null) { if (obj !== null && obj !== \"\") { this.classIpMain(obj); } } // 当表单控件值改变时，函数 fn 会被调用 // 这也是我们把变化 emit 回表单的机制 public registerOnChange(fn: any) { this.propagateChange = fn; } // 验证表单，验证结果正确返回 null, 否则返回一个验证结果对象 public validate() { return !this.hasFalseIp && this.trueIpList.length > 0 ? null : { hasFalseIp: { valid: false } }; } // 这里没有使用，用于注册 touched 状态 public registerOnTouched() {} // IP分类函数，入口为字符串，输出是正确，错误，全部IP classIpMain(ipString: string) { const list = this.ipCut(ipString); const removeEmpty = compact(list); this.ipCheck(removeEmpty); } // IP分割 ipCut(ipString: string) { return ipString.split(/[\\s\\n,]/); } // IP分类 ipCheck(listArr: string[]) { listArr.forEach(current => { if (this.IpReg.test(current)) { this.addTrueList(current); } else { this.addFalseList(current); } }); this.upDataAllIpList(); } // 更新总IP列表 + 更新一些状态值 upDataAllIpList() { this.allIpList = concat(this.trueIpList, this.falseIpList); this.hasFalseIp = this.falseIpList.length > 0; this.propagateChange(this.trueIpList); } // 清空IP列表 clearAllIpList() { this.trueIpList = []; this.falseIpList = []; this.upDataAllIpList(); } // 添加进正确列表 addTrueList(ip: string) { this.trueIpList.unshift(ip); this.trueIpList = uniq(this.trueIpList); } // 添加进错误列表 addFalseList(ip: string) { this.falseIpList.unshift(ip); this.falseIpList = uniq(this.falseIpList); } // 删除错误Ip deleteFalseIp(fIp: string) { this.falseIpList = difference(this.falseIpList, [fIp]); this.upDataAllIpList(); } // 删除正确Ip deleteTrueIp(tIp: string) { this.trueIpList = difference(this.trueIpList, [tIp]); this.upDataAllIpList(); } // 编辑错误Ip列表 editIp(oldVal: string, newVal: string) { if (newVal === oldVal || newVal === \"\") { return false; } if (this.IpReg.test(newVal)) { this.addTrueList(newVal); } else { this.addFalseList(newVal); } this.deleteFalseIp(oldVal); this.deleteTrueIp(oldVal); } } Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 07:53:15 "},"InputorInjectable.html":{"url":"InputorInjectable.html","title":"[重难]@Input() or @Inject()","keywords":"","body":"前言 在组件化开发的项目中，对于我们来说组件之间的传值是一个核心话题，父->子传值、子->父传值、兄弟组件传值。今天这篇文章不打算全部覆盖传值方式，主要来学习下input的传值方式和Injectable的传值方式 @Input() 一个装饰器，用来把某个类字段标记为输入属性，并且提供配置元数据。 声明一个可供数据绑定的输入属性，在变更检测期间，Angular 会自动更新它。 @Input()的工作方式：父组件 @Component({ selector: 'app', template: ` ` }) class App {} 子组件 @Component({ selector: 'bank-account', template: ` Bank Name: {{bankName}} Account Id: {{id}} ` }) class BankAccount { @Input() bankName: string; @Input('account-id') id: string; normalizedBankName: string; } 对就是这么简单，主要就是用于父子之间数据传递。没有其它更加复杂的东西 Injectable 标记性元数据，表示一个类可以由 Injector 进行创建。 看一个service import { Injectable } from '@angular/core'; import { heroList } from \"../mock\"; @Injectable({ providedIn: 'root' }) export class HeroService { constructor() { } getHeroList(){ return heroList; } } 表示该服务是一个可以注入到组件中的服务[原创]Angular依赖注入(DI)与服务service详解 那么在组件中我们可以这样使用服务： import { Component, OnInit } from '@angular/core'; import { HeroService } from \"../../shared/service/hero.service\"; @Component({ selector: 'hero-list', templateUrl: './hero-list.component.html', styleUrls: ['./hero-list.component.css'], providers: [HeroService] }) export class HeroListComponent implements OnInit { heroList; constructor( public heroService: HeroService //constructor中注入该服务即可 ) { } ngOnInit() { this.heroList = this.heroService.getHeroList(); } } 注入服务的概念也是比较简单的，其本意是分离组件对数据的操作，尽量让数据在service处理和保存，由于service是单例模式的，这样可以多个组件同时注入同一个service共用一类数据。达到组件间数据传递的效果。[注意]使用service注入数据的方式配合rxjs使用可以事半功倍。后续也会专门写一系列文章来讲解rxjs 该使用哪个呢 在 Angular 应用中，通过 Service 来管理状态，把需要共享的数据通过 Observable 包装起来，提供相应的订阅接口即可。这样的状态流非常的简单清晰，易于维护。对于组件通信，在 Angular 中有多种方式，我建议的方式是： 对于父 => 子，使用 @Input()对于子 => 父，使用 @Output() EventEmitter。(其实 EventEmitter 就是一个 Observable 对象)对于其他情况，在没有特殊需求的条件下，尽可能的使用 Service + Rxjs 的方式通信，让组件解耦。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 09:46:01 "},"Angular依赖注入与服务service详解.html":{"url":"Angular依赖注入与服务service详解.html","title":"[原创]Angular 依赖注入(DI)与服务 service 详解","keywords":"","body":"前言 本文将重点介绍Angular中两个重要的概念 service 以及 DI 本文代码github地址 服务 组件应该把诸如从服务器获取数据、验证用户输入或直接往控制台中写日志等工作委托给各种服务。通过把各种处理任务定义到可注入的服务类中，你可以让它被任何组件使用。 通过在不同的环境中注入同一种服务的不同提供商，你还可以让你的应用更具适应性。 Angular 会通过依赖注入来帮你更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。 创建服务 DI 框架让你能从一个可注入的服务类（独立文件）中为组件提供数据。 快速创建一个服务ng g s shared/service/hero /service-test/src/app/shared/service/hero.service.ts import { Injectable } from '@angular/core'; import { heroList } from \"../mock\"; @Injectable({ providedIn: 'root' }) export class HeroService { constructor() { } getHeroList(){ return heroList; } } @Injectable() 对所有服务都是必须的。该服务对外提供了一个getHeroList方法 注入服务 你可以通过制定带有依赖类型的构造函数参数来要求 Angular 在组件的构造函数中注入依赖项。 constructor(heroService: HeroService) 创建一个组件ng g c pages/hero-list import { Component, OnInit } from '@angular/core'; import { HeroService } from \"../../shared/service/hero.service\"; @Component({ selector: 'hero-list', templateUrl: './hero-list.component.html', styleUrls: ['./hero-list.component.css'] }) export class HeroListComponent implements OnInit { heroList; constructor( public heroService: HeroService ) { } ngOnInit() { this.heroList = this.heroService.getHeroList(); } } html代码： 英雄展示 姓名：{{ hero.name }} 年龄：{{ hero.age }} 至此我们就可以使用该服务对外提供的方法例如：getHeroList()来获取英雄列表 那么多个组件我们都可以通过同样的方式注入进去即可共用了，这也是angular数据传递比较重要的方式 Angular 中的依赖注入 依赖注入（DI）是一种重要的应用设计模式。Angular 有自己的 DI 框架，在设计应用时常会用到它，以提升它们的开发效率和模块化程度。 DI 是一种编码模式，其中的类会从外部源中请求获取依赖，而不是自己创建它们。 在 Angular 中，DI 框架会在实例化该类时向其提供这个类所声明的依赖项。 多级依赖注入器 Angular 的依赖注入系统是多级的。 实际上，应用程序中有一个与组件树平行的注入器树（译注：平行是指结构完全相同且一一对应）。 你可以在组件树中的任何级别上重新配置注入器。 配置服务注入器 我们创建的类提供了一个服务。@Injectable() 装饰器把它标记为可供注入的服务，不过在你使用该服务的 provider 提供商配置好 Angular 的依赖注入器之前，Angular 实际上无法将其注入到任何位置。 你可以在三种位置之一设置元数据，以便在应用的不同层级使用提供商来配置注入器： 在服务本身的 @Injectable() 装饰器中。 在 NgModule 的 @NgModule() 装饰器中。 在组件的 @Component() 装饰器中。 @Injectable() 进行配置 当你在服务自身的 @Injectable() 装饰器中指定提供商时（通常在应用的根一级root），CLI 生产模式构建时所用的优化工具可以执行摇树优化，它会移除没有用过的那些服务。摇树优化生成的包会更小。 当使用 providedIn:'root' 时，你是在配置应用的根注入器，也就是 AppModule 的注入器。 整个注入器树的真正的根是平台注入器，它是根注入器的父节点。 这可以让多个应用共享同一套平台配置。 @Injectable({ providedIn: 'root' // 指定为根目录，还可以指定为具体模块 }) @NgModule() 进行配置 NgModule 级的提供商可以在 @NgModule() providers 元数据中指定，也可以在 @Injectable() 的 providedIn 选项中指定某个模块类（但根模块 AppModule 除外）。 你还可以在非根 NgModule 元数据的 providedIn 选项中配置一个模块级的提供商，以便把该服务的范围限定到该模块一级。 这和在 @Injectable() 元数据中指定一个非根模块是基本等效的，但以这种方式提供的服务无法被摇树优化掉。 @NgModule({ imports: [CommonModule], declarations: [], providers: [HeroService], exports: [] }) 如果某个模块是惰性加载的，那么请使用 @NgModule() 的 provides 选项。加载那个模块时，就会用这里的提供商来配置模块本身的注入器，而 Angular 会为该模块中创建的任何类注入相应的服务。如果你使用了 @Injectable() 中的 providedIn: MyLazyloadModule 选项，那么如果该提供商没有在别处用过，就可以在编译期间把它摇树优化掉。 @Component() 进行配置 NgModule 中每个组件都有它自己的注入器。 通过使用 @Component 元数据在组件级配置某个提供商，你可以把这个提供商的范围限定到该组件及其子组件 @Component({ selector: 'hero-list', templateUrl: './hero-list.component.html', styleUrls: ['./hero-list.component.css'], providers: [HeroService] }) 注入器树与服务实例 在某个注入器的范围内，服务是单例的。也就是说，在指定的注入器中最多只有某个服务的最多一个实例。除非你在子注入器中配置了另一个提供商。 [注意]这句话这也理解当我们注入范围选择了root那么在root的范围内该服务最多就一个实例，但是如果我们在@Component中又配置了一个提供商，那么就对该服务另起一个实例。 注入器冒泡 当一个组件申请获得一个依赖时，Angular 先尝试用该组件自己的注入器来满足它。 如果该组件的注入器没有找到对应的提供商，它就把这个申请转给它父组件的注入器来处理。 如果那个注入器也无法满足这个申请，它就继续转给它在注入器树中的父注入器。 这个申请继续往上冒泡 —— 直到 Angular 找到一个能处理此申请的注入器或者超出了组件树中的祖先位置为止。 如果超出了组件树中的祖先还未找到，Angular 就会抛出一个错误。 如果你在不同的层级上为同一个 DI 令牌注册了提供商，那么 Angular 所碰到的第一个注入器就会用来提供该依赖。 比如，如果提供商注册在该组件的本地注入器上，那么当该组件需要这个服务时，Angular 就不会去找能提供同一服务的其它提供商。 [注意]使用@Host()可以限制冒泡。当搜索提供商时，就会在组件宿主元素的注入器处停下。 依赖提供商 依赖提供商会使用 DI 令牌来配置注入器，注入器会用它来提供这个依赖值的具体的、运行时版本。 注入器依靠 \"提供商配置\" 来创建依赖的实例，并把该实例注入到组件、指令、管道和其它服务中。 providers: [Logger] 不过，你也可以用一个替代提供商来配置注入器，这样就可以指定另一些同样能提供日志功能的对象。 你可以提供一个替代类。 你可以提供一个类似于 Logger 的对象。 你的提供商可以调用一个工厂函数来创建 logger。 Provider 对象字面量 类提供商的语法实际上是一种简写形式，它会扩展成一个由 Provider 接口定义的提供商配置对象。 [{ provide: Logger, useClass: Logger }] 实际上面两种配置方式是相等的 [Logger] == [{ provide: Logger, useClass: Logger }] 替代类提供商 不同的类都可用于提供相同的服务。 比如，下面的代码告诉注入器，当组件使用 Logger 令牌请求日志对象时，给它返回一个 BetterLogger 实例 [{ provide: Logger, useClass: BetterLogger }] EvenBetterLogger类 @Injectable() export class EvenBetterLogger extends Logger { constructor(private userService: UserService) { super(); } log(message: string) { let name = this.userService.user.name; super.log(`Message to ${name}: ${message}`); } } 别名类提供商 假设老的组件依赖于 OldLogger 类。OldLogger 和 NewLogger 的接口相同，但是由于某种原因，我们没法修改老的组件来使用 NewLogger。 当老的组件要使用 OldLogger 记录信息时，你可能希望改用 NewLogger 的单例来处理它。 在这种情况下，无论某个组件请求老的 logger 还是新的 logger，依赖注入器都应该注入这个 NewLogger 的单例。 也就是说 OldLogger 应该是 NewLogger 的别名。 如果你试图用 useClass 为 OldLogger 指定一个别名 NewLogger，就会在应用中得到 NewLogger 的两个不同的实例。 [ NewLogger, // Not aliased! Creates two instances of `NewLogger` { provide: OldLogger, useClass: NewLogger}] 要确保只有一个 NewLogger 实例，就要用 useExisting 来为 OldLogger 指定别名。 [ NewLogger, // Alias OldLogger w/ reference to NewLogger { provide: OldLogger, useExisting: NewLogger}] 值提供商 有时候，提供一个现成的对象会比要求注入器从类去创建更简单一些。 如果要注入一个你已经创建过的对象，请使用 useValue 选项来配置该注入器。 下面的代码定义了一个变量，用来创建这样一个能扮演 logger 角色的对象 // An object in the shape of the logger service export function SilentLoggerFn() {} const silentLogger = { logs: ['Silent logger says \"Shhhhh!\". Provided via \"useValue\"'], log: SilentLoggerFn }; 下面的提供商定义对象使用 useValue 作为 key 来把该变量与 Logger 令牌关联起来。 [{ provide: Logger, useValue: silentLogger }] 工厂提供商 hero.service.ts constructor( private logger: Logger, private isAuthorized: boolean) { } getHeroes() { let auth = this.isAuthorized ? 'authorized ' : 'unauthorized'; this.logger.log(`Getting heroes for ${auth} user.`); return HEROES.filter(hero => this.isAuthorized || !hero.isSecret); } app-heroes @Component({ selector: 'app-heroes', providers: [ { provide: HeroService, useFactory: (logger: Logger, userService: UserService) => { return new HeroService(logger, userService.user.isAuthorized); };, deps: [Logger, UserService] } ] }) 预定义令牌与多提供商 Angular 提供了一些内置的注入令牌常量，你可以用它们来自定义系统的多种行为。 比如，你可以使用下列内置令牌来切入 Angular 框架的启动和初始化过程。 提供商对象可以把任何一个注入令牌与一个或多个用来执行应用初始化操作的回调函数关联起来。 PLATFORM_INITIALIZER：平台初始化之后调用的回调函数。 APP_BOOTSTRAP_LISTENER：每个启动组件启动完成之后调用的回调函数。这个处理器函数会收到这个启动组件的 ComponentRef 实例。 APP_INITIALIZER：应用初始化之前调用的回调函数。注册的所有初始化器都可以（可选地）返回一个 Promise。所有返回 Promise 的初始化函数都必须在应用启动之前解析完。如果任何一个初始化器失败了，该应用就不会继续启动。 比如，当启动应用时，你可以使用同一个令牌注册多个初始化器。 export const APP_TOKENS = [ { provide: PLATFORM_INITIALIZER, useFactory: platformInitialized, multi: true }, { provide: APP_INITIALIZER, useFactory: delayBootstrapping, multi: true }, { provide: APP_BOOTSTRAP_LISTENER, useFactory: appBootstrapped, multi: true }, ]; 在其它地方，多个提供商也同样可以和单个令牌关联起来。 比如，你可以使用内置的 NG_VALIDATORS 令牌注册自定义表单验证器，还可以在提供商定义对象中使用 multi: true 属性来为指定的验证器令牌提供多个验证器实例。 Angular 会把你的自定义验证器添加到现有验证器的集合中。 可摇树优化的提供商 摇树优化是指一个编译器选项，意思是把应用中未引用过的代码从最终生成的包中移除。 如果提供商是可摇树优化的，Angular 编译器就会从最终的输出内容中移除应用代码中从未用过的服务。 这会显著减小你的打包体积。 理想情况下，如果应用没有注入服务，它就不应该包含在最终输出中。 不过，Angular 要能在构建期间识别出该服务是否需要。 由于还可能用 injector.get(Service) 的形式直接注入服务，所以 Angular 无法准确识别出代码中可能发生此注入的全部位置，因此为保险起见，只能把服务包含在注入器中。 因此，在 NgModule 或 组件级别提供的服务是无法被摇树优化掉的。 创建可摇树优化的提供商 只要在服务本身的 @Injectable() 装饰器中指定，而不是在依赖该服务的 NgModule 或组件的元数据中指定，你就可以制作一个可摇树优化的提供商。 @Injectable({ providedIn: 'root', }) export class Service { } 该服务还可以通过配置工厂函数来实例化 @Injectable({ providedIn: 'root', useFactory: () => new Service('dependency'), }) export class Service { constructor(private dep: string) { } } 参考文献 官网api Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-29 17:32:34 "},"依赖注入实战.html":{"url":"依赖注入实战.html","title":"[进阶]依赖注入实战","keywords":"","body":"前言 之前我们也学习过了 angular 框架的依赖注入的一些基本使用方式，今天将更加深入的学习下依赖注入 用 @Optional 来让依赖是可选的，以及使用 @Host 来限定搜索方式 依赖可以注册在组件树的任何层级上。 当组件请求某个依赖时，Angular 会从该组件的注入器找起，沿着注入器树向上，直到找到了第一个满足要求的提供商。如果没找到依赖，Angular 就会抛出一个错误。 某些情况下，你需要限制搜索，或容忍依赖项的缺失。 你可以使用组件构造函数参数上的 @Host 和 @Optional 这两个限定装饰器来修改 Angular 的搜索行为。 @Optional 属性装饰器告诉 Angular 当找不到依赖时就返回 null。 @Host 属性装饰器会禁止在宿主组件以上的搜索。宿主组件通常就是请求该依赖的那个组件。 不过，当该组件投影进某个父组件时，那个父组件就会变成宿主。 constructor( @Host() // 查找HeroCacheService实例限制在该组件或者它的父组件以下 private heroCache: HeroCacheService, @Host() @Optional() // 限制在该组件的父组件内查找，如果没有找到则返回null，也不会报错 private loggerService: LoggerService ) 使用 @Inject 指定自定义提供商 自定义提供商让你可以为隐式依赖提供一个具体的实现，比如内置浏览器 API。下面的例子使用 InjectionToken 来提供 localStorage，将其作为 BrowserStorageService 的依赖项。 import { Inject, Injectable, InjectionToken } from '@angular/core'; export const BROWSER_STORAGE = new InjectionToken('Browser Storage', { providedIn: 'root', factory: () => localStorage }); @Injectable({ providedIn: 'root' }) export class BrowserStorageService { constructor(@Inject(BROWSER_STORAGE) public storage: Storage) {} get(key: string) { this.storage.getItem(key); } set(key: string, value: string) { this.storage.setItem(key, value); } remove(key: string) { this.storage.removeItem(key); } clear() { this.storage.clear(); } } factory 函数返回 window 对象上的 localStorage 属性。Inject 装饰器修饰一个构造函数参数，用于为某个依赖提供自定义提供商。 使用 @Self 和 @SkipSelf 来修改提供商的搜索方式 注入器也可以通过构造函数的参数装饰器来指定范围。下面的例子就在 Component 类的 providers 中使用浏览器的 sessionStorage API 覆盖了 BROWSER_STORAGE 令牌。同一个 BrowserStorageService 在构造函数中使用 @Self 和 @SkipSelf 装饰器注入了两次，来分别指定由哪个注入器来提供依赖。 import { Component, OnInit, Self, SkipSelf } from '@angular/core'; import { BROWSER_STORAGE, BrowserStorageService } from './storage.service'; @Component({ selector: 'app-storage', template: ` Open the inspector to see the local/session storage keys: Session Storage Set Session Storage Local Storage Set Local Storage `, providers: [ BrowserStorageService, { provide: BROWSER_STORAGE, useFactory: () => sessionStorage } ] }) export class StorageComponent implements OnInit { constructor( @Self() private sessionStorageService: BrowserStorageService, // BrowserStorageService会读取该组件提供的 BROWSER_STORAGE @SkipSelf() private localStorageService: BrowserStorageService, // BrowserStorageService跳过该组件提供的 BROWSER_STORAGE 则默认读取自己组件的依赖 ) { } ngOnInit() { } setSession() { this.sessionStorageService.set('hero', 'Dr Nice - Session'); } setLocal() { this.localStorageService.set('hero', 'Dr Nice - Local'); } } 使用 @Self 装饰器时，注入器只在该组件的注入器中查找提供商。@SkipSelf 装饰器可以让你跳过局部注入器，并在注入器树中向上查找，以发现哪个提供商满足该依赖。 sessionStorageService 实例使用浏览器的 sessionStorage 来跟 BrowserStorageService 打交道，而 localStorageService 跳过了局部注入器，使用根注入器提供的 BrowserStorageService，它使用浏览器的 localStorage API。 使用提供商来定义依赖 为了从依赖注入器中获取服务，你必须传给它一个令牌。 Angular 通常会通过指定构造函数参数以及参数的类型来处理它。 参数的类型可以用作注入器的查阅令牌。 Angular 会把该令牌传给注入器，并把它的结果赋给相应的参数。 constructor(logger: LoggerService) { logger.logInfo('Creating HeroBiosComponent'); } Angular 会要求注入器提供与 LoggerService 相关的服务，并把返回的值赋给 logger 参数。 如果注入器已经缓存了与该令牌相关的服务实例，那么它就会直接提供此实例。 如果它没有，它就要使用与该令牌相关的提供商来创建一个。 定义提供商的几种方式 import { Component, Inject } from '@angular/core'; import { DateLoggerService } from './date-logger.service'; import { Hero } from './hero'; import { HeroService } from './hero.service'; import { LoggerService } from './logger.service'; import { MinimalLogger } from './minimal-logger.service'; import { RUNNERS_UP, runnersUpFactory } from './runners-up'; @Component({ selector: 'app-hero-of-the-month', templateUrl: './hero-of-the-month.component.html', providers: [ { provide: Hero, useValue: someHero }, { provide: TITLE, useValue: 'Hero of the Month' }, { provide: HeroService, useClass: HeroService }, { provide: LoggerService, useClass: DateLoggerService }, { provide: MinimalLogger, useExisting: LoggerService }, { provide: RUNNERS_UP, useFactory: runnersUpFactory(2), deps: [Hero, HeroService] } ] }) export class HeroOfTheMonthComponent { logs: string[] = []; constructor( logger: MinimalLogger, public heroOfTheMonth: Hero, @Inject(RUNNERS_UP) public runnersUp: string, @Inject(TITLE) public title: string) { this.logs = logger.logs; logger.logInfo('starting up'); } } 【值提供商：useValue】useValue 键让你可以为 DI 令牌关联一个固定的值。 使用该技巧来进行运行期常量设置，比如网站的基础地址和功能标志等。 你也可以在单元测试中使用值提供商，来用一个 Mock 数据来代替一个生产环境下的数据服务。 【类提供商：useClass】useClass 提供的键让你可以创建并返回指定类的新实例。 你可以使用这类提供商来为公共类或默认类换上一个替代实现。比如，这个替代实现可以实现一种不同的策略来扩展默认类，或在测试环境中模拟真实类的行为 【别名提供商：useExisting】useExisting 提供了一个键，让你可以把一个令牌映射成另一个令牌。实际上，第一个令牌就是第二个令牌所关联的服务的别名，这样就创建了访问同一个服务对象的两种途径。 { provide: MinimalLogger, useExisting: LoggerService } MinimalLogger 可以访问 LoggerService 服务 【工厂提供商：useFactory】useFactory 提供了一个键，让你可以通过调用一个工厂函数来创建依赖实例 { provide: RUNNERS_UP, useFactory: runnersUpFactory(2), deps: [Hero, HeroService] } 注入器通过调用你用 useFactory 键指定的工厂函数来提供该依赖的值。 注意，提供商的这种形态还有第三个键 deps，它指定了供 useFactory 函数使用的那些依赖。 runners-up.ts export function runnersUpFactory(take: number) { return (winner: Hero, heroService: HeroService): string => { /* ... */ }; }; 提供替代令牌：'InjectionToken' 依赖对象可以是一个简单的值，比如日期，数字和字符串，或者一个无形的对象，比如数组和函数。 这样的对象没有应用程序接口，所以不能用一个类来表示。更适合表示它们的是：唯一的和符号性的令牌，一个 JavaScript 对象，拥有一个友好的名字，但不会与其它的同名令牌发生冲突。 InjectionToken 具有这些特征。在Hero of the Month例子中遇见它们两次，一个是 title 的值，一个是 runnersUp 工厂提供商。 { provide: TITLE, useValue: 'Hero of the Month' }, { provide: RUNNERS_UP, useFactory: runnersUpFactory(2), deps: [Hero, HeroService] } 这样创建 TITLE 令牌： import { InjectionToken } from '@angular/core'; export const TITLE = new InjectionToken('title'); 使用一个前向引用(forwardRef)来打破循环 在 TypeScript 里面，类声明的顺序是很重要的。如果一个类尚未定义，就不能引用它。 这通常不是一个问题，特别是当你遵循一个文件一个类规则的时候。 但是有时候循环引用可能不能避免。当一个类A 引用类 B，同时'B'引用'A'的时候，你就陷入困境了：它们中间的某一个必须要先定义。 Angular 的 forwardRef() 函数建立一个间接地引用，Angular 可以随后解析。 providers: [{ provide: Parent, useExisting: forwardRef(() => AlexComponent) }], forwardRef 允许引用尚未定义的引用 class Door { lock: Lock; // Door attempts to inject Lock, despite it not being defined yet. // forwardRef makes this possible. constructor(@Inject(forwardRef(() => Lock)) lock: Lock) { this.lock = lock; } } // Only at this point Lock is defined. class Lock {} Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-21 11:21:54 "},"angular中组件的引用.html":{"url":"angular中组件的引用.html","title":"[进阶]angular 中组件的引用","keywords":"","body":"前言 现在我有3个组件他们之间的关系是父组件：RefParentComponent import { Component, OnInit } from '@angular/core'; @Component({ selector: 'ref-parent', templateUrl: './ref-parent.component.html', styleUrls: ['./ref-parent.component.css'] }) export class RefParentComponent implements OnInit { constructor() { } ngOnInit() { } mult(a,b){ return a * b; } } 子组件1：RefChildOneComponent import { Component, OnInit } from '@angular/core'; @Component({ selector: 'ref-child-one', templateUrl: './ref-child-one.component.html', styleUrls: ['./ref-child-one.component.css'] }) export class RefChildOneComponent implements OnInit { constructor() { } ngOnInit() { } add(a,b){ return a + b; } } 子组件2：RefChildTwoComponent import { Component, OnInit } from '@angular/core'; @Component({ selector: 'ref-child-two', templateUrl: './ref-child-two.component.html', styleUrls: ['./ref-child-two.component.css'] }) export class RefChildTwoComponent implements OnInit { constructor() { } ngOnInit() { } sub(a,b){ return a - b; } } 现在我希望： RefParentComponent 获取到 RefChildOneComponent 的引用 RefChildOneComponent 获取到 RefParentComponent 的引用 RefChildOneComponent 获取到 RefChildTwoComponent 的引用 这也是今天我们主要讲解的，组件中的引用 父组件中引用子组件 父组件HTML： 父组件TS： import { Component, OnInit, ViewChild, AfterViewInit } from '@angular/core'; import { RefChildOneComponent } from \"./ref-child-one/ref-child-one.component\"; @Component({ selector: 'ref-parent', templateUrl: './ref-parent.component.html', styleUrls: ['./ref-parent.component.css'] }) export class RefParentComponent implements OnInit, AfterViewInit { @ViewChild(RefChildOneComponent) childOne:RefChildOneComponent; constructor() { } ngOnInit() { } ngAfterViewInit(){ console.log(this.childOne); this.childOne.add(1,2); } mult(a,b){ return a * b; } } 子组件中引用父组件 方法1： import {Component, OnInit, Optional} from '@angular/core'; import {RefParentComponent} from \"../ref-parent.component\"; @Component({ selector: 'ref-child-two', templateUrl: './ref-child-two.component.html', styleUrls: ['./ref-child-two.component.css'] }) export class RefChildTwoComponent implements OnInit { constructor(@Optional() public parentComponent: RefParentComponent) { } ngOnInit() { this.parentComponent.mult(1,2); // 引用父组件中的方法 this.parentComponent.childOne.add(1,2); // 引用父组件中引用的子组件的方法 } sub(a,b){ return a - b; } } 方法2： parent export abstract class Parent { mult(a,b){}; } RefParentComponent import { Component, OnInit, ViewChild, AfterViewInit, forwardRef } from '@angular/core'; import { RefChildOneComponent } from \"./ref-child-one/ref-child-one.component\"; import { Parent } from \"./parent\"; @Component({ selector: 'ref-parent', templateUrl: './ref-parent.component.html', styleUrls: ['./ref-parent.component.css'], // 父组件通过providers 把自己当service提供出去了。这样子组件可以直接注入该服务，就可获取父组件的引用 providers: [{ provide: Parent, useExisting: forwardRef(() => RefParentComponent) }], // forwardRef: 允许引用尚未定义的引用，这里RefParentComponent尚未定义，因为是引用自己，自己在下方定义了。 }) export class RefParentComponent implements OnInit, AfterViewInit { @ViewChild(RefChildOneComponent) childOne:RefChildOneComponent; constructor() { } ngOnInit() { } ngAfterViewInit(){ console.log(this.childOne); this.childOne.add(1,2); } mult(a,b){ return a * b; } } RefChildOneComponent import { Component, OnInit, Optional } from '@angular/core'; import { Parent } from \"../parent\"; @Component({ selector: 'ref-child-one', templateUrl: './ref-child-one.component.html', styleUrls: ['./ref-child-one.component.css'] }) export class RefChildOneComponent implements OnInit { // 直接通过DI注入父组件提供的服务 constructor(@Optional() public parent: Parent) { } ngOnInit() { console.log(this.parent.mult(1,2)); } add(a,b){ return a + b; } } 兄弟组件引用 ref-parent/ref-parent.component.html ref-child-two import {Component, OnInit, Optional,Input} from '@angular/core'; import {RefParentComponent} from \"../ref-parent.component\"; @Component({ selector: 'ref-child-two', templateUrl: './ref-child-two.component.html', styleUrls: ['./ref-child-two.component.css'] }) export class RefChildTwoComponent implements OnInit { @Input() com; // 注入 constructor(@Optional() public parentComponent: RefParentComponent) { } ngOnInit() { this.parentComponent.mult(1,2); this.parentComponent.childOne.add(1,2); console.log(this.com); } sub(a,b){ return a - b; } } 将 ref-child-one 组件实例注入到 ref-child-two中。 最佳实践 其实项目中避免不了组件之间的引用，但是最好的办法还是引入service。这也是angular胜过其他框架的地方 RefService import { Injectable } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class RefService { constructor() { } multSer(a,b){ return a * b; } addSer(a,b){ return a + b; } subSer(a,b){ return a - b; } } 组件中注入： import { Component, OnInit, Optional } from '@angular/core'; import { Parent } from \"../parent\"; import { RefService } from \"../../../shared/service/ref.service\"; @Component({ selector: 'ref-child-one', templateUrl: './ref-child-one.component.html', styleUrls: ['./ref-child-one.component.css'] }) export class RefChildOneComponent implements OnInit { constructor( @Optional() public parent: Parent, private ref : RefService ) { } ngOnInit() { console.log(this.ref.addSer(1,5)); } add(a,b){ return a + b; } } service + EventEmitter 实现多组件间数据实时交互 RefService import { Injectable, EventEmitter } from '@angular/core'; @Injectable({ providedIn: 'root' }) export class RefService { numChange: EventEmitter; constructor() { this.numChange = new EventEmitter(); } } RefChildOneComponent：发射数据 import { Component, OnInit, Optional } from '@angular/core'; import { Parent } from \"../parent\"; import { RefService } from \"../../../shared/service/ref.service\"; @Component({ selector: 'ref-child-one', templateUrl: './ref-child-one.component.html', styleUrls: ['./ref-child-one.component.css'] }) export class RefChildOneComponent implements OnInit { constructor( @Optional() public parent: Parent, private ref : RefService ) { } ngOnInit() { // RefChildOneComponent 子组件不断发射数据 let i = 0; setInterval(()=> { this.ref.numChange.emit(i++); }, 1000); } } RefChildTwoComponent：实时接收RefChildOneComponent发送过来的数据 import {Component, OnInit, Optional,Input} from '@angular/core'; import {RefParentComponent} from \"../ref-parent.component\"; import {RefService} from \"../../../shared/service/ref.service\"; @Component({ selector: 'ref-child-two', templateUrl: './ref-child-two.component.html', styleUrls: ['./ref-child-two.component.css'] }) export class RefChildTwoComponent implements OnInit { constructor( private ref : RefService ) { } ngOnInit() { // RefChildTwoComponent 组件中不断接受来自 RefChildOneComponent 组件发射过来的数据 this.ref.numChange.subscribe((value:number)=>{ console.log(value); }); } } 这样在没有关联的两个组件中进行数据交互是非常方便的，之后引入rxjs配合angular的service依赖注入，将会给我们提供更加强大的跨组件交互能力。 小结 通过本文我们学习了组件间的一些引用实现。但是请尽量减少这样的写法，多引入service服务。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-21 16:04:20 "},"Input的set还是ngOnChanges.html":{"url":"Input的set还是ngOnChanges.html","title":"[重难]@Input() 的 set or ngOnChanges()","keywords":"","body":"场景描述 父组件： import { Component, OnInit } from '@angular/core'; @Component({ selector: 'app-set-data', templateUrl: './set-data.component.html', styleUrls: ['./set-data.component.css'] }) export class SetDataComponent implements OnInit { heroList = [ { name: \"jack\", age: 18 } ]; constructor() { } ngOnInit() { } } html: 子组件展示： 子组件： import { Component, OnInit, Input } from '@angular/core'; @Component({ selector: 'child-data', templateUrl: './child-data.component.html', styleUrls: ['./child-data.component.css'] }) export class ChildDataComponent implements OnInit { @Input() heroList; constructor() { } ngOnInit() { console.log(this.heroList); } } 以上代码：父组件通过@Input()的方式把heroList传递给子组件，子组件要添加一些附加东西来适应子组件的渲染，譬如添加checked是否被选中。 我们把子组件代码改善一下： ngOnInit() { this.heroList.forEach((item)=>{ item['checked'] = false; }) } 现在假设父组件中的heroList因为某种原因，在后期需要拉取后台的数据进行更新，那么我们在子组件就不能在ngOnInit对数据进行操作了，因为父组件后期还会更改heroList里面的数据例如往里面再添加一条。 此时我们在子组件中该如何处理呢？ angular提供了两种方法给我们 Input的set方法 ngOnChanges的声明周期中获取 Input的set方法 我们把上面的代码再次修改下：父组件： ngOnInit() { setTimeout(()=>{ this.heroList.push({ name: \"tom\", age: 26 }) },3000) } 开一个定时器在3s后添加一条数据进来 子组件： export class ChildDataComponent implements OnInit { _heroList; @Input() set heroList(value){ this._heroList = value; this._heroList.forEach((item)=>{ item['checked'] = false; }); }; constructor() { } ngOnInit() { } } html: {{hero.name}} 我们来看下页面的变化： 从图片中我们可以看到当3秒后，增加了一条数据，说明setter函数感知到数据变换了。 ngOnChanges方法 一个生命周期钩子，当指令的任何一个可绑定属性发生变化时调用。 定义一个 ngOnChanges() 方法来处理这些变更 interface OnChanges { ngOnChanges(changes: SimpleChanges): void } 触发条件： @input属性(输入属性)发生变化时，会调用。非此属性，不会调用。 当输入属性为对象时，当对象的属性值发生变化时，不会调用，当对象的引用变化时会触发。 我们改动下子组件的代码： import { Component, OnInit, Input, OnChanges, SimpleChanges } from '@angular/core'; @Component({ selector: 'child-data', templateUrl: './child-data.component.html', styleUrls: ['./child-data.component.css'] }) export class ChildDataComponent implements OnInit, OnChanges { _heroList; @Input() heroList; constructor() { } ngOnInit() { } ngOnChanges({heroList}: SimpleChanges){ if(heroList.currentValue.length > 0){ this._heroList = heroList.currentValue; this._heroList.forEach((item)=>{ item['checked'] = false; }); } } } 我们同样实现了上面一样的功能 我们打印下heroList对象，看下是什么： currentValue: 最新的valuepreviousValue: 上一次的value 我们发现这个方法不仅提供了最新的值，还保留了上一次的值。 但是有一个问题，上面也提到了对象的属性值改变是不会触发的，只要更改了对象的引用才会触发的，针对这个问题，有没有好的解决方案呢。 最好的解决方案就是使用 service + rxjs的方式解决，题主在后期也会深入学习rxjs + service 进行数据管理的 小结 在通常情况下使用 setter方式 或者 ngOnChanges 的方式都可以，具体看业务需求。 stack overflow中有一个回答可以参考下： One advantage of ngOnChanges() is that you get all changes at once if your component has several @Input()s. If your code only depends on a single @Input() a setter is probably the better approach. 意思是有多个@Input()的时候使用ngOnChanges来监听，只有单个@Input()的时候选用setter方式。 本文代码地址 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 11:40:19 "},"HttpClient.html":{"url":"HttpClient.html","title":"Angular HttpClient","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:30:28 "},"Angular-ngContent.html":{"url":"Angular-ngContent.html","title":"Angular 内容投影 ng-content","keywords":"","body":"前言 最近在编写一个先对比较大点的项目，其中可以抽取的公用组件非常多，然后就一直在思考，该如何让通用组件做到更加灵活。于是不断翻阅各类相关文章，终于ng-content走入了我的视线。今天这篇文章将主要讲解如何使用ng-content。 完整代码地址 什么是ng-content 将Angular的组件或者内容投影进另外一个组件。你可以认为它等价于 node.appendChild(el)或 jQuery 中的 $(node).append(el) 方法：使用这些方法，节点不被克隆，它被简单地移动到它的新位置。因此，投影内容的生命周期将被绑定到它被声明的地方，而不是显示在地方。 因为 ng-content 只是移动元素，所以可以在编译时完成，而不是在运行时，这大大减少了实际应用程序的工作量。 没有它我们是怎么工作的 先实现一个简单的弹窗组件： 创建组件： ng g c modal-container // 弹窗mask层 ng g c modal-container/modal-inner // 弹窗内容层 modal-container modal-inner X {{title}} {{content}} 取消 确定 具体样式可以到github上查看。来看看现在的布局 我们可以看到，标题和内容是通过@Input 传递进组件的。 这也是我们在编写一个组件最开始能想到的方法。 现在可以看到content是写死在一个p标签内部。如果我们想做到更加通用该怎么办？其实很简单，就是在组件外直接传递DOM结构进来。这应该就是最直观的方式。所以就有本文的主题ng-content。 有了它之后该如何改进 modal-inner // 原本的传值替换成ng-content modal-container 这个是传入DOM结构 // 在这里传入DOM 可以看到也成功展示出来了，那么我们现在就可以传入一个完整的DOM进去了，大大的提高了组件的灵活性了。 ng-content 基础使用 正常来说，我们会直接传入一个组件进app-modal-inner的content，这样灵活性更大。 ng g c modal-container/modal-content modal-container select 属性 此时又来一个需求要把标题改成红色的？那么怎么办，把标题也改成ng-content的形式传入把。 创建标题组件 ng g c modal-container/modal-title modal-container // 传入标题组件 // 传入内容组件 modal-inner ... ... 看看效果： 你会发现传入的两个组件都只进入modal-body的ng-content中。 是的，当传入多个ng-content时，是没有办法区分的。这个时候需要添加select指令。 select = 传入的组件名 此时你会发现各种都对应上了。 ContentChild && ContentChildren 在有些实现时，我们可能需要在宿主组件中获取投影组件的实例，ContentChild && ContentChildren 支持我们这样做。 【ContentChild】modal-inner import { Component, OnInit, AfterContentInit, ContentChild } from '@angular/core'; import { ModalContentComponent } from '../modal-content/modal-content.component'; @Component({ selector: 'app-modal-inner', templateUrl: './modal-inner.component.html', styleUrls: ['./modal-inner.component.css'] }) export class ModalInnerComponent implements OnInit, AfterContentInit { @ContentChild(ModalContentComponent) contentCom: ModalContentComponent; constructor() { } ngOnInit() { } ngAfterContentInit() { console.log(this.contentCom); // 可以正确的打印出`ModalContentComponent`实例 } } @ContentChild 的作用同 @ViewChild 的作用相同 我们现在就可以获取到ModalContentComponent中的数据已经方法。 【ContentChildren】除了 ContentChild 装饰器之外，Angular 还为我们提供了一个 ContentChildren 装饰器，用来从通过 Content Projection 方式设置的视图中获取匹配的多个元素，返回的结果是一个 QueryList 集合。 用法同上这里就不赘述了。 ngProjectAs 有时候我们的定义的组件可能会包含在其它容器中，比如 ，这时我们的目标投影会发生什么： modal-container // 添加了ng-container的包裹 看下效果： 你会发现标题不见了。这个时候就需要ngProjectAs的帮助了 现在再去看又恢复了。这个就是ngProjectAs的作用。 小结 通过这边文章，我们学习了ng-content该如何使用，以及它的使用场景。以后就可以使用它编写更加通用的组件了。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-27 12:05:05 "},"Angular操作DOM详解.html":{"url":"Angular操作DOM详解.html","title":"Angular 操作 DOM 详解","keywords":"","body":"前言 已经使用angular2+编写项目一段时间了，官网教程也看了一遍，但是一直以来好像对于angular是如何操作DOM好像还是一点都不懂，今天这篇文章主要讲解angular是如何操作DOM的。 新版本 Angular 需要在不同平台上运行，如 Browser 平台，Mobile 平台或者 Web Worker 平台，所以，就需要在特定平台的 API 和框架接口之间进行一层抽象（abstraction）。 Angular 中的这层抽象就包括这些引用类型：ElementRef、TemplateRef、ViewRef、ComponentRef 和 ViewContainerRef。 @ViewChild 在探索 DOM 抽象类前，先了解下如何在组件/指令中获取这些抽象类。Angular 提供了一种叫做 DOM Query 的技术，主要来源于 @ViewChild 和 @ViewChildren 装饰器（decorators）。两者基本功能相同，唯一区别是 @ViewChild 返回单个引用，@ViewChildren 返回由 QueryList 对象包装好的多个引用。本文示例中主要以 ViewChild 为例，并且描述时省略 @。 通常这两个装饰器与模板引用变量（template reference variable）一起使用，模板引用变量仅仅是对模板（template）内 DOM 元素命名式引用（a named reference），类似于 html 元素的 id 属性。你可以使用模板引用（template reference）来标记一个 DOM 元素，并在组件/指令类中使用 ViewChild 装饰器查询（query）它，比如： @Component({ selector: 'sample', template: ` I am span ` }) export class SampleComponent implements AfterViewInit { @ViewChild(\"tref\", {read: ElementRef}) tref: ElementRef; ngAfterViewInit(): void { // outputs `I am span` console.log(this.tref.nativeElement.textContent); } } ViewChild 装饰器基本语法是： @ViewChild([reference from template], {read: [reference type]}); 上例中你可以看到，我把 tref 作为模板引用名称，并将 ElementRef 与该元素联系起来。第二个参数 read 是可选的，因为 Angular 会根据 DOM 元素的类型推断出该引用类型。例如，如果它（#tref）挂载的是类似 span 的简单 html 元素，Angular 返回 ElementRef；如果它挂载的是 template 元素，Angular 返回 TemplateRef。一些引用类型如 ViewContainerRef 就不可以被 Angular 推断出来，所以必须在 read 参数中显式申明。其他的如 ViewRef 不可以挂载在 DOM 元素中，所以必须手动在构造函数中编码构造出来。 现在，让我们看看应该如何获取这些引用，一起去探索吧。 获取DOM元素的方式 ElementRef 这是最基本的抽象类，如果你查看它的类结构，就发现它只包含所挂载的元素对象，这对访问原生 DOM 元素很有用，比如： // outputs `I am span` console.log(this.tref.nativeElement.textContent); 然而，Angular 团队不鼓励这种写法，不但因为这种方式会暴露安全风险，而且还会让你的程序与渲染层（rendering layers）紧耦合，这样就很难在多平台运行你的程序。我认为这个问题并不是使用 nativeElement 而是使用特定的 DOM API 造成的，如 textContent。但是后文你会看到，Angular 实现了操作 DOM 的整体思路模型，这样就不再需要低阶 API，如 textContent。 使用 ViewChild装饰的 DOM 元素会返回 ElementRef，但是由于所有组件挂载于自定义 DOM 元素，所有指令作用于 DOM 元素，所以组件和指令都可以通过 DI（Dependency Injection）获取宿主元素的ElementRef 对象。比如： @Component({ selector: 'sample', ... export class SampleComponent{ constructor(private hostElement: ElementRef) { console.log(this.hostElement.nativeElement.outerHTML); //outputs ... } ... 所以组件通过 DI（Dependency Injection）可以访问到它的宿主元素，但 ViewChild 装饰器经常被用来获取模板视图中的 DOM 元素。然而指令却相反，因为指令没有视图模板，所以主要用来获取指令挂载的宿主元素。 TemplateRef Angular 采用 template 标签这种方式，实现了 TemplateRef 抽象类来和 template 标签一起合作，看看它是如何使用的（译者注：ng-template 是 Angular 提供的类似于 template 原生 html 标签）： @Component({ selector: 'sample', template: ` I am span in template ` }) export class SampleComponent implements AfterViewInit { @ViewChild(\"tpl\") tpl: TemplateRef; ngAfterViewInit() { let elementRef = this.tpl.elementRef; // outputs `template bindings={}` console.log(elementRef.nativeElement.textContent); } } Angular 框架从 DOM 中移除 template 元素，并在其位置插入注释，这是渲染后的样子： [注意]ng-template里面的代码是不会被直接渲染出来的，只能获取到它的DOM元素，然后进行动态插入 TemplateRef 是一个结构简单的抽象类，它的 elementRef 属性是对其宿主元素的引用，还有一个 createEmbeddedView 方法。然而 createEmbeddedView 方法很有用，因为它可以创建一个视图（view）并返回该视图的引用对象 ViewRef。 ViewRef 该抽象表示一个 Angular 视图（View），在 Angular 世界里，视图（View）是一堆元素的组合，一起被创建和销毁，是构建程序 UI 的基石。Angular 鼓励开发者把 UI 作为一堆视图（View）的组合，而不仅仅是 html 标签组成的树。 Angular 支持两种类型视图： 嵌入视图（Embedded View），由 Template 提供 宿主视图（Host View），由 Component 提供 创建嵌入视图 模板仅仅是视图的蓝图，可以通过之前提到的 createEmbeddedView 方法创建视图，比如： ngAfterViewInit() { let view = this.tpl.createEmbeddedView(null); } 创建宿主视图 ComponentFactoryResolver 宿主视图是在组件动态实例化时创建的，一个动态组件（dynamic component）可以通过 ComponentFactoryResolver 创建： 新增一个组件ModalContainerComponent constructor(private injector: Injector, private r: ComponentFactoryResolver) { let factory = this.r.resolveComponentFactory(ModalContainerComponent); let componentRef = factory.create(injector); let view = componentRef.hostView; } 在 Angular 中，每一个组件绑定着一个注入器（Injector）实例，所以创建 ModalContainerComponent 组件时传入当前组件（即 SampleComponent）的注入器。另外，别忘了，动态创建组件时需要在模块（module）或宿主组件的 EntryComponents 属性添加被创建的组件。 app.module.ts import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { OverlayModule } from '@angular/cdk/overlay'; import { AppComponent } from './app.component'; import { ModalContainerComponent } from './modal-container/modal-container.component'; @NgModule({ declarations: [ AppComponent, ModalContainerComponent ], imports: [ BrowserModule, OverlayModule ], providers: [], bootstrap: [AppComponent], entryComponents: [ModalContainerComponent] // 这里一定要添加 }) export class AppModule { } 这里就不得不提到一句什么是entry component。以下是文档原文： An entry component is any component that Angular loads imperatively by type. 所有通过类型进行命令式加载的组件都是入口组件。 现在，我们已经看到嵌入视图和宿主视图是如何被创建的，一旦视图被创建，它就可以使用 ViewContainer 插入 DOM 树中。下文主要探索这个功能。 渲染DOM的方式 把上面生成的View，挂载到视图容器上。 ViewContainerRef 视图容器就是挂载一个或多个视图的容器。 首先需要说的是，任何 DOM 元素都可以作为视图容器，然而有趣的是，对于绑定 ViewContainer 的 DOM 元素，Angular 不会把视图插入该元素的内部，而是追加到该元素后面，这类似于 router-outlet 插入组件的方式。 通常，比较好的方式是把 ViewContainer 绑定在 ng-container 元素上，因为 ng-container 元素会被渲染为注释，从而不会在 DOM 中引入多余的 html 元素。下面示例描述在组建模板中如何创建 ViewContainer： 操作视图 ViewContainer 提供了一些操作视图 API： class ViewContainerRef { ... clear() : void // 清空视图容器中的视图 insert(viewRef: ViewRef, index?: number) : ViewRef // 插入视图 get(index: number) : ViewRef // 获取相应索引上的视图引用 indexOf(viewRef: ViewRef) : number // 获取某个视图view的索引值 detach(index?: number) : ViewRef // 清空某个索引下的视图引用 move(viewRef: ViewRef, currentIndex: number) : ViewRef // 移动视图 } 从上文我们已经知道如何通过模板和组件创建两种类型视图，即嵌入视图和组件视图。一旦有了视图，就可以通过 insert 方法插入 DOM 中。 @Component({ selector: 'sample', template: ` I am first span I am last span I am span in template ` }) export class SampleComponent implements AfterViewInit { @ViewChild(\"vc\", {read: ViewContainerRef}) vc: ViewContainerRef; // 获取视图容器 @ViewChild(\"tpl\") tpl: TemplateRef; // 获取模板引用 ngAfterViewInit() { let view = this.tpl.createEmbeddedView(null); // 创建嵌入视图 this.vc.insert(view); // 插入视图容器 } } 可以通过 detach 方法从视图中移除 DOM 创建视图 ViewContainer 也提供了手动创建视图 API ： class ViewContainerRef { element: ElementRef length: number createComponent(componentFactory...): ComponentRef createEmbeddedView(templateRef...): EmbeddedViewRef ... } 上面两个方法是个很好的封装，可以传入模板引用对象或组件工厂对象来创建视图，并将该视图插入视图容器中特定位置。 ngAfterViewInit() { this.vc.createEmbeddedView(this.tpl); // 创建view 并插入到容器中 } ngTemplateOutlet && ngComponentOutlet 尽管知道 Angular 操作 DOM 的内部机制是好事，但是要是有某种快捷方式就更好了啊。没错，Angular 提供了两种快捷指令：ngTemplateOutlet 和 ngComponentOutlet。 【ngTemplateOutlet】该指令会把 DOM 元素标记为 ViewContainer，并插入由模板创建的嵌入视图，从而不需要在组件类中显式创建该嵌入视图。这样，上面实例中，针对创建嵌入视图并插入 #vc DOM 元素的代码就可以重写： @Component({ selector: 'sample', template: ` I am first span I am last span I am span in template ` }) export class SampleComponent {} 从上面示例看到我们不需要在组件类中写任何实例化视图的代码。非常方便，对不对。 【ngComponentOutlet】这个指令与 ngTemplateOutlet 很相似，区别是 ngComponentOutlet 创建的是由组件实例化生成的宿主视图，不是嵌入视图。你可以这么使用： 小结 看似有很多新知识需要消化啊，但实际上 Angular 通过视图操作 DOM 的思路模型是很清晰和连贯的。你可以使用 ViewChild 查询模板引用变量来获得 Angular DOM 抽象类。 DOM 元素的最简单封装是 ElementRef。 对于模板，你可以使用 TemplateRef 来创建嵌入视图。 对于组件，可以使用 ComponentRef 来创建宿主视图，同时又可以使用 ComponentFactoryResolver 创建 ComponentRef。 这两个创建的视图（即嵌入视图和宿主视图）又会被 ViewContainerRef 管理。 最后，Angular 又提供了两个快捷指令自动化这个过程：ngTemplateOutlet 指令使用模板创建嵌入视图；ngComponentOutlet 使用动态组件创建宿主视图。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-28 09:31:27 "},"rxjs.html":{"url":"rxjs.html","title":"rxjs","keywords":"","body":"angular学习汇总 使用 Service + Rxjs 进行 Angular 的状态管理 Service的用途-博客文章 rxjs-博客文章 30 天精通 RxJS rxjs 中文文档 产出步骤 1、阅读rxjs 中文文档 2、阅读30 天精通 RxJS 3、阅读一些散博客 4、拟一个文章提纲 5、正式产出 rxjs系列文章 rxjs基本概念入门，Observable、Observer、Subscription、Subject Subject的3个变体 Operators(操作符)以及如何理解弹珠图 Scheduler(调度器) rxjs实战应用(参考下面文章实现todoList) https://github.com/ecmadao/Coding-Guide/blob/master/Notes/RxJS/%E6%8E%A2%E7%B4%A2RxJS-%E5%81%9A%E4%B8%80%E4%B8%AAgithub%E5%B0%8F%E5%BA%94%E7%94%A8.md https://jerryzou.com/posts/rxjs-practice-01/ Angular打造企业级协作平台(慕课视频) Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-08 22:39:42 "},"rxjs简介.html":{"url":"rxjs简介.html","title":"rxjs 简介","keywords":"","body":"RxJS 基本介紹 RxJS 是一个库，它通过使用 observable 序列来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 [Array#extras] 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。 可以把 RxJS 当做是用来处理事件的 Lodash 。 ReactiveX 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。 在 RxJS 中用来解决异步事件管理的的基本概念是： Observable (可观察对象) Observer (观察者) Subscription (订阅) Operators (操作符) Subject (主体) Schedulers (调度器) 下面分别来概述下核心概念，让大家对rxjs的主体部分有个了解 Observable 它是rxjs最核心的概念，理解了它基本上就理解了60%的rxjs了。 标签1：可观察对象 标签2：惰性运算 当我们创建一个Observable可观察对象，只有当我们对它进行订阅了之后，它才会执行；不订阅不执行！ 【创建第一个Observable】 const observable = Observable.create(function (observer) { observer.next(1); }); 【订阅刚刚创建的可观察对象】 const subscriber = observable.subscribe({ next: x => console.log('值：' + x), error: err => console.error('报错：' + err), complete: () => console.log('结束') }); 只有订阅过后它才会去执行。 这时我们可以看下控制台： 输出了上面observer.next(1)推送过来的1; observable生产者 把消息推送给 subscriber消费者 上面创建的是一个同步执行的Observable，接下来我们来创建一个异步的Observable asyncObservable() { const observable = Observable.create(function (observer) { setTimeout(() => { observer.next(1); // 这里就好比我们跟后台请求的数据，在angular中一般存放在service中 }, 3000 ); }); console.log('before subscribe'); // 这里就好比我们在组件中订阅了service的请求数据，当异步数据请求到了就会返回给组件 observable.subscribe({ next: x => console.log('值：' + x), error: err => console.error('报错：' + err), complete: () => console.log('结束') }); console.log('after subscribe'); } 输出循序： before subscribe after subscribe 值：1 我们通过这种方式就已经替代了基础版本的 callback模式回调处理请求来的数据。 上面我们对可观察对象分别做了几个动作：创建、订阅、执行 既然有创建就一定有清除，不然就要内存溢出了 【清除一个可观察对象】 clearObservable() { const observable = Observable.create(function (observer) { setTimeout(() => { observer.next(1); }, 3000 ); }); const subscriber = observable.subscribe({ next: x => console.log('值：' + x), error: err => console.error('报错：' + err), complete: () => console.log('结束') }); subscriber.unsubscribe(); // 这句就是清除一个可观察对象 } 到这里为止，已经基本上对 Observable 这个可观察对象已经有一个了解了。 Observer 它的中文名叫观察者，观察者是由 Observable 发送的值的消费者。 上面已经提到了 Observable是生产者；subscriber是消费者。 Observer 对 Observable next(1) 出来的值进行了消费。 通俗来讲就是它了： const observer = { next: x => console.log('值：' + x), error: err => console.error('报错：' + err), complete: () => console.log('结束') } const subscriber = observable.subscribe(observer); 这样看代码是不是清晰了很多：observer = '值的消费者' = '对象且包含一组不类型的消费者'所以说对象里面的 next: ()=>{} , error: ()=>{} , complete: ()=>{} 这三个函数就是真正意义上的数据消费者了，它们3个就组成了数据消费对象observer 所以Observer的标签就是： 观察者 值的消费者 Observer特性 底下有3个数据消费者，当我派出哪个函数，才会消费相应的数据，不派出则不消费 例如： var observer = { next: x => console.log('Observer got a next value: ' + x), error: err => console.error('Observer got an error: ' + err), }; 这样我们就消费不到complete传来的数据，但是其他传来的数据都可以正常消费。 Subscription Subscription 是表示可清理资源的对象，通常是 Observable 的执行。 Subscription 有一个重要的方法，即 unsubscribe，它不需要任何参数，只是用来清理由 Subscription 占用的资源。 var observable = Rx.Observable.interval(1000); var subscription = observable.subscribe(x => console.log(x)); // 稍后： // 这会取消正在进行中的 Observable 执行 // Observable 执行是通过使用观察者调用 subscribe 方法启动的 subscription.unsubscribe(); 记住一点，它存在的价值就是用来释放资源或去取消Observable执行。 Subscription的方法 【add()】把一个childSubscription添加到另外一个subscription中 var observable1 = Rx.Observable.interval(400); var observable2 = Rx.Observable.interval(300); var subscription = observable1.subscribe(x => console.log('first: ' + x)); var childSubscription = observable2.subscribe(x => console.log('second: ' + x)); subscription.add(childSubscription); 【remove()】用来撤销一个已添加的子 Subscription 。 var observable1 = Rx.Observable.interval(400); var observable2 = Rx.Observable.interval(300); var subscription = observable1.subscribe(x => console.log('first: ' + x)); var childSubscription = observable2.subscribe(x => console.log('second: ' + x)); subscription.add(childSubscription); subscription.remove(childSubscription); 【unsubscribe()】 取消订阅,释放资源，一般在组件的destroy声明周期进行操作 subscription.unsubscribe(); 以上基本上已经把rxjs的一些基本概念都讲解清楚了，接下来我们来学习些进阶的概念。 Subject Subject 是一种特殊类型的 Observable Subject vs Observable Subject允许将值多播给多个观察者,所以 Subject 是多播的 而普通的 Observables 是单播的(每个已订阅的观察者都拥有 Observable 的独立执行) Subject标签 多播 它就是Observable的一种(子类型) 单播、多播的理解 我们通过代码来理解下多播的概念： observable const observable = Observable.create(function subscribe(observer) { try { observer.next(1); observer.next(2); observer.next(3); observer.complete(); } catch (err) { observer.error(err); } }); observable.subscribe(val => { console.log('第一个监听者：', val ); }); setTimeout(() => { observable.subscribe(val => { console.log('第二个监听者：', val ); }); }, 3000); 看下打印出来的值： 结论：无论什么时候去监听observable都可以获取到该observable推送的所有数据。我们对这种特性就称之为单播 那我们在来看看subject是如何进行数据推送的： const subject = new Subject(); // 监听数据 subject.subscribe({ next: (v) => { console.log(`监听者1：` + v ); } }); subject.subscribe({ next: (v) => { console.log(`监听者2：` + v ); } }); setTimeout(() => { subject.subscribe({ next: (v) => { console.log(`监听者3：` + v ); } }); }, 3000 ); // 推送数据 subject.next(1); subject.next(2); subject.next(3); setTimeout(() => { subject.next(4); }, 4000 ); 我们来看看数据打印的结果： 监听者1和监听者2,最开始就打印出了1，2，3 过了4秒后，监听者1，监听者2，监听者3都打印了一个4 这说明“监听者3”是没有监听到数据1，2，3的，因为它是3秒后才开始监听的，而数据1，2，3则是在它监听之前就已经推送过的数据，所以它只监听到了4，因为4是在4秒后发送的数据。所以监听者1，2，3都可以监听到了 现在拿subject和observable进行对比，我们发现observable的单播，则是每个监听者之间都是非常独立的获取到了observable提供的数据(以往提供 + 未来提供)，而subject向外推送的数据更像一个管道的流水，你什么时候开始监听了，它就会流向你这里。每个监听者都共享同一个管道的流水。 多播:subject 单播:observable 通过上面的图，我们应该就可以理解什么是单播，什么是多播的形式了。 Subject的双重身份 Observable 生产者 Observer 消费者 第一点作为生产者Observable的一种多播形式，上面已经介绍了。 【作为消费者】 每个 Subject 都是观察者。 - Subject 是一个有如下方法的对象： next(v)、error(e) 和 complete() 。要给 Subject 提供新值，只要调用 next(theValue)，它会将值多播给已注册监听该 Subject 的观察者们。 其实这个也是非常好理解的，上面代码中其实我们已经使用了该特性： 1. const subject = new Subject(); 2. subject.next(1); 第二行代码我们可以看出，subject对象是具有next方法的，且调用了该方法就可以向管道中注入一股数据。 subject是一个观察者 == Observer观察者 我们再回顾一下Observable的代码： 1. const observable = Observable.create(function (observer) { observer.next(1); }); 2. const observer = { next: x => console.log('值：' + x), error: err => console.error('报错：' + err), complete: () => console.log('结束') } 3. const subscriber = observable.subscribe(observer); 第三行：observable的监听函数其实就是传入一个observer观察者。 那么我们可以传入一个subject进去吗？答案是可以的。 const observable = Observable.create(function (observer) { observer.next(1); }); const subject = new Subject(); // 监听subject subject.subscribe({ next: (v) => { console.log( '监听者1：' + v ); } }); // 这里其实就是会调用subject的next方法，向subject管道里面注入一股数据1， 此时我们只需要监听subject就可以获取到数据1 observable.subscribe(subject); 数据也可以正常打印，说明subject在这里就是作为一个数据的消费者的功能 这也是把Observable从单播转换为多播的一种方式 小结 到这里我们基本上已经可以理解Subject 与 Observable 了，以及可以理解什么是单播，什么时候多播，已经如何把一个单播的Observable转换为一个多播的Subject。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-08 22:15:42 "},"FunctionalProgramming.html":{"url":"FunctionalProgramming.html","title":"JavaScript 函数式编程","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 15:47:58 "},"Observable.html":{"url":"Observable.html","title":"Observable","keywords":"","body":"Observer Pattern Iterator Pattern Observable(可观察对象) Observables 是多个值的惰性推送集合。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 16:02:44 "},"AngularJs.html":{"url":"AngularJs.html","title":"AngularJs","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:23:03 "},"AngularJS基础.html":{"url":"AngularJS基础.html","title":"AngularJS基础","keywords":"","body":"AngularJS是什么 完全使用js编写的客户端技术。同其他历史悠久的web技术(HTML、CSS)配合使用,使web应用开发比以往更简单、更快捷。AngularJS主要用于构建单页面Web应用。它通过增加开发人员和常见Web应用开发任务之间的抽象级别，使构建交互式的现代Web应用变得更加简单。 高级功能 解耦应用逻辑、数据模型和视图 Ajax服务 依赖注入 浏览历史 测试 容易犯错的地方 【ng-model】AngularJS中的 ng-model 必须得放到对象里面，不然在流程控制语句里面会失效 常用概念集合 【指令】：将DOM元素增强为可复用的DOM组件的属性或元素 【值绑定】：模板语法{{}}可以将表达式绑定到视图上 【过滤器】：可以在视图中使用的函数，用来进行格式化 【表单控件】：用来检验用户输入的控件 【ng-app】ng-app属性声明所有被其包含的内容都属于这个AngularJS应用 【ng-controller】ng-controller DOM元素上的controller属性声明所有被它包含的元素都属于某个控制器 【$】Angular使用$预定义对象 【$rootScope】$rootScope是所有$scope对象的最上层 是AngularJS中最接近全局作用域的对象。在$rootScope上附加太多业务逻辑并不是好主意，这与污染JavaScript的全局作用域是一样的 【$scope】$scope对象：是一个树形结构的JavaScript对象，其中的属性可以被视图访问，也可以同控制器进行交互 $scope的所有属性，都可以自动被视图访问到 【angular.module()函数】angular.module('myApp',[]) 我们告诉Angular希望通过使用它来创建一个名为myApp的模块，该函数返回一个模块 【controller函数】定义了一个新的控制器。它接收两个参数第一个参数：定义了控制器的名称第二个参数：是一个函数定义，它定义了这个控制器将如何工作 常用指令 ng-model 双向数据绑定指令 常用对象 【$scope】存储数据对象 【$timeout】定时器对象 最佳实践 【使用对象的属性进行数据绑定，优于使用对象进行数据绑定】 由于JavaScript自身的特点，以及它在传递值和引用时的不同处理方式，通常认为，在视图中通过对象的属性而非对象本身来进行引用绑定，是Angular中的最佳实践 Hello {{ clock.now }}! // 这样更好 Hello {{ clock }}! // 这样没有上面好 将控制器命名为[Name]Controller而不是[Name]Ctrl是一个最佳实践。 AngularJS中的数据绑定 Hello World Hello {{ name }} 1) 使用ng-modal指令将内部数据模型对象$scope中的name属性(property)绑定到了文本输入字段上 AngularJS则采用了完全不同的解决方案。它创建实时模板来代替视图，而不是将数据合并进模板之后更新DOM AngularJS会记录数据模型所包含的数据在任何特定时间点的值（在Hello World例子中就是name的值），而不是原始值。 当AngularJS认为某个值可能发生变化时，它会运行自己的事件循环来检查这个值是否变“脏”。如果该值从上次事件循环运行之后发生了变化，则该值被认为是“脏”值。这也是Angular可以跟踪和响应应用变化的方式。 比如在游戏开发中就大量使用脏检查技术 模块 使用模块能给我们带来许多好处 保持全局命名空间的清洁 编写测试代码更容易，并能保持其清洁，以便更容易找到互相隔离的功能 易于在不同应用复用代码 使应用能够以任意顺序加载代码的各个部分 声明一个模块 angular.module('myApp', []); 参数1：模块名称参数2：依赖列表 ** 这个方法相当于AngularJS模块的setter方法，是用来定义模块的。 angular.module('myApp') 这个方法相当于getter方法，用来获取对模块的引用 作用域 作用域(scope)是构成AngularJS应用的核心基础，作用域是视图和控制器之间的胶水。视图中的模板会和作用域进行连接，然后应用会对DOM进行设置以便将属性变化通知给AngularJS. 作用域是应用状态的基础。基于动态绑定，我们可以依赖视图在修改数据时立刻更新$scope，也可以依赖$scope在其发生变化时立刻重新渲染视图 AngularJS将$scope设计成和DOM类似的结构，因此$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性 $scope的所有属性，都可以自动被视图访问到 $scope生命周期 【创建】 在创建控制器或指令时，AngularJS会用$injector创建一个新的作用域，并在这个新建的控制器或指令运行时将作用域传递进去 【链接】当Angular开始运行时，所有的$scope对象都会附加或者链接到视图中。所有创建$scope对象的函数也会将自身附加到视图中。这些作用域将会注册当Angular应用上下文中发生变化时需要运行的函数 【更新】当事件循环运行时，它通常执行在顶层$scope对象上，每个子作用域都执行自己的脏值检测，每个监控函数都会检查变化。如果检测到任意变化，$scope对象就会触发指定的回调函数 【销毁】当一个$scope在视图中不再需要时，这个作用域将会清理和销毁自己 控制器 控制器在AngularJS中的作用是增强视图。AngularJS中的控制器是一个函数，用来向视图的作用域中添加额外的功能。我们用它来给作用域对象设置初始状态，并添加自定义行为 第一个控制器代码示例： app.controller('FirstController', function($scope) { $scope.counter = 0; $scope.add = function(amount) { $scope.counter += amount; }; $scope.subtract = function(amount) { $scope.counter -= amount; }; }); 控制器嵌套(作用域包含作用域) AngularJS应用的任何一个部分，无论它渲染在哪个上下文中，都有父级作用域存在。对于ng-app所处的层级来讲，它的父级作用域就是$rootScope 有一个例外：在指令内部创建的作用域被称作孤立作用域 除了孤立作用域外，所有的作用域都通过原型继承而来，也就是说它们都可以访问父级作用域。 表达式 表达式和eval(javascript:;)非常相似，但是由于表达式由AngularJS来处理，它们有以下显著不同的特性： 所有的表达式都在其所属的作用域内部执行，并有访问本地$scope的权限 如果表达式发生了TypeError和ReferenceError并不会抛出异常 不允许使用任何流程控制功能(条件控制，例如if/else)但是可以使用三目 可以接受过滤器和过滤器链 {{ expression }} 当使用 {{ }} 表示法的时候，便设置了一个$watch。简而言之，这个$watch函数会监控$scope上的属性。当属性以任何方式改变时，它就会调用相应的函数。你也可以在$scope上的任意属性发生变化时用$watch函数直接执行某个自定义函数。 手动解析AngularJS表达式 AngularJS通过$parse这个内部服务来进行表达式的运算，这个服务能够访问当前所处的作用域。这个过程允许我们访问定义在$scope上的原始JavaScript数据和函数。 代码展示： {{ parsedValue }} angular.module(\"myApp\", []) .controller('MyController', function($scope,$parse) { $scope.$watch('expr', function(newVal, oldVal, scope) { console.log(scope); if (newVal !== oldVal) { // 用该表达式设置parseFun var parseFun = $parse('expr'); // 获取经过解析后表达式的值 $scope.parsedValue = parseFun(scope); } }); }); 过滤器 基础使用 {{ name | uppercase }} 也可以通过$filter来调用过滤器 app.controller('DemoController', ['$scope', '$filter', function($scope, $filter) { $scope.name = $filter('lowercase')('Ari'); }]); 过滤器增加参数 {{ 123.456789 | number:2 }} 【常用过滤器】currency:货币过滤器date:日期过滤filter：给定数组中选择一个子集，并将其生成一个新数组返回。经常在搜索中使用；同时也支持对象过滤也支持自定义函数过滤json：将一个JSON或JavaScript对象转换成字符串。这种转换对调试非常有帮助limitTo：限制数组或字符串的长度lowercase：转换为小写number：过滤器将数字格式化成文本。它的第二个参数是可选的，用来控制小数点后截取的位数orderBy：过滤器可以用表达式对指定的数组进行排序uppercase：字母转大写 【自定义过滤器】 angular.module('myApp.filters', []) .filter('capitalize', function() { return function(input) { // input是我们传入的字符串 if (input) { return input[0].toUpperCase() + input.slice(1); } } }); 表单验证（第七章） Your email novalidate：屏蔽浏览器对表单的默认验证行为 【必填项】 【最小长度】 【最大长度】 【模式匹配】匹配指定的正则表达式 【电子邮件】 【数字】 【URL】 在表单中控制变量 formName.inputFieldName.property : 访问表单字段属性 formName.inputFieldName.$pristine : 未修改的表单 formName.inputFieldName.$dirty : 修改过的表单 formName.inputFieldName.$valid : 合法的表单 formName.inputFieldName.$invalid : 不合法的表单 【错误】$error对象。它包含当前表单的所有验证内容，以及它们是否合法的信息 formName.inputfieldName.$error 表单css样式 AngularJS处理表单时，会根据表单当前的状态添加一些CSS类 .ng-pristine {} .ng-dirty {} .ng-valid {} .ng-invalid {} 【$parsers】使用$parsers数组是实现自定义验证的途径之一 angular.module('myApp') .directive('oneToTen', function() { return { require: '?ngModel', link: function(scope, ele, attrs, ngModel) { if (!ngModel) return; ngModel.$parsers.unshift( function(viewValue) { var i = parseInt(viewValue); if (i >= 0 && i 指令 第一个简单指令 HTML使用 指令代码 angular.module(\"myApp\", []) .directive('myDirective',function () { return { restrict: 'E', // 元素（E）、属性（A）、类（C）或注释（M） replace: true, // 将自定义标签从DOM中移除 template: ' Click me to go to Google' // 自定义HTML } }); 注意：指令命名应该遵循驼峰命名，HTML中可以羊肉串的写法 向指令中传递数据 angular.module(\"myApp\", []) .directive('myDirective',function () { return { restrict: 'E', // 元素（E）、属性（A）、类（C）或注释（M） replace: true, // 将自定义标签从DOM中移除 scope:{ myUrl: '@', // 绑定策略 myLinkText: '@' // 我们用属性将数据从DOM中复制到指令的隔离作用域 }, template: ' {{myLinkText}}' // 自定义HTML } }); 内置指令 【基础ng属性指令】 ng-href 创建动态的URL ng-src ng-disabled 禁用，常用在表单上面 ng-checked 是否选中 ng-readonly 是否只读 ng-selected option选中的值 ng-class ng-style 【在指令中使用子作用域】ng-app和ng-controller是特殊的指令，因为它们会修改嵌套在它们内部的指令的作用域 ng-app为AngularJS应用创建$rootScope，ng-controller则会以$rootScope或另外一个ng-controller的作用域为原型创建新的子作用域 【ng-include】使用ng-include可以加载、编译并包含外部HTML片段到当前的应用中。 要记住，使用ng-include时AngularJS会自动创建一个子作用域。如果你想使用某个特定的作用域，例如ControllerA的作用域，必须在同一个DOM元素上添加ng-controller=\"ControllerA\"指令，这样当模板加载完成后，不会像往常一样从外部作用域继承并创建一个新的子作用域 Hello {{ name }} 【ng-view】用来设置将被路由管理和放置在HTML中的视图的位置 【ng-if】使用ng-if指令可以完全根据表达式的值在DOM中生成或移除一个元素。如果赋值给ng-if的表达式的值是false，那对应的元素将会从DOM中移除，否则对应元素的一个克隆将被重新插入DOM中。 【ng-repeat】ng-repeat用来遍历一个集合或为集合中的每个元素生成一个模板实例 $index：遍历的进度（0...length-1）。 $first：当元素是遍历的第一个时值为true。 $middle：当元素处于第一个和最后元素之间时值为true。 $last：当元素是遍历的最后一个时值为true。 $even：当$index值是偶数时值为true。 $odd：当$index值是奇数时值为true。 代码示例 {{person.name}} lives in {{person.city}} .odd { background-color: blue; } .even { background-color: red; } angular.module('myApp',[]) .controller('PeopleController',function($scope) { $scope.people = [ {name: \"Ari\", city: \"San Francisco\"}, {name: \"Erik\", city: \"Seattle\"} ]; }) 【ng-init】ng-init指令用来在指令被调用时设置内部作用域的初始状态。 【ng-bind】尽管可以在视图中使用{{}}模板语法，我们也可以通过ng-bind指令实现同样的行为 【ng-cloak】除使用ng-bind来避免未渲染元素闪烁，还可以在含有{{}}的元素上使用ng-cloak指令 {{ greeting }} 【ng-bind-template】同ng-bind指令类似，ng-bind-template用来在视图中绑定多个表达式 【ng-model】ng-model指令用来将input、select、textarea或自定义表单控件同包含它们的作用域中的属性进行绑定。 【ng-show】【ng-hide】根据所给的表达式的值来显示或隐藏HTML元素。 【ng-change】这个指令会在表单输入发生变化时计算给定表达式的值。因为要处理表单输入，这个指令要和ngModel联合起来使用 {{ equation.output }} angular.module('myApp',[]) .controller('EquationController',function($scope) { $scope.equation = {}; $scope.change = function() { $scope.equation.output = parseInt($scope.equation.x) + 2; }; }); 【ng-form】用来在一个表单内部嵌套另一个表单。普通的HTML 标签不允许嵌套，但ng-form可以 这意味着内部所有的子表单都合法时，外部的表单才会合法。这对于用ng-repeat动态创建表单是非常有用的 【ng-click】用来指定一个元素被点击时调用的方法或表达式 【ng-select】 Choose City Best City: {{ city.name }} angular.module('myApp',[]) .controller('CityController',function($scope) { $scope.cities = [ {name: 'Seattle'}, {name: 'San Francisco'}, {name: 'Chicago'}, {name: 'New York'}, {name: 'Boston'} ]; }); 【ng-submit】ng-submit用来将表达式同onsubmit事件进行绑定。这个指令同时会阻止默认行为（发送请求并重新加载页面），但前提是表单不含有action属性。 【ng-class】使用ng-class 动态设置元素的类 5}\" ng-if=\"x > 5\"> You won! Draw Number Number is: {{ x }} .red { background-color: red; } angular.module('myApp',[]) .controller('LotteryController', function($scope) { $scope.generateNumber = function() { return Math.floor((Math.random()*10)+1); }; }); 自定义指令 基础框架 angular.module('myApp', []) .directive('myDirective', function ($timeout, UserDefinedService) { // 指令定义放在这里 return { // 通过设置项来定义指令 } }); myDirective ： 指令名字这个函数返回一个对象，其中定义了指令的全部行为。$compile服务利用这个方法返回的对象，在DOM调用指令时来构造指令的行为。 定义一个指令会使用到的全部设置 angular.module('myApp', []) .directive('myDirective', function() { return { restrict: String, // 元素还是属性 E（元素）A（属性，默认值）C（类名）M（注释）可以复选‘EA’ priority: Number, // 优先级（如果一个元素上具有两个优先级相同的指令，声明在前面的那个会被优先调用，如果设置了优先级的话，则优先级高的先执行） 默认值0 terminal: Boolean, // 这个参数用来告诉AngularJS停止运行当前元素上比本指令优先级低的指令。但同当前指令优先级相同的指令还是会被执行。 template: String or Template Function: 模板 function(tElement, tAttrs) (...}, templateUrl: String, // 一个代表外部HTML文件路径的字符串 replace: Boolean or String, // 将自定义标签从DOM中移除 scope: Boolean or Object, // 当scope设置为true时，会从父作用域继承并创建一个新的作用域对象。传一个{}空对象的话就会创建一个隔离作用域 transclude: Boolean, controller: String or function(scope, element, attrs, transclude, otherInjectables) { ... }, // controller参数可以是一个字符串或一个函数。当设置为字符串时，会以字符串的值为名字，来查找注册在应用中的控制器的构造函数.或者包含一个内联控制器 controllerAs: String, // 控制器别名，这个参数看起来好像没什么大用，但它给了我们可以在路由和指令中创建匿名控制器的强大能力。这种能力可以将动态的对象创建成为控制器，并且这个对象是隔离的、易于测试的。 require: String, link: function(scope, iElement, iAttrs) { ... }, // 链接函数负责将作用域和DOM进行链接。用link函数创建可以操作DOM的指令。 compile: // 返回一个对象或连接函数，如下所示： // 编译函数负责对模板DOM进行转换。 function(tElement, tAttrs, transclude) { return { pre: function(scope, iElement, iAttrs, controller) { ... }, post: function(scope, iElement, iAttrs, controller) { ... } } // 或者 return function postLink(...) { ... } } }; }); 指令绑定策略 【本地作用域属性@ (or @attr)】使用@符号将本地作用域同DOM属性的值进行绑定。指令内部作用域可以使用外部作用域的变量 【双向绑定= (or =attr)】通过=可以将本地作用域上的属性同父级作用域上的属性进行双向的数据绑定。 【父级作用域绑定& (or &attr)】通过&符号可以对父级作用域进行绑定，以便在其中运行函数。意味着对这个值进行设置时会生成一个指向父级作用域的包装函数。 scope: { ngModel: '=', // 将ngModel同指定对象绑定 onSend: '&', // 将引用传递给这个方法 fromName: '@' // 储存与fromName相关联的字符串 } 指令内部controller controller参数可以是一个字符串或一个函数。当设置为字符串时，会以字符串的值为名字，来查找注册在应用中的控制器的构造函数 angular.module('myApp', []) .directive('myDirective', function() { restrict: 'A', // 始终需要 controller: 'SomeController' }) // 应用中其他的地方，可以是同一个文件或被index.html包含的另一个文件 angular.module('myApp') .controller('SomeController', function($scope, $element, $attrs, $transclude) { // 控制器逻辑放在这里 }); 可以在指令内部通过匿名构造函数的方式来定义一个内联的控制器： angular.module('myApp',[]) .directive('myDirective', function() { restrict: 'A', controller: function($scope, $element, $attrs, $transclude) { // 控制器逻辑放在这里 } }); 我们可以将任意可以被注入的AngularJS服务传递给控制器。 【$scope】与指令元素相关联的当前作用域 【$element】当前指令对应的元素 【$attrs】由当前元素的属性组成的对象，例如下面的元素 具有如下的属性对象： { id:\"aDiv\", class:\"box\" } 【$transclude】嵌入链接函数会与对应的嵌入作用域进行预绑定。transclude链接函数式实际被执行作用来克隆元素和操纵DOM函数 angular.module('myApp') .directive('link', function() { return { restrict: 'EA', transclude: true, controller: function($scope, $element, $transclude, $log) { $transclude(function(clone) { var a = angular.element(''); a.attr('href', clone.text()); a.text(clone.text()); $log.info(\"Created new a tag in link directive\"); $element.append(a); }); } }; }); 指令的控制器和link函数可以进行互换。控制器主要是用来提供可在指令间复用的行为，但链接函数只能在当前内部指令中定义行为，且无法在指令间复用。 由于指令可以require其他指令所使用的控制器，因此控制器常被用来放置在多个指令间共享的动作 如果我们希望将当前指令的API暴露给其他指令使用，可以使用controller参数，否则可以使用link来构造当前指令元素的功能性。如果我们使用了scope.$watch()或者想要与DOM元素做实时的交互，使用链接会是更好的选择。 【require】 require参数可以被设置为字符串或数组，字符串代表另外一个指令的名字。require会将控制器注入到其值所指定的指令中，并作为当前指令的链接函数的第四个参数。 字符串或数组元素的值是会在当前指令的作用域中使用的指令名称 指令定义只会查找定义在指令当前用域中的ng-model=\"\"。 //... restrict: 'EA', require: 'ngModel' //... require参数的值可以用下面的前缀进行修饰，这会改变查找控制器时的行为： ？如果在当前指令中没有找到所需要的控制器，会将null作为传给link函数的第四个参数。 ^ 如果添加了^前缀，指令会在上游的指令链中查找require参数所指定的控制器。 ?^ 将前面两个选项的行为组合起来，我们可选择地加载需要的指令并在父指令链中进行查找。 没有前缀 如果没有前缀，指令将会在自身所提供的控制器中进行查找，如果没有找到任何控制器（或具有指定名字的指令）就抛出一个错误 【link】 // require 'SomeController', link: function(scope, element, attrs, SomeController) { // 在这里操作DOM，并且可以访问依赖指令的控制器 } 如果指令定义中有require选项，函数签名中会有第四个参数，代表控制器或者所依赖的指令的控制器。 如果require选项提供了一个指令数组，第四个参数会是一个由每个指令所对应的控制器组成的数组。 scope 指令用来在其内部注册监听器的作用域 iElement iElement参数代表实例元素，指使用此指令的元素。在postLink函数中我们应该只操作此元素的子元素，因为子元素已经被链接过了。 iAttrs iAttrs参数代表实例属性，是一个由定义在元素上的属性组成的标准化列表，可以在所有指令的链接函数间共享。会以JavaScript对象的形式进行传递。 controller controller参数指向require选项定义的控制器。如果没有设置require选项，那么controller参数的值为undefined。 【自定义验证器】 angular.module('validationExample', []) .directive('ensureUnique',function($http) { return { require: 'ngModel', link: function(scope, ele, attrs, c) { scope.$watch(attrs.ngModel, function() { $http({ method: 'POST', url: '/api/check/' + attrs.ensureUnique, data: { field': attrs.ensureUnique }).success(function(data,status,headers,cfg) { c.$setValidity('unique', data.isUnique); }).error(function(data,status,headers,cfg) { c.$setValidity('unique', false); }); }); } }; }); AngularJS模块加载 AngularJS模块可以在被加载和执行之前对其自身进行配置。我们可以在应用的加载阶段应用不同的逻辑组。 【配置】可以使用来配置路由在模块的加载阶段，AngularJS会在提供者注册和配置的过程中对模块进行配置。在整个AngularJS的工作流中，这个阶段是唯一能够在应用启动前进行修改的部分。 angular.module('myApp', []) .config(function($provide) { }); 当对模块进行配置时，需要格外注意只有少数几种类型的对象可以被注入到config()函数中：提供者和常量。如果我们将一个服务注入进去，会在真正对其进行配置之前就意外地把服务实例化了。 这种对配置服务进行严格限制的另外一个副作用就是，我们只能注入用provider()语法构建的服务，其他的则不行。 【运行块】和配置块不同，运行块在注入器创建之后被执行,它是所有AngularJS应用中第一个被执行的方法 运行块是AngularJS中与main方法最接近的概念。 运行块通常用来注册全局的事件监听器。例如，我们会在.run()块中设置路由事件的监听器以及过滤未经授权的请求。 假设我们需要在每次路由发生变化时，都执行一个函数来验证用户的权限，放置这个功能唯一合理的地方就是run方法： angular.module('myApp', ['ngRoute']) .run(function($rootScope, AuthService) { $rootScope.$on('$routeChangeStart', function(evt, next, current) { // 如果用户未登录 if (!AuthService.userLoggedIn()) { if (next.templateUrl === \"login.html\") { // 已经转向登录路由因此无需重定向 } else { $location.path('/login'); } } }); }); 依赖注入 一个对象通常有三种方式可以获得对其依赖的控制权 在内部创建依赖 通过全局变量进行引用 在需要的地方通过参数进行传递 依赖注入是通过第三种方式实现的。依赖注入是一种设计模式，它可以去除对依赖关系的硬编码，从而可以在运行时改变甚至移除依赖关系。 AngularJS使用$injetor（注入器服务）来管理依赖关系的查询和实例化。事实上，$injetor负责实例化AngularJS中所有的组件，包括应用的模块、指令和控制器等。 依赖注入简单示例：1、声明一个模块和一个控制器 angular.module('myApp', []) .factory('greeter', function() { return { greet: function(msg) {alert(msg);} } }) .controller('MyController', function($scope, greeter) { $scope.sayHello = function() { greeter.greet(\"Hello!\"); }; }); 2、当AngularJS实例化这个模块时，会查找greeter并自然而然地把对它的引用传递进去 Hello 3、内部的实现流程 // 使用注入器加载应用 var injector = angular.injector(['ng', 'myApp']); // 通过注入器加载$controller服务：var $controller = injector.get('$controller'); var scope = injector.get('$rootScope').$new(); // 加载控制器并传入一个作用域，同AngularJS在运行时做的一样 var MyController = $controller('MyController', {$scope: scope}) 上面的代码中并没有说明是如何找到greeter的，但是它的确能正常工作，因为$injector会负责为我们查找并加载它。 【显式注入声明】 var aControllerFactory = function aController($scope, greeter) { console.log(\"LOADED controller\", greeter); // ... 控制器 }; aControllerFactory.$inject = ['$scope', 'greeter']; // Greeter服务 var greeterService = function () { console.log(\"greeter service\"); } // 我们应用的控制器 angular.module('myApp', []) .controller('MyController', aControllerFactory) .factory('greeter', greeterService); // 获取注入器并创建一个新的作用域 var injector = angular.injector(['ng', 'myApp']), controller = injector.get('$controller'), rootScope = injector.get('$rootScope'), newScope = rootScope.$new(); // 调用控制器 controller('MyController', {$scope: newScope}); 【行内注入声明】 angular.module('myApp') .controller('MyController', ['$scope', 'greeter', function($scope, greeter) { }]); 服务 服务提供了一种能在应用的整个生命周期内保持数据的方法，它能够在控制器之间进行通信，并且能保证数据的一致性。 服务是一个单例对象，在每个应用中只会被实例化一次(被$injector实例化)并且是延迟加载的(需要时才会被创建) 以AngularJS的$http服务为例，它提供了对浏览器的XMLHttpRequest对象的底层访问功能，我们可以通过$http的API同XMLHttpRequest进行交互，而不需要因为调用这些底层代码而污染应用 // 示例服务，在应用的整个生命周期内保存current_user angular.module('myApp', []) .factory('UserService', function($http) { var current_user; return { getCurrentUser: function() { return current_user; }, setCurrentUser: function(user) { current_user = user; } }; }); 【注册一个服务】 使用angular.module的factory API创建服务，是最常见也是最灵活的方式： angular.module('myApp.services', []) .factory('githubService', function() { var serviceInstance = {}; // 我们的第一个服务，返回serviceInstance; }); 编写第一个服务应用 angular.module('myApp.services', []) .factory('githubService', function($http) { var githubUrl = 'https://api.github.com'; var runUserRequest = function(username, path) { // 从使用JSONP调用 Github API的$http服务中返回promise return $http({ method: 'JSONP', url: githubUrl + '/users/' + username + '/' + path + '?callback=JSON_CALLBACK' }); }; // 返回一个events函数的服务对象 return { events: function(username) { return runUserRequest(username, 'events'); } }; }); 在应用中使用服务 angular.module('myApp', ['myApp.services']) .controller('ServiceController', function($scope, githubService) { // 可以在对象上调用events函数 $scope.events = githubService.events('auser'); }); 【创建服务的设置项】在AngularJS应用中，factory()方法是用来注册服务的最常规方式，同时还有其他一些API可以在特定情况下帮助我们减少代码量。 共有5种方法用来创建服务： factory() service() constant() value() provider() 【service】使用service()可以注册一个支持构造函数的服务，它允许我们为服务对象注册一个构造函数。 service()方法接受两个参数。 name（字符串）要注册的服务名称。 constructor（函数） var Person = function($http) { this.getName = function() { return $http({ method: 'GET', url: '/api/user'}); }; }; angular.service('personService', Person); 【constant】可以将一个已经存在的变量值注册为服务，并将其注入到应用的其他部分当中。例如，假设我们需要给后端服务一个apiKey，可以用constant()将其当作常量保存下来。 angular.module('myApp') .constant('apiKey','123123123') angular.module('myApp') .controller('MyController', function($scope, apiKey) { // 可以像上面一样用apiKey作为常量 //用123123123作为字符串的值 $scope.apiKey = apiKey; }); 【value】如果服务的$get方法返回的是一个常量，那就没要必要定义一个包含复杂功能的完整服务，可以通过value()函数方便地注册服务。 angular.module('myApp') .value('apiKey','123123123'); 【value()和constant()该用谁】value()方法和constant()方法之间最主要的区别是，常量可以注入到配置函数中，而值不行。 angular.module('myApp', []) .constant('apiKey', '123123123') .config(function(apiKey) { // 在这里apiKey将被赋值为123123123 //就像上面设置的那样 }) .value('FBid','231231231') .config(function(FBid) { // 这将抛出一个错误，未知的provider: FBid // 因为在config函数内部无法访问这个值 }); 【decorator】$provide服务提供了在服务实例创建时对其进行拦截的功能，可以对服务进行扩展，或者用另外的内容完全代替它。 装饰器是非常强大的，它不仅可以应用在我们自己的服务上，也可以对AngularJS的核心服务进行拦截、中断甚至替换功能的操作。事实上AngularJS中很多功能的测试就是借助$provide.decorator()建立的。 例如，我们想给之前定义的githubService服务加入日志功能，可以借助decorator()函数方便地实现这个功能，而不需要对原始的服务进行修改。 var githubDecorator = function($delegate,$log) { var events = function(path) { var startedAt = new Date(); var events = $delegate.events(path); // 事件是一个promise events.finally(function() { $log.info(\"Fetching events\" + \" took \" + (new Date() - startedAt) + \"ms\"); }); return events; }; return { events: events }; }; angular.module('myApp') .config(function($provide) { $provide.decorator('githubService',githubDecorator); //对服务进行拦截 }); 事件 Angular应用也可以响应Angular事件。这使我们可以在应用中嵌套的各组件之间进行通信，即使这些组件在创建时并未考虑到其他组件。 注意，Angular事件系统并不与浏览器的事件系统相通，这意味着，我们只能在作用域上监听Angular事件而不是DOM事件。 【事件传播】 因为作用域是有层次的，所以我们可以在作用域链上传递事件。 使用$emit来冒泡事件 // 发送一个事件 //我们的用户以当前user登录了 scope.$emit('user:logged_in', scope.user); 使用$broadcast向下传递事件 // 等等，购物车去结账了 // 当购物车在结账的时候 // 下面所有的指令都应当禁用自己 scope.$broadcast('cart:checking_out', scope.cart); 在$broadcast()方法上，每个注册了监听器的子作用域都会收到这个信息。事件传播到所有的指令和当前作用域的间接作用域上，并且一路往下调用每个监听器。 事件的监听 要监听一个事件，我们可以使用$on()方法。这个方法为具有某个特定名称的事件注册了一个监听器。事件名称就是在Angular中触发的事件类型。 scope.$on('$routeChangeStart', function(evt, next, current) { // 一个新的路由被触发了 }); 完整代码实例： Father: {{name}}! Son: {{name}} var app = angular.module ('myApp', []); app.controller('fatherCtrl', function ($scope) { $scope.name = \"father\"; $scope.$on ('test', function(e, newName) { $scope.name = newName; }); }); app.controller('sonCtrl', function ($scope) { $scope.name = \"son\"; $scope.nameOnChange = function () { $scope.$emit ('test', $scope.name); } }); var app = angular.module ('myApp', []); app.controller('fatherCtrl', function ($scope) { $scope.name = \"father\"; $scope.nameOnChange = function () { $scope.$broadcast ('test', $scope.name); } }); app.controller('sonCtrl', function ($scope) { $scope.name = \"son\"; $scope.$on ('test', function(e, newName) { $scope.name = newName; }); $scope.nameOnChange = function () { // $scope.$emit ('test', $scope.name); } }); Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:47:38 "},"vue.html":{"url":"vue.html","title":"vue","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:23:14 "},"uiRouter.html":{"url":"uiRouter.html","title":"ui-router","keywords":"","body":"UI-ROUTER 英文官网 规划 1、angular项目中使用ui-router初始化项目 知道如何使用 2、ui-router features介绍https://ui-router.github.io/about/features 学习一些路由的基本概念 3、ui-router guide https://ui-router.github.io/guide/ 对每个概念进行详细解释，最后列举一些实际案例结合着写，这样会更加清晰 4、核心api讲解 5、如果能写一个实际案例带到这些知识点就OK Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-08 11:06:27 "},"UI-Router基础.html":{"url":"UI-Router基础.html","title":"Angular2+ 项目中安装并初始化 UI-Router","keywords":"","body":"前言 本系列主要讲解UI-Router在angular2+中的应用，今天主讲在angular中初始化一个UI-Router并且建立一些简单的路由。 完整代码 初始化Angular项目 1、安装angular/cli npm install -g angular/cli 安装好后：ng --version 2、利用脚手架生成一个项目 ng new task 初始化项目成功后 执行：npm start 或者 ng serve @uirouter/angular 安装 npm install --save @uirouter/angular 或者： yarn add @uirouter/angular 创建两个组件hello 和 about执行命令： ng g c hello & ng g c about 创建router创建如下文件以及文件夹：/src/app/router/index.ts import { HelloComponent } from \"../hello/hello.component\"; import { AboutComponent } from \"../about/about.component\"; // 以下是两个最简单的路由对象 const helloState = { name: 'hello', url: '/hello', component: HelloComponent }; const aboutState = { name: 'about', url: '/about', component: AboutComponent }; //导出路由数组 export const allStates = [ helloState, aboutState ]; app.module.ts中添加路由module以及创建好的路由path:/src/app/app.module.ts import { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; import {UIRouterModule} from \"@uirouter/angular\";// 引入路由module import { allStates } from \"./router\"; import { HelloComponent } from './hello/hello.component'; import { AboutComponent } from './about/about.component'; @NgModule({ declarations: [ AppComponent, HelloComponent, AboutComponent ], imports: [ BrowserModule, UIRouterModule.forRoot({ states: allStates, useHash: true }) // 引入 ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } 编写入口界面/src/app/app.component.html Hello About // 路由视口 /src/app/app.component.css .active { color: red; font-weight: bold; } // 当路由处于激活状态的样式 a{margin:20px;} 效果 代码都编写完成了，现在来看下效果： 小结 以上就简单的简介了如何在一个angular2+项目中配合ui-router来使用。接下会更加深入的讲解ui-router的一些新特性。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-12 09:54:09 "},"UI-RouterFeatures.html":{"url":"UI-RouterFeatures.html","title":"UI-Router Features","keywords":"","body":"前言 上一节我们在angular2+项目中初步的使用了ui-router，也算是会用了吧，今天这节主要来理解下ui-router的几个重要概念 States ui-router提供的路由其实就是一个一个States状态对象组成的。ui-router管理这些状态之间的切换以及生命周期 每个状态等于一个URL，在进入URL之前，UI-Router首先获取任何先决条件例如：身份验证，所需数据(异步)，然后激活视图并更新URL。 State对象 const helloState = { name: 'hello', // 状态的名称，可以直接使用状态名字找到该状态，相当于状态的id url: '/hello', // 浏览器访问的url component: HelloComponent, // 展示的组件 params:{}, // 参数对象 resolve:[] // 状态所需的实际数据(通常使用参数值从后端异步获取) }; 嵌套状态 与传统状态机中的状态不同，UI-Router状态可以嵌套在彼此内部。一个父状态可以有多个子状态，形成一个状态树。 [注意]子状态的视图通常在父状态创建的视图端口中呈现。这称为嵌套视图 Views 状态使用视图，视图是一个UI组件，当状态被激活时，它被放置到一个viewport ()中。 视图可以嵌套在其他视图中。父状态的视图可以创建一个viewport ()，而嵌套状态可以在激活时用自己的视图填充该viewport。 上篇文章中，有一段代码： Hello About 当点击哪个路由，该路由对应的组件则映射到中，我们在界面就可以看到该组件了。 添加一个嵌套路由 代码都是接着上篇文章的代码 路由文件定义: const parentState = { name: 'folderlist', url: '/folder', component: FolderListComponent }; const childState = { name: 'folderlist.messagelist', url: '/message', component: MessageListComponent }; const childTwoState = { name: 'folderlist.foolist', url: '/foo', component: FooListComponent }; FolderListComponent定义 messagelist foolist 这样两个子路由就会去它的父路由组件中取查找； 完整代码 Urls state中定义的URL实际上只是一个URL片段。每个状态只定义它自己的那部分。如果是嵌套路由时，会先读取父路由拼接在一起的。 上面代码中如果想访问childTwoState这个状态，实际上访问的路由地址是：/folder/foo Parameters 在一个状态中，或者说一个具体的URL中我们经常是需要使用参数的。 基本写法： const childTwoState = { url: '/foo/{fooId}', 第一种写法 url: '/foo?fooId' 第二种写法 }; 但是这样写也是不够的，我们还需要对参数项做一些配置 const childTwoState = { name: 'folderlist.foolist', url: '/foo?fooId', component: FooListComponent, params: { fooId: { type: 'string', value: \"aabbcc\", // type类型: string、int、bool、Date、json。value: 设置默认值squash: true/false,压缩模式:省略URL中的默认参数值 参数的配置项是非常重要的，后续会详细讲解的。 Resolve Data 简单的理解：当路由进入一个组件时，通过resolve可以实现准备好这个路由所需的数据； 当一个resolve请求的后台接口报错例如：401，404，500等错误时，将调用错误的钩子拒绝进入该路由组件； 当然一个组件可以同时注入多个resolve的； 解析resolve的过程是异步的。如果一个resolve返回一个Promise，则将暂停转换，直到该Promise得到解决。因此，resolve数据参与转换生命周期。 [重点]resolve系统实际上是一个异步的、分层的依赖注入系统。 var state = { name: 'user', url: '/user/:userId resolve: [ { token: 'user', policy: { when: 'EAGER' }, // deps: ['UserService', Transition], resolveFn: (userSvc, trans) => userSvc.fetchUser(trans.params().userId) }, } ] } 代码解析：token: 注入到组件数据的名字，在组件中可以通过 @Input() user的方式注入该resolvepolicy: 定义何时获取到 resolve 数据，EAGER(进入到组件前) 获取 LAZY(进入到组件后)deps: 该resolve依赖的服务resolveFn: resolve函数主体，通过它来获取后台返回的请求数据 Transitions 路由切换：一个状态(URL)切换到另外一个状态(URL) 声明周期： - before：跳转开始之前 - start：跳转开始 - exit：退出状态 - retain：状态被保留(状态是活动的，既不退出也不进入) - enter：进入状态 - finish：完成 - success/error：跳转完成后的状态 Transition 生命周期挂钩： - 钩子可以在转换生命周期的任何阶段注册 - 钩子可以改变转换 小结 通过简单了解关于ui-router的一些基本概念，我们能明白，一个url就是一个state状态对象，一个state状态对象包含：视图、url、参数、resolve等属性。当状态之间跳转的时候，又要经历一些生命周期以及触发一些钩子。在接下来的文章我会对每一个部分进行详细讲解和学习，并应用到实战项目中，加深对ui-router的理解。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-15 23:03:54 "},"State对象.html":{"url":"State对象.html","title":"UI-Router State对象","keywords":"","body":"前言 回顾上一节的内容，我们大致学习了ui-router有几个核心概念：State、Urls、Parameters、Resolve、Transitions。今天这篇文章主要讲解下State对象 State对象 ui-router提供的路由其实就是一个一个States状态对象组成的。ui-router管理这些状态之间的切换以及生命周期 每个状态等于一个URL，在进入URL之前，UI-Router首先获取任何先决条件例如：身份验证，所需数据(异步)，然后激活视图并更新URL。 一个基础的state对象 const helloState = { name: 'hello', url: '/hello', component: HelloComponent, params:{}, resolve:[] }; name 【普通访问】这个state的名字，我们在组件中可以通过state的name属性访问到该路由 Hello 【嵌套访问】 路由在正常的项目中一般都是多级嵌套的一个树形结构的。那么我们如何定义和访问一个嵌套路由呢？ 定义一个嵌套路由 const parentState = { name: 'folderlist', url: '/folder', component: FolderListComponent }; const childState = { name: 'folderlist.messagelist', url: '/message', component: MessageListComponent }; 访问的话还是如上所诉，直接访问路由的name即可， url 在嵌套路由的访问中应该是要把父级路由拼接起来的，例如访问childState这路由的访问地址就是http://localhost:4200/#/folder/message 常见url的形式 url: \"/home\" url: \"/users/:userid\" url: \"/books/{bookid:[a-zA-Z_-]}\" url: \"/books/{categoryid:int}\" url: \"/books/{publishername:string}/{categoryid:int}\" url: \"/messages?before&after\" url: \"/messages?{before:date}&{after:date}\" url: \"/messages/:mailboxid?{before:date}&{after:date}\" params 路由访问所需的参数 const aboutState = { name: 'about', url: '/about?id', component: AboutComponent, onEnter: function(trans, state) { console.log(\"Entering \" , state , trans); }, onExit: function(trans, state) { console.log(\"Leaving \" + state.name); }, onRetain: function(trans, state) { console.log(state.name + \" is still active!\"); }, params: { id: { value: 'aabcc123' // 设置默认的参数值 } } }; 由于参数设置选项比较多，我们将在下一篇文章中详细讲解下params对象 resolve resolve获取到的Data数据，可以用于当前视图 或 transition hooks，或用于该state对象其它的resolve。或者用于该state嵌套的state对象里面resolve。 因为resolve函数可以返回一个promise，所以路由器会延迟进入状态，直到promise就绪。如果任何一个承诺被拒绝，转换就会因为一个错误而中止。 【ResolvableLiteral】 一个resolve必须是一个ResolvableLiteral对象 export interface ResolvableLiteral { token: any; // 依赖注入的token resolveFn: Function; // 解析系统将在调用此函数之前异步获取依赖项 policy?: ResolvePolicy; // policy定义何时调用解析，以及是否等待async并打开数据 deps?: any[]; // 依赖项数组 data?: any; // 预处理数据 } 【普通使用】 新建一个 getListResolve.ts 文件 import { ResolvableLiteral, Transition } from \"@uirouter/core\"; export async function resolveFn( trans: Transition, ) { return [ { id: \"123\", name: \"jack\" }, { id: \"234\", name: \"joke\" } ] } export const getListResolver: ResolvableLiteral = { token: \"listData\", deps: [Transition], resolveFn }; 在路由中引入： const childState = { name: 'messagelist', parent:'folderlist', url: '/message', component: MessageListComponent, resolve:[getListResolver] }; 然后到MessageListComponent组件中添加DI token import { Component, OnInit, Input } from '@angular/core'; @Component({ selector: 'message-list', templateUrl: './message-list.component.html', styleUrls: ['./message-list.component.css'] }) export class MessageListComponent implements OnInit { @Input() listData; // 这样就把数据注入进来了 constructor() { } ngOnInit() { console.log(this.listData); } } 【用于其它resolve】新建一个resolve: getMessageResolver import { ResolvableLiteral, Transition } from \"@uirouter/core\"; export async function resolveFn( trans: Transition, listData ) { return listData.push({ id: \"456\", name: \"tom\" }) } export const getMessageResolver: ResolvableLiteral = { token: \"messageData\", deps: [Transition,\"listData\"], resolveFn }; 看下state中是如何使用的 const childState = { name: 'messagelist', parent:'folderlist', url: '/message', component: MessageListComponent, resolve:[getListResolver,getMessageResolver] }; 现在可以看到getMessageResolver中的deps依赖中是可以直接使用getListResolver中的token直接注入的。 【用于嵌套state中的resolve】 父路由： const parentState = { name: 'folderlist', url: '/folder', component: FolderListComponent, resolve:[getListResolver] }; 子路由： const childState = { name: 'messagelist', parent:'folderlist', url: '/message', component: MessageListComponent, resolve:[getMessageResolver] }; getMessageResolver import { ResolvableLiteral, Transition } from \"@uirouter/core\"; export async function resolveFn( trans: Transition, listData ) { return listData.pop(); } export const getMessageResolver: ResolvableLiteral = { token: \"messageData\", deps: [Transition,\"listData\"], resolveFn }; getMessageResolver中依赖可以直接使用getListResolver中返回的数据，这就是嵌套state中resolve的使用方法。 Abstract 抽象状态永远不能被直接激活。使用抽象状态向子状态提供继承属性(url、解析、数据等)。 const parentState = { name: 'folderlist', url: '/folder', abstract: true, component: FolderListComponent }; 这样我们直接访问：http://localhost:4200/#/folder是会报错的，上面说了：抽象状态永远不能被直接激活。但是我们可以直接访问它的子路由，并且子路由会继承父路由的相关数据的。 parent 父路由 const parentState = { name: 'folderlist', url: '/folder', component: FolderListComponent }; 子路由 const childState = { name: 'folderlist.messagelist', url: '/message', component: MessageListComponent }; 那么我们如果要调整到这个子路由时，就必须要这样写： messagelist parent属性给我们带来另外一种方式： const childState = { name: 'messagelist', parent:'folderlist', url: '/message', component: MessageListComponent }; 现在可以这样访问： messagelist redirectTo 如果定义了此属性，将根据属性的值重定向 const parentState = { name: 'folderlist', url: '/folder', component: FolderListComponent, redirectTo: 'folderlist.foolist' }; 这样写的话，当我们访问folderlist路由时，会直接定向到folderlist.foolist如果redirectTo: 'folderlist.foolist'是一个不存在的值，则该路由会不起作用 redirectTo的常用方法： // 跳转到'A.B'路由 .state('A', { redirectTo: 'A.B' }) // 跳转到'C.D'路由，并且带上参数 .state('C', { redirectTo: { state: 'C.D', params: { foo: 'index' } } }) // 跳转到路由\"A\" .state('E', { redirectTo: () => \"A\" }) // 根据参数判断要跳转的路由 .state('F', { redirectTo: (trans) => { if (trans.params().foo { let svc = trans.injector().get('SomeAsyncService') let promise = svc.getAsyncRedirectTo(trans.params.foo); return promise; } }) // 根据resolve Data 来判断是跳转到登录还是其它界面 .state('G', { redirectTo: (trans) => { // getAsync tells the resolve to load let resolvePromise = trans.injector().getAsync('SomeResolve') return resolvePromise.then(resolveData => resolveData === 'login' ? 'login' : null); } }) hook 【onEnter】 当进入某个路由的时候触发的钩子函数 const aboutState = { name: 'about', url: '/about', component: AboutComponent, onEnter: function(trans, state) { console.log(\"Entering \" + state.name); } }; 当进入about路由时，会触发onEnter函数 【onExit】 当离开一个路由时触发 const aboutState = { name: 'about', url: '/about', component: AboutComponent, onEnter: function(trans, state) { console.log(\"Entering \" , state , trans); }, onExit: function(trans, state) { console.log(\"Leaving \" + state.name); } }; Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-18 15:31:34 "},"uirouter-params.html":{"url":"uirouter-params.html","title":"UI-Router params参数详解","keywords":"","body":"前言 之前已经详细的介绍过了State对象了，但是其中有params对象配置颇为复杂，本文将详细介绍params的配置 一个普通state var mystate = { template: '', controller: function() {} url: '/mystate?start', params: { start: { type: 'date', value: new Date(), squash: true, } } } 我们可以看到，不仅在url上面要配置好参数,而且还必须要在params对象中对声明好的参数做进一步的配置。 params 对象的属性值 【type】 参数的类型 常用的类型值有： 1. string // 字符型 2. int // 数值型 3. bool // 布尔型 4. date // new Date(2000, 0, 1) 5. json // json格式 6. any // 任意类型 【value】 设置参数的默认值 【squash】 为true当参数值等于默认值时会省略掉该参数 params: { myparam: 'defaultParamValue' squash: true } 【dynamic】 dynamic = true 时，对参数值的更改不会触发state的entered，exited钩子。resolves不会被重新获取，视图也不会被重新加载 默认值：false params: { myparam: 'defaultParamValue' squash: true, dynamic: false } 【raw】 当raw为true时禁用参数值的url编码 默认值：false params: { taskId: { dynamic: false, raw: true, value: \"\", squash: true } } 小结 以上就是params是的一些常用配置。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 15:13:23 "},"uirouter-directives.html":{"url":"uirouter-directives.html","title":"UI-Router 常用指令","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-21 16:20:06 "},"UI-Router实例.html":{"url":"UI-Router实例.html","title":"UI-Router 搭建一个简单的后台管理","keywords":"","body":"前言 通过前面对ui-router的基础知识学习，本文使用and-design实战后台管理系统。串联起前面学习的知识来。 代码托管地址 初始化一个angular 6+ 项目 安装angular/cli npm install -g angular/cli 安装好后：ng --version 创建一个angular项目 ng new taskmgr --style less // 样式默认使用less 初始化ant design for angular ng add ng-zorro-antd 添加相应组件 app/pages/index ng g c pages/index 该组件主要用来搭建界面框架 app/pages/manage ng g c pages/manage 具体内容界面，展示与index界面里面的ui-view Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-19 11:37:55 "},"状态管理.html":{"url":"状态管理.html","title":"状态管理","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:23:38 "},"visualDOM.html":{"url":"visualDOM.html","title":"visual DOM","keywords":"","body":"学习资料 你不知道的Virtual DOM 系列 深度剖析：如何实现一个 Virtual DOM 算法 如何理解虚拟DOM? Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 21:32:56 "},"JavaScript实现一个简单的MVVM前端框架ES6语法.html":{"url":"JavaScript实现一个简单的MVVM前端框架ES6语法.html","title":"JavaScript 实现一个简单的MVVM前端框架(ES6语法)","keywords":"","body":"前言 随着前端各大框架的崛起，为我们平时的开发带来了相当的便利，我们不能一直停留在应用层面，今天就自己动手实现一个乞丐版的MVVM小框架 完整代码github地址 效果 html代码 {{a}} {{b.b}} js调用代码 const vm = new Mvvm({ el: '#app', data: { a: 1, b: { b : 2 } } }) 基本是模仿vue的调用方式 实现步骤 数据劫持Observe 数据代理(让Mvvm对象可以处理数据) 模板编译Compile 发布订阅 视图与数据进行关联 实现双向数据绑定 代码分析 // 定义框架类名Mvvm,我们则可以直接实例化new Mvvm() 来调用 class Mvvm { constructor(options){ /** * options 则是前台传来的数据 * { el: '#app', data: { a: 1, b: { b : 2 } } } */ const {el,data} = options; this._data = data; Observe.observeData(data); // 通过该函数把所有前台传来的data中的数据劫持 this.mount(data); // 把所有的data数据代理到this，也就是Mvvm对象上 Mvvm.compile(el,this); // 解析模板数据，也就是解析HTML中的{{a}} {{b.b}} } // 把data中的数据挂载到this上 mount(data){ // 遍历data数据 通过defineProperty进行重新创建属性到this上 for(let key in data){ Object.defineProperty(this,key,{ enumerable:true, // 可枚举 get(){ return this._data[key]; }, set(newVal){ this._data[key] = newVal; } }) } } // 解析模板功能 static compile(el,_that){ new Compile(el,_that); } } // 对数据进行劫持 class Observe{ constructor(data){ this.deepObserve(data); } deepObserve(data){ let dep = new Dep(); // 创建一个可观察对象 for(let key in data){ let value = data[key]; Observe.observeData(value); // 递归调用数据劫持方法 this.mount(data,key,value,dep); // 数据劫持主体方法 } } mount(data,key,value,dep){ // 其实就是把data中的数据一层层递归的通过defineProperty方式创建 Object.defineProperty(data,key,{ enumerable:true, get(){ Dep.target && dep.addSub(Dep.target); //Dep.target = watcher 这个存在的时候，添加到可观察对象数组中 return value; // get返回该值 }, set(newVal){ // 当设置值时，新值老值进行比对 if(newVal === value){ return; } value = newVal; Observe.observeData(newVal);// 把后来手动设置的值也劫持了 dep.notify(); // 发布所有的订阅来更新界面数据 } }) } static observeData(data){ // 递归的终止条件，这里写的并不完善!! 我们主要目的还是理解mvvm if(typeof data !== 'object'){ return ; } return new Observe(data); } } class Compile{ constructor(el,vm){ // vm = this vm.$el = document.querySelector(el); // 创建一个文档片段 let fragment = document.createDocumentFragment(); let child; while(child = vm.$el.firstChild){ // 不断遍历DOM，添加到文档片段(内存)中 fragment.appendChild(child); } // replace是解析HTML的核心函数 this.replace(fragment,this,vm); // 把更新后的文档片段插入回DOM，达到更新视图的目的 vm.$el.appendChild(fragment); } // 解析DOM replace(fragment,that,vm){ // 循环文档片段中的DOM节点 Array.from(fragment.childNodes).forEach(function (node) { let text = node.textContent; // 节点值 let reg = /\\{\\{(.*)\\}\\}/; // 正则匹配{{}}里面的值 // nodeType === 3 表示文本节点 if(node.nodeType === 3 && reg.test(text)){ let arr = RegExp.$1.split('.'); // RegExp.$1获取到 b.b , 并通过.转换成数组 let val = vm; // val 指针指向 vm对象地址 arr.forEach(function (k) { val = val[k]; // vm['b'] 可以一层层取到值 }); // 给这个node创建一个watcher对象，用于后期视图动态更新使用 new Watcher(vm,RegExp.$1,function (newVal) { node.textContent = text.replace(reg,newVal); }); // 更新视图 {{a}} ==> 1 node.textContent = text.replace(reg,val); } // 元素节点 if(node.nodeType === 1){ let nodeAttrs = node.attributes; // 获取DOM节点上的属性列表 // 遍历该属性列表 Array.from(nodeAttrs).forEach((attr)=>{ let name = attr.name; // 获取属性名 v-model let exp = attr.value; // 获取属性值 \"a\" if(name.startsWith('v-')){ node.value = vm[exp]; // 实现了把a的值添加到input输入框内 } // 给该node创建一个watcher对象，用于动态更新视图 new Watcher(vm,exp,function (newVal) { node.value = newVal; // 更新输入框的值 }); // 输入框添加事件 node.addEventListener('input',function (e) { // 会调用数据劫持中的set方法，从而触发 dep.notify()发布所有的订阅来更新界面数据 vm[exp] = e.target.value; },false); }) } // 递归解析DOM节点 if(node.childNodes){ that.replace(node,that,vm); } }); } } // 简单的发布订阅 class Dep{ constructor(){ this.subs = []; } addSub(sub){ this.subs.push(sub); } notify(){ this.subs.forEach(sub=>{ sub.update(); }) } } // Watcher对象，用来跟node的关联起来。把后期需要更新的node变成Watcher对象，存入内存中 class Watcher{ constructor(vm,exp,fn){ this.vm = vm; // this对象 this.exp = exp; // 值 this.fn = fn; // 回调函数 Dep.target = this; // 发布订阅对象Dep，添加一个属性target = this 也是当前watcher let val = vm; let arr = exp.split('.'); arr.forEach(function (k) { val = val[k]; // 这个步骤会循环的调用改对象的get，所以就会把该watcher添加到观察数组中 }); Dep.target = null; } // 给每个watcher都加一个update方法，用来发布 update(){ // 通过最新 this对象，去取到最新的值，触发watcher的回调函数，来更新node节点中的数据，以达到更新视图的目的 let val = this.vm; let arr = this.exp.split('.'); arr.forEach(function (k) { val = val[k]; }); this.fn(val); // 这个传入的val就是最新计算出来的值 } } 小结 代码已经全部写了详细的注释，但是可能还是会有难以理解的地方，这个时候多动手练练，使用下可能会让你更加熟悉MVVM原理 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 08:03:16 "},"webComponent.html":{"url":"webComponent.html","title":"webComponent","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:38:29 "},"单元测试.html":{"url":"单元测试.html","title":"单元测试","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:38:41 "},"前端构建.html":{"url":"前端构建.html","title":"前端构建","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:38:54 "},"gulp.html":{"url":"gulp.html","title":"gulp","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:24:01 "},"webpack.html":{"url":"webpack.html","title":"webpack","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:24:11 "},"webpack入门学习.html":{"url":"webpack入门学习.html","title":"webpack入门学习","keywords":"","body":"前言 前端构建工具经历了很多了，npm scripts -> grunt -> gulp -> Fis3 -> webpack -> rollup.js , 但是所有构建工具都是为了解决我们实际项目中的静态资源打包的问题，各有优缺点。今天我们主要是介绍webpack的使用方式。 什么是webpack 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(static module bundler)。在 webpack 处理应用程序时，它会在内部创建一个依赖图(dependency graph)，用于映射到项目需要的每个模块，然后将所有这些依赖生成到一个或多个bundle。 webpack的优点 专注于处理模块化的项目，能做到开箱即用、一步到位； 可通过 Plugin 扩展，完整好用又不失灵活性； 使用场景不局限于Web开发； 社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展； 良好的开发体验； webpack的缺点 只能用于采用模块化开发的项目。 核心概念 【入口(entry)】 入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始，webpack 会找出有哪些模块和 library 是入口起点（直接和间接）依赖的。 默认值： module.exports = { entry : './src/index.js' } 当然也可以多入口配置，在后面的实战中会一一讲到。 【输出(output)】 output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，主输出文件默认为 ./dist/main.js，其他生成文件的默认输出目录是 ./dist。 简单配置output const path = require('path'); module.exports = { entry : './src/index.js' output:{ path : path.resolve(__dirname,'dist'), // 输入文件的路径。path.resolve(__dirname,'') 这个是node语法 找到当前跟目录 filename: 'my-first-webpack.bundle.js' // 输出文件的名字，具体有很多用法。实战中会讲到 } } 【loader】 作为开箱即用的自带特性，webpack 自身只支持 JavaScript。而 loader 能够让 webpack 处理那些非 JavaScript 文件，并且先将它们转换为有效 模块，然后添加到依赖图中，这样就可以提供给应用程序使用。 loader代码展示 const path = require('path'); module.exports = { entry : './src/index.js' output:{ path : path.resolve(__dirname,'dist'), filename: 'my-first-webpack.bundle.js' }, module: { rules : [ { test : /\\.txt$/, // 通过正则去匹配相应的文件 use : 'raw-loader' // 使用哪个loader来处理匹配的文件 } ] } } 【plugins】 loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务，插件的范围包括：打包优化、资源管理和注入环境变量。 插件代码简单展示 const path = require('path'); module.exports = { entry : './src/index.js' output:{ path : path.resolve(__dirname,'dist'), filename: 'my-first-webpack.bundle.js' }, module: { rules : [ { test : /\\.txt$/, // 通过正则去匹配相应的文件 use : 'raw-loader' // 使用哪个loader来处理匹配的文件 } ] }, plugins:[ new HtmlWebpackPlugin({ template: './src/index.html' }) ] } 在上面的示例中，html-webpack-plugin 会为你的应用程序生成一个 html 文件，然后自动注入所有生成的 bundle。 webpack 4.x之前的核心概念就以上几个点，后续在实战内容中会补充一些其他概念和实战用法 小结 webpack入门的核心的四个概念：entry 入口文件的配置， output 输出文件的配置，loader打包css,ES6,typeScript等变为浏览器可识别的模块。plugins则是在整体打包过程中解决loader无法实现的其他事，例如压缩文件之类的。 参考文献 官方文档 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 08:04:19 "},"rollup.html":{"url":"rollup.html","title":"rollup","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:24:23 "},"前端安全.html":{"url":"前端安全.html","title":"前端安全","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:39:07 "},"性能优化.html":{"url":"性能优化.html","title":"性能优化","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:39:19 "},"前端监控.html":{"url":"前端监控.html","title":"前端监控","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:39:31 "},"计算机图形.html":{"url":"计算机图形.html","title":"计算机图形","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:39:46 "},"canvas.html":{"url":"canvas.html","title":"canvas","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-03 14:24:47 "},"svg.html":{"url":"svg.html","title":"svg","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:40:05 "},"SVG基本形状及样式设置.html":{"url":"SVG基本形状及样式设置.html","title":"svg 基本形状及样式设置","keywords":"","body":"前言 图形分为位图和矢量图。 位图是基于颜色的描述，是由像素点组成的图像； 而矢量图是基于数学矢量的描述，是由几何图元组成的图像，与分辨率无关。 可缩放矢量图形，即SVG，是W3C XML的分支语言之一，用于标记可缩放的矢量图形。本文将详细介绍SVG基本形状及样式设置 概述 SVG是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形，可以通过定义必要的线和形状来创建一个图形，也可以修改已有的位图，或者将这两种方式结合起来创建图形 [注意]IE8-浏览器不兼容 SVG提供了一些元素，用于定义圆形、矩形、简单或复杂的曲线，以及其他形状。一个简单的SVG文档由根元素和基本的形状元素构成。另外还有一个g元素，它用来把若干个基本形状编成一个组 从这些开始，SVG可以成为任何复杂的组合图形。SVG支持渐变、旋转、滤镜效果、JavaScript接口等等功能，但是所有这些额外的语言特性，都需要在一个定义好的图形区域内实现 【入门】 下面直接从一个简单的例子开始介绍 SVG 上面实例的绘制流程包括以下几步 　　1、从svg根元素开始 　　2、绘制一个完全覆盖图像区域的矩形 ，把背景颜色设为红色 　　3、一个半径80px的绿色圆圈绘制在红色矩形的正中央 （向右偏移150px，向下偏移100px） 　　4、绘制文字“SVG”。文字被填充为白色， 通过设置居中的锚点把文字定位到期望的位置 引入 SVG包括以下几种使用方式：1、使用img、frame、object、embed标签引用，或使用CSS背景图片 2、浏览器直接打开SVG文件SVG有以下两种文件类型　　a、普通SVG文件是包含SVG标记的简单文本文件。推荐使用“.svg”（全部小写）作为此类文件的扩展名　　b、由于在某些应用（比如地图应用等）中使用时，SVG文件可能会很大，SVG标准同样允许gzip压缩的SVG文件。推荐使用“.svgz”（全部小写）作为此类文件扩展名 SVG文件的完整结构如下所示 　　 第一行包含了 XML 声明，包含version和standalone这两个属性 version表示使用1.0版本的XML standalone属性规定该文件是否是“独立的”。standalone=\"no\" 意味着会引用一个外部文件，在这里是DTD文件 第二行引用了这个外部的 SVG DTD。该 DTD 位于 http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd。该 DTD 位于 W3C，含有所有允许的 SVG 元素 [注意]因为基于SVG的DTD验证导致的问题比它能解决的问题更多，所以应舍弃来自 (X)HTML的doctype声明 第三行开始是SVG代码，包括开始标签 和关闭标签 。这是根元素 width和height属性设置SVG文档的宽度和高度 version属性定义所使用的SVG版本 xmlns属性定义SVG命名空间 因此，SVG的基本框架如下 3、使用SVG标签 在HTML文件中使用SVG标签，或者浏览器直接打开SVG文件时，有一些语法特性需要注意 　　a、SVG的元素和属性必须按标准格式书写 　　b、SVG里的属性值必须用引号引起来，就算是数值也必须这样做 基本形状 下面介绍的几个基本的形状用于大多数的SVG绘图。通过这些形状的命名可以知道其用途。给它们一些属性可以确定它们的位置和大小 要想插入一个形状，可以在文档中创建一个元素。不同的元素对应着不同的形状，并且使用不同的属性来定义图形的大小和位置。有一些形状因为可以由其他的形状创建而略显冗余， 但是它们用起来方便，可让SVG文档简洁易懂 【矩形】 　　rect元素会在屏幕上绘制一个矩形 。其实只要6个基本属性就可以控制它在屏幕上的位置和形状 x 矩形左上角的x位置 y 矩形左上角的y位置 width 矩形的宽度 height 矩形的高度 rx 圆角的x方位的半径 ry 圆角的y方位的半径 [注意]如果只设置rx或ry任意一个，则另一个将默认相等 如果没有设置圆角，则默认为0 【圆形】 circle元素会在屏幕上绘制一个圆形。它只有3个属性用来设置圆形 r 圆的半径 cx 圆心的x位置 cy 圆心的y位置 【椭圆】 　　椭圆Ellipse是circle元素更通用的形式，可以分别缩放圆的x半径和y半径（通常数学家称之为长轴半径和短轴半径） rx 椭圆的x半径 ry 椭圆的y半径 cx 椭圆中心的x位置 cy 椭圆中心的y位置 【线条】 　　线条Line 绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置 　　[注意]line相当于只设置路径，需要设置stroke属性可以显示出线条 x1 起点的x位置 y1 起点的y位置 x2 终点的x位置 y2 终点的y位置 【折线】 　　折线Polyline是一组连接在一起的直线。它可以有很多的点，折线的所有点位置都放在一个points属性中 　　[注意]如果不将polyline的fill设置为透明，将会呈现多边形的效果 points 点集数列。每个数字用空白、逗号、终止命令符或者换行符分隔开 　　每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2” 【多边形】多边形polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。矩形也是一种多边形，如果需要更多灵活性，也可以用多边形创建一个矩形 points 点集数列。每个数字用空白符、逗号、终止命令或者换行符分隔开。 每个点必须包含2个数字，一个是x坐标，一个是y坐标。所以点列表 (0,0), (1,1) 和(2,2)可以写成这样：“0 0, 1 1, 2 2”。路径绘制完后闭合图形，所以最终的直线将从位置(2,2)连接到位置(0,0) 填充和描边 与canvas类似，svg进行样式设置的属性主要是填充fill和描边stroke 多数基本的涂色可以通过在元素上设置两个属性来搞定：fill属性和stroke属性。fill属性设置对象内部的颜色，stroke属性设置绘制对象线条的颜色 【透明度】 　　可以使用opacity来定义图形的整体透明度。而在SVG中可以分别定义填充色和边框色的不透明度，属性fill-opacity控制填充色的不透明度，属性stroke-opacity控制描边的不透明度 将描边设置为0.5的透明度，可实现双色描边的效果 除了颜色和透明度设置，还有其他一些属性用来控制绘制描边的方式 stroke-width属性定义了描边的宽度。注意，描边是以路径为中心线绘制的，在下面的例子里，路径是粉红色的，描边是黑色的。路径的每一侧都有均匀分布的描边 第二个影响描边的属性是stroke-linecap属性，它控制边框终点的形状，有三种可能值　　1、butt用直边结束线段，它是常规做法，线段边界90度垂直于描边的方向、贯穿它的终点　　2、square的效果差不多，但是会稍微超出实际路径的范围，超出的大小由stroke-width控制　　3、round表示边框的终点是圆角，圆角的半径也是由stroke-width控制的 还有一个stroke-linejoin属性，用来控制两条描边线段之间，用什么方式连接 每条折线都是由两个线段连接起来的，连接处的样式由stroke-linejoin属性控制，它有三个可用的值 　　1、miter是默认值，表示用方形画笔在连接处形成尖角 　　2、round表示用圆角连接，实现平滑效果 　　3、bevel表示连接处会形成一个斜接 最后，可以通过指定stroke-dasharray属性，将虚线类型应用在描边上 stroke-dasharray属性的参数，是一组用逗号分割的数字组成的数列。这里的数字必须用逗号分割（空格会被忽略）。每一组数字，第一个用来表示填色区域的长度，第二个用来表示非填色区域的长度 上面的例子中，第二个路径会先做5个像素单位的填色，紧接着是5个空白单位，然后又是5个单位的填色。如果想要更复杂的虚线模式，可以定义更多的数字 第一个例子指定了3个数字，这种情况下，数字会循环两次，形成一个偶数的虚线模式（奇数个循环两次变偶数个）。所以该路径首先渲染5个填色单位，10个空白单位，5个填色单位，然后回头以这3个数字做一次循环，但是这次是创建5个空白单位，10个填色单位，5个空白单位。通过这两次循环得到偶数模式，并将这个偶数模式不断重复 另外还有一些关于填充和描边的属性，如下所示 　　1、fill-rule，用于定义如何给图形重叠的区域上色　　2、stroke-miterlimit，定义什么情况下绘制或不绘制边框连接的miter效果 CSS 　　可以通过CSS来样式化填充和描边。语法和在html里使用CSS一样，只不过要把background-color、border改成fill和stroke 　　不是所有的属性都能用CSS来设置。上色和填充的部分一般是可以用CSS来设置的，比如fill，stroke，stroke-dasharray等，但是不包括下面会提到的渐变和图案等功能。另外，width、height，以及路径的命令等等，都不能用css设置。判断它们能不能用CSS设置还是比较容易的 【行间样式】　CSS可以利用style属性插入到元素的行间 【内部样式】 　　利用设置一段样式段落。就像在html里这样的一般放在里，在svg里可以直接放置标签 　　下面利用CSS来实现hover效果 circle{stroke: black; fill: transparent;stroke-width:5;} circle:hover{stroke:red;} 【外部样式】 　　当然，也可以定义一个外部的样式表，这种情况只适合SVG文件，不适合在HTML文档中引入的SVG标签 　　[注意]在HTML文档的样式表中，只能设置SVG的样式，不能设置SVG里面的circle等形状的样式 //style.css circle{stroke: black; fill: transparent;stroke-width:5;} circle:hover{stroke:red;} Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 08:30:22 "},"svg文本.html":{"url":"svg文本.html","title":"svg 文本","keywords":"","body":"位置属性 在一个SVG文档中，使用元素来设置文本，元素有x、y、dx、dy这四个位置属性 【x和y】属性x和属性y性决定了文本在视口中显示的位置 可以只设置y属性，此时x属性默认为0[注意]如果不设置y属性，则文本将不会显示 【dx和dy】 属性dx和dy用于设置文本相对于当前位置的偏移量 如果dx或dy的值是多个值，则从第二个值开始，表示文本内字符的间距 Hello World! Hello World! 对齐属性 【水平对齐】属性text-anchor用来设置水平对齐，取值包括：start、middle、end或inherit 【垂直对齐】属性dominant-baseline可以设置垂直对齐，包括以下属性 效果展示： 样式属性 和形状元素类似，属性fill可以给文本填充颜色，属性stroke可以给文本描边，也可以引用渐变或图案 对于字体相关属性，下列每个属性可以被设置为一个SVG属性或者成为一个CSS声明：font-family、font-style、font-weight、font-variant、font-stretch、font-size、font-size-adjust、kerning、letter-spacing、word-spacing和text-decoration tspan tspan元素用来标记大块文本的子部分，它必须是一个text元素或别的tspan元素的子元素。一个典型的用法是把句子中的一个词变成粗体 测试文字 【自定义属性】　　tspan元素有以下的自定义属性 　　x 为容器设置一个新绝对x坐标。它覆盖了默认的当前的文本位置。这个属性可以包含一个数列，它们将一个一个地应用到tspan元素内的每一个字符上 　　dx 从当前位置，用一个水平偏移开始绘制文本。这里，可以提供一个值数列，可以应用到连续的字体，因此每次累积一个偏移 　　类似地，还有y和dy 　　rotate 把所有的字符旋转一个角度。如果是一个数列，则使每个字符旋转分别旋转到那个值，剩下的字符根据最后一个值旋转 　　textLength 这是一个很模糊的属性，给出字符串的计算长度。它意味着如果它自己的度量文字和长度不满足这个提供的值，则允许渲染引擎精细调整字型的位置 测试文字你好世界 textPath 　　该元素利用路径文本textPath的xlink:href属性取得一个任意路径，把字符对齐到路径，于是字体会环绕路径、顺着路径走 　　[注意]如果给出的路径长度不够长，则超出部分不会被渲染出来 　　渲染原理如下图所示 你好世界世界你好 【属性】使用textPath后，text元素的x和y属性的含义有所改变 x 路径位置 y 无效 效果展示： textPath只有一个startOffset属性，用来确定排列起始位置 效果展示： 波浪文字 　　下面使用SVG，来实现波浪文字的效果。由于标签的dx、dy属性可以控制文本间的间距。因此，可以通过定时器动态的修改他们的值，将其呈现出动态波浪文字的效果 小火柴的蓝色理想小火柴的蓝色理想 开始运动 暂停运动 //n为文本的数量 var n = sinText.innerHTML.length; //x和y分别储存dx和dy的值 var x = [],y = []; //设置x的值 for(var i = 0; i Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 16:40:38 "},"SVG路径.html":{"url":"SVG路径.html","title":"svg 路径","keywords":"","body":"path字符串 路径(path)是一个非常强大的绘图工具，可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形，以及一些其他的形状，例如贝塞尔曲线、2次曲线等曲线 SVG路径最常用的属性是d属性，即path字符串，用来定义path元素的路径形状 属性d的值是一个“命令+参数”的序列，每一个命令都用一个关键字母来表示。参数之间可以用空格或逗号隔开，有一种情况例外，就是下一个数值是负数 d 一个点集数列以及其它关于如何绘制路径的信息 下面是path字符串中的命令汇总 　　Path命令有如下规律 　　1、区分大小写：每一个命令都有两种表示方式，一种是用大写字母，表示采用绝对位置。另一种是用小写字母，表示采用相对位置 　　2、最后的参数表示最终要到达的位置 　　3、上一个命令结束的位置就是下一个命令开始的位置 　　4、命令可以重复参数表示重复执行同一条命令 　　5、因为属性d采用的是用户坐标系统，所以不需标明单位 直线路径 　　元素里有5个画直线的命令，顾名思义，直线命令就是在两个点之间画直线 　　首先是“Move to”命令，M需要两个参数，分别是需要移动到的点的x轴和y轴的坐标。假设，画笔当前位于一个点，在使用M命令移动画笔后，只会移动画笔，但不会在两点之间画线。因为M命令仅仅是移动画笔，但不画线。所以M命令经常出现在路径的开始处，用来指明从何处开始画 M x y (or m dx dy) 能够真正画出线的命令有三个（M命令是移动画笔位置，但是不画线），最常用的是“Line to”命令，L需要两个参数，分别是一个点的x轴和y轴坐标，L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段 L x y (or l dx dy) 　　另外还有两个简写命令，用来绘制平行线和垂直线。H，绘制平行线。V，绘制垂直线。这两个命令都只带一个参数，标明在x轴或y轴移动到的位置，因为它们都只在坐标轴的一个方向上移动 H x (or h dx) V y (or v dy) “闭合路径命令”Z命令会从当前点画一条直线到路径的起点，尽管不总是需要闭合路径，但是它还是经常被放到路径的最后。另外，Z命令不用区分大小写 Z (or z) 下面使用绝对位置来绘制不闭合的直线 如果使用相对位置，则如下所示 如果使用Z，则可以自动闭合路径 弧形路径 　　基本上，弧形可以视为圆形或椭圆的一部分。假设，已知椭圆形的长轴半径和短轴半径，另外已知两个点（它们的距离在圆的半径范围内），这时有两个路径可以连接这两个点。每种情况都可以生成出四种弧形。所以，为了保证创建的弧形唯一，A命令需要用到比较多的参数 A rx ry x-axis-rotation large-arc-flag sweep-flag x y a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy 　　弧形命令A的前两个参数分别是x轴半径和y轴半径，第三个参数x-axis-rotation表示弧形的旋转情况 　　第四个参数large-arc-flag决定弧线是大于还是小于180度，0表示小角度弧，1表示大角度弧 　　第五个参数sweep-flag表示弧线的方向，0表示从起点到终点沿逆时针画弧，1表示从起点到终点沿顺时针画弧 下面的例子展示了这四种情况 下面使用直线和弧线命令实现一小段圆弧 贝塞尔曲线 SVG支持三次贝塞尔曲线和二次贝塞尔曲线两种形式 【三次贝塞尔曲线】 三次贝塞尔曲线需要定义一个点和两个控制点，所以用C命令创建三次贝塞尔曲线，需要设置三组坐标参数 C x1 y1, x2 y2, x y (or c dx1 dy1, dx2 dy2, dx dy) 　　这里的最后一个坐标(x,y)表示的是曲线的终点，另外两个坐标是控制点，(x1,y1)是起点的控制点，(x2,y2)是终点的控制点。控制点描述的是曲线起始点的斜率，曲线上各个点的斜率，是从起点斜率到终点斜率的渐变过程 　　可以将若干个贝塞尔曲线连起来，从而创建出一条很长的平滑曲线。通常情况下，一个点某一侧的控制点是它另一侧的控制点的对称（以保持斜率不变）。这样，可以使用一个简写的贝塞尔曲线命令S S x2 y2, x y (or s dx2 dy2, dx dy) 　　S命令可以用来创建与之前那些曲线一样的贝塞尔曲线，但是，如果S命令跟在一个C命令或者另一个S命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点。如果S命令单独使用，前面没有C命令或者另一个S命令，那么它的两个控制点就会被假设为同一个点 【二次贝塞尔曲线】 　　另一种可用的贝塞尔曲线是二次贝塞尔曲线Q，它比三次贝塞尔曲线简单，只需要一个控制点，用来确定起点和终点的曲线斜率。因此它需要两组参数，控制点和终点坐标 Q x1 y1, x y (or q dx1 dy1, dx dy) 　　就像三次贝塞尔曲线有一个S命令，二次贝塞尔曲线有一个差不多的T命令，可以通过更简短的参数，延长二次贝塞尔曲线 T x y (or t dx dy) 　　快捷命令T会通过前一个控制点，推断出一个新的控制点。这意味着，在第一个控制点后面，可以只定义终点，就创建出一个相当复杂的曲线。需要注意的是，T命令前面必须是一个Q命令，或者是另一个T命令，才能达到这种效果。如果T单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线 　　虽然三次贝塞尔曲线拥有更大的自由度，但是两种曲线能达到的效果总是差不多的。具体使用哪种曲线，通常取决于需求，以及对曲线对称性的依赖程度 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:08:04 "},"SVG辅助标签.html":{"url":"SVG辅助标签.html","title":"svg 辅助标签","keywords":"","body":"超链接 在SVG中，可以使用超链接。超链接可以添加到任意的图形上，类比于热区 SVG中的超链接有如下3个常用属性 xlink:href 指定连接地址 xlink:title 指定连接标题 target 指定打开方式 光栅图像 SVG有一个image元素，可以利用它嵌入任意光栅（以及矢量）图像。它的规格要求应用至少支持PNG、JPG和SVG格式文件 　　嵌入的图像变成一个普通的SVG元素。这意味着，可以在其内容上用剪切、遮罩、滤镜、旋转等操作 辅助标签 SVG中有四个常用的辅助标签：、、、 　　是一个分组(容器)标签，用来组合元素。可以设置一组元素的属性 　　由于是一个通用的分组标签，可以包含任何形状，因此其只能设置所有形状都有的属性，包括stroke、fill等。由于cx、cy是圆特有的属性，所以无法在上设置 　　下面是一个制作同心圆的小实例 　　如果要改变所有圆的样式时，就要一个一个进行修改，稍显麻烦。这时，使用分组标签就非常合适。如果想通过标签来平移所有元素的位置，可以使用transform()来实现 defs SVG允许定义以后需要重复使用的图形元素。 建议把所有需要再次使用的引用元素定义在defs元素里面。这样做可以增加SVG内容的易读性和可访问性。 在defs元素中定义的图形元素不会直接呈现 use use元素在SVG文档内取得目标节点，并在别的地方复制它们。它的效果等同于这些节点被深克隆到一个不可见的DOM中，然后将其粘贴到use元素的位置 　　因为克隆的节点是不可见的，所以当使用CSS样式化一个use元素以及它的隐藏的后代元素的时候，隐藏的、克隆的DOM不能保证继承CSS属性，除非明文设置使用CSS继承。 　　出于安全原因，一些浏览器可能在use元素上应用同源策略，还有可能拒绝载入xlink:href属性内的跨源URI black red blue symbol 　　symbol元素用来定义一个图形模板对象，它可以用一个元素实例化。symbol元素对图形的作用是在同一文档中多次使用，添加结构和语义，从而提升了可访问性 　　一个symbol元素本身是不呈现的。只有symbol元素的实例（亦即，一个引用了symbol的 元素）才能呈现 　　一个元素可以有preserveAspectRatio和viewBox属性。而元素不能拥有这些属性。因此相比于在元素中使用的方式来复用图形，使用元素也许是一个更好的选择 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:11:42 "},"svg视野.html":{"url":"svg视野.html","title":"svg 视野","keywords":"","body":"前言 SVG中坐标系统非常关键，但在介绍坐标系统之前，首先要了解视野。本文将详细介绍SVG视野 视野 下面来区分视窗、世界和视野 【视窗】 　　SVG的属性width、height来控制视窗的大小，也称为SVG容器 【世界】 　　SVG里面的代码，就是对SVG世界的定义 【视野】 　　世界是无穷大的，视野是观察世界的一个矩形区域。如下图所示 世界不可变，而视野是可以改变的。在SVG中，提供了viewBox和preserveAspectRatio属性来控制视野 viewBox 　　viewBox属性允许指定一个给定的一组图形伸展以适应特定的容器元素 　　viewBox属性的值是一个包含4个参数的列表 min-x, min-y, width and height， 以空格或者逗号分隔开， 在用户空间中指定一个矩形区域映射到给定的元素 【位置】 　　首先来介绍下viewBox的位置属性x、y 　　将viewBox的尺寸与SVG容器尺寸设置为相同，并且在SVG中绘制占满容器尺寸的一个矩形 结果如下图所示，矩形占满容器 效果展示 由结果所示，当x值为正值时，视野向右移动，由于世界和视窗都不变。所以，看起来好像是图形向左移动。反之亦然 【尺寸】 　　介绍过位置属性后，下面以一个例子的形式来解释viewBox中的width和height属性 　　如果不看viewBox，一定会觉得诧异。SVG尺寸明明有200*150像素，而小小的大小只有其1/10，但是显示出来的图形占据了大量的区域 　　下面的gif图，解释了这种现象的原因 　　因此，SVG里面的图形等元素的尺寸是依据viewBox的width、height设置来布局的。最终，再把viewBox的尺寸放大到视窗的尺寸大小来显示 　　下面来解释下，视窗、世界和视野的关系 　　世界是无穷大的。viewBox的尺寸设置的越大，即视野越大，则可显示的世界的区域就越大。由于视窗大小是固定的，因此，SVG内部元素尺寸看上去就越小。反之亦然 preserveAspectRatio 　　上面的例子，SVG的宽高比正好和viewBox的宽高比是一样的，都是4:3。显然，实际应用viewBox不可能一直跟viewport相同比例。此时，就需要preserveAspectRatio出马了，此属性也是应用在元素上，且作用的对象都是viewBox 　　preserveAspectRatio属性的值为空格分隔的两个值组合而成。第一个值表示，viewBox如何与SVG viewport对齐；第二个值表示，如何维持高宽比（如果有） 　　其中，第1个值又是由两部分组成的。前半部分表示x方向对齐，后半部分表示y方向对齐 值 含义 xMin viewport和viewBox左边对齐 xMid viewport和viewBox x轴中心对齐 xMax viewport和viewBox右边对齐 YMin viewport和viewBox上边缘对齐。注意Y是大写。 YMid viewport和viewBox y轴中心点对齐。注意Y是大写。 YMax viewport和viewBox下边缘对齐。注意Y是大写。 然后，把x和y进行组合，比如xMinYMin、xMidYMin 　　preserveAspectRatio属性第二部分的值支持下面3个 值 含义 meet 保持纵横比缩放viewBox适应viewport slice 保持纵横比同时比例小的方向放大填满viewport none 扭曲纵横比以充分适应viewport 　[注意]preserveAspectRatio属性第二部分的值设置为none时，第一部分的值必须为空，否则报错 　　如果不设置preserveAspectRatio属性，默认是xMidYMid、meet属性 　　下面的例子中，视窗设置为200150，视野设置为200100，矩形占满整个视野 效果演示 　　由结果所示，设置为meet时，视野的宽高通过按比例缩放，都处于视窗范围内；设置为slice时，按比例缩放后发生剪切，有些内容超出视窗范围；设置为none时，视野宽高缩放到视窗的尺寸 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:15:37 "},"SVG坐标系统及图形变换.html":{"url":"SVG坐标系统及图形变换.html","title":"svg 坐标系统及图形变换","keywords":"","body":"前言 前面介绍过SVG视野后，本文将开始介绍SVG坐标系统及图形变换 坐标定位 　　对于所有元素，SVG使用的坐标系统或者说网格系统，和Canvas用的差不多（所有计算机绘图都差不多）。这种坐标系统是：以页面的左上角为(0,0)坐标点，坐标以像素为单位，x轴正方向是向右，y轴正方向是向下 定义一个矩形，即从左上角开始，向右延展100px，向下延展100px，形成一个100*100大的矩形 四个坐标系 　　SVG中的四个坐标系包括用户坐标系、自身坐标系、前驱坐标系和参考坐标系。其中，用户坐标系和自身坐标系是客观的坐标系，而前驱坐标系和参考坐标系是相对的坐标系 【用户坐标系】 　　SVG的世界是无穷大的，世界里面的坐标系就是用户坐标系 　　viewBox的设置就是观察用户坐标系的哪个区域。比如设置viewBox = \"0 0 200 150\"，即观察用户坐标系里的这个区域 　　用户坐标系是最原始的坐标系，其他的坐标系都是基于用户坐标系产生的。因此，用户坐标系也被称为原始坐标系 【自身坐标系】 　　自身坐标系是每个SVG图形或图形分组与生俱来的坐标系 　　比如一个矩形设置为，其位置和尺寸的定义都是基于其自身坐标系来描述的 【前驱坐标系】　　前驱坐标系即该元素的父元素的坐标系 　　如下所示，矩形rect的父元素是SVG元素，即其前驱坐标系是用户坐标系 坐标变换 　　所谓坐标变换，指前驱坐标系经过元素的变换后，得到元素的自身坐标系 　　如下所示，加入transform属性之后，rect元素就是相对于其前驱坐标系发生了坐标变换，得到了自身坐标系 【参考坐标系】 　　使用其他坐标系来观察自身元素坐标位置时使用 　　如下所示，rect元素定义的坐标是(0,0)。如果以用户坐标系作为参考坐标系，则rect元素在参考坐标系中的坐标是(50,50) 图形变换 　　在SVG中，坐标变换是对一个坐标系到另一个坐标系的变换的描述 　　在2D平面上，一般采用线性变换来满足变换的需求。SVG中的线性变换使用transform属性来完成 　　SVG中的transform属性与CSS3中的transform样式里面的一些基本的变换类型是一样的，包括：位移translate, 旋转rotate, 缩放scale, 斜切skew以及直接矩阵matrix。但只局限于2D层面的变换。SVG似乎只支持二维变换，且类似translateX, rotateX也都是不支持的 【平移】 　　translate()变形方法把元素移动一段距离，可以根据相应的属性定位它 　　该示例将呈现一个矩形，移到点(30,40)，而不是出现在点(0,0) 　　[注意]如果没有指定第二个值，它默认被赋值0 【旋转】 　　使用rotate()变形旋转一个元素 该示例显示了一个方形，旋转了45度。rotate()的值是用角度数指定的 【缩放】 　　scale()变形改变了元素的尺寸。它需要两个数字，作为比率计算如何缩放。0.5表示收缩到50%。如果第二个数字被忽略了，它默认等于第一个值 【斜切】 　　在前面的一些变换中，例如位移、缩放之类是不支持translateX, scaleX这种CSS常见用法的，但是这里的skew却有点不同：不支持skew(x[, y])这种语法，而只能是skewX或者skewY 　　利用一个矩形制作一个斜菱形。可用skewX()变形和skewY()变形。每个需要一角度以确定元素斜切到多远 【matrix()】 　　所有上面的变形可以表达为一个2x3的变形矩阵。组合一些变形，可以直接用matrix(a, b, c, d, e, f)变形设置结果矩阵，利用下面的矩阵，它把来自上一个坐标系统的坐标映射到新的坐标系统： 【变换列表】 　　线性变换列表表示为一系列的变换，结果为变换的矩阵的乘积。要特别注意的是，后面的变换要乘在前面 居中变换 　　像缩放、斜切这些SVG变换，想要如CSS transform-origin:50% 50%一样的中心点变换效果，下面有两个思路可供参考 【原始中心位置位于SVG左上角】 　　拿45度旋转举例，可以把元素默认就放在中心点和SVG左上角重合的位置上 【viewBox】 　　可以把元素默认挂在左上角，然后，通过设置viewBox，让元素呈现的位置并不是真正的左上角，例如应用viewBox='-140 -105 280 210' 　　此时，只需要让元素旋转就可以了，无需额外的做translate位移 todo:problem : svg的居中变换，通过实践方法1和方法2好像都没有达到想要的效果 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:22:26 "},"SVG渐变.html":{"url":"SVG渐变.html","title":"svg 渐变","keywords":"","body":"前言 给SVG元素应用填充和描边，除了使用纯色外，还可以使用渐变。本文将详细介绍SVG渐变 线性渐变 　　有两种类型的渐变：线性渐变和径向渐变。必须给渐变内容指定一个id属性，否则文档内的其他元素不能引用它。为了让渐变能被重复使用，渐变内容需要定义在标签内部，而不是定义在形状上面 　　线性渐变沿着直线改变颜色，要插入一个线性渐变，需要在SVG文件的defs元素内部，创建一个 节点 元素一共有3个属性，包括offset，stop-color，stop-opacity offset用来设置色标位置 stop-color用来设置色标颜色 stop-opacity用来设置色标的透明 例子： 【x1、x2、y1、y2】 　　线性渐变包括x1、x2、y1、y2这四个属性，用来控制渐变的大小和方向。取值为0-100%，或者0-1的小数。默认地，x1=y1=y2=0、x2=1 　　如果变成垂直方向的渐变，则需要设置为x1=x2=y1=0、y2=1 如果将y2或x2设置为50%，则50%-100%这一部分区域填充为最后一个色标的纯色 当然了，可以有多个色标 渐变除了可以作为填充，也可以作为描边 【xlink:href】 　　xlink:href属性用于在一个渐变中引用另一个渐变，被引用的渐变的属性是可继承的，也可以被重写 　　下面的例子中，Gradient2引用了Gradient1的渐变，并重写了渐变的方向 【gradientUnits】 　　gradientUnits有两个的值，userSpaceOnUse和objectBoundingBox，这用于决定渐变是否随着引用它的元素进行缩放。也就是说它决定了x1、y1、x2、y2的缩放 　　userSpaceOnUse: x1、y1、x2、y2表示当前用户坐标系统的坐标。也就是说渐变中的值都是绝对值 　　objectBoundingBox: x1, y1, x2, y2表示应用渐变的元素创建的边界坐标系统。也就是说渐变随着应用的元素进行了缩放 　　如果不设置，默认取值是objectBoundingBox 如果设置为userSpaceOnUse，则x1、x2、y1、y2需要设置为用户坐标系的坐标绝对值 【spreadMethod】 　　spreadMethod可以接受三个值，pad，reflect，repeat，它定义了渐变如何开始和结束，当cx和cy的值是在0%到100%里面的时候 pad:（默认值）使用开始和结束位置的颜色结点来填充剩余的部分 reflect: 反射渐变图案，从开始->结束，再从结束->开始，然后开始->结束，往复直到空间都填满 repeat: 从start-to-end重复渐变图案，直到空间填满 pad为默认值 下面是reflect的效果 下面是repeat的效果 径向渐变 　　径向渐变与线性渐变相似，只是它是从一个点开始发散绘制渐变。创建径向渐变需要在文档的defs中添加一个元素 【cx、cy、r、fx、fy】 　　与线性渐变的x1、y1、x2、y2属性不同，径向渐变使用cx、cy、r、fx、fy这五个属性来设置渐变 r 设置圆的半径 cx、cy 定义渐变的中心点坐标 fx、fy 定义渐变的焦点坐标 如果不设置，r默认0.5，即元素宽度或高度的一半；cx、cy默认为0.5；fx、fy默认为0.5 巧妙地设置焦点坐标，可以实现聚光灯的效果 【xlink:href】 　　xlink:href属性用于在一个渐变中引用另一个渐变，被引用的渐变的属性是可继承的，也可以被重写 　　下面的例子中，Gradient2引用了Gradient1的渐变，并重写了渐变的方向 【gradientUnits】 　　gradientUnits有两个的值，userSpaceOnUse和objectBoundingBox，这用于决定渐变是否随着引用它的元素进行缩放。也就是说它决定了cx、cy、fx、fy、r的缩放 　　userSpaceOnUse: cx、cy、fx、fy、r表示当前用户坐标系统的坐标。也就是说渐变中的值都是绝对值 　　objectBoundingBox: cx、cy、fx、fy、r表示应用渐变的元素创建的边界坐标系统。也就是说渐变随着应用的元素进行了缩放 　　如果不设置，默认取值是objectBoundingBox 如果设置为userSpaceOnUse，则cx、cy、fx、fy、r需要设置为用户坐标系的坐标绝对值 【spreadMethod】 　　和线性渐变一样。它可以接受三个值，pad，reflect，repeat，它定义了渐变如何开始和结束，当cx和cy的值是在0%到100%里面的时候 pad:（默认值）使用开始和结束位置的颜色结点来填充剩余的部分 reflect: 反射渐变图案，从开始->结束，再从结束->开始，然后开始->结束，往复直到空间都填满 repeat: 从start-to-end重复渐变图案，直到空间填满 pad为默认值 reflect的效果 下面是repeat的效果 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:33:36 "},"前端工具.html":{"url":"前端工具.html","title":"前端工具","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:40:21 "},"yarn教程.html":{"url":"yarn教程.html","title":"yarn 教程","keywords":"","body":"yarn 是什么 Yarn 对你的代码来说是一个包管理器， 你可以通过它使用全世界开发者的代码，或者分享自己的代码。 Yarn 做这些快捷、安全、可靠，所以你不用担心什么。 代码通过包（package）（或者称为模块（module））的方式来共享。 一个包里包含所有需要共享的代码，以及描述包信息的文件，称为package.json。 安装升级 【安装】你可以通过 Homebrew 包管理器安装 Yarn，如果没有安装 Node.js 它也可以安装。 brew install yarn 【升级】 brew upgrade yarn 【查看版本】 yarn --version 常用命令 【初始化新项目】 yarn init 【添加依赖包】 yarn global add [package] 全局安装包 yarn add [package] yarn add [package]@[version] yarn add [package]@[tag] [将依赖项添加到不同依赖项类别]分别添加到 devDependencies、peerDependencies 和 optionalDependencies： yarn add [package] --dev yarn add [package] --peer yarn add [package] --optional 【升级依赖包】 yarn upgrade [package] yarn upgrade [package]@[version] yarn upgrade [package]@[tag] 【移除依赖包】 yarn remove [package] 【安装项目的全部依赖】 yarn install yarn.lock 为了跨机器安装得到一致的结果，Yarn 需要比你配置在 package.json 中的依赖列表更多的信息。 Yarn 需要准确存储每个安装的依赖是哪个版本。 为了做到这样，Yarn 使用一个你项目根目录里的 yarn.lock 文件。这些 “lockfile” 看起来像这样的： # THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. # yarn lockfile v1 package-1@^1.0.0: version \"1.0.3\" resolved \"https://registry.npmjs.org/package-1/-/package-1-1.0.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\" package-2@^2.0.0: version \"2.0.1\" resolved \"https://registry.npmjs.org/package-2/-/package-2-2.0.1.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\" dependencies: package-4 \"^4.0.0\" package-3@^3.0.0: version \"3.1.9\" resolved \"https://registry.npmjs.org/package-3/-/package-3-3.1.9.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0\" dependencies: package-4 \"^4.5.0\" package-4@^4.0.0, package-4@^4.5.0: version \"4.6.3\" resolved \"https://registry.npmjs.org/package-4/-/package-4-2.6.3.tgz#a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0 这可以媲美其他像 Bundler 或 Cargo 这样的包管理器的 lockfiles。它类似于 npm 的 npm-shrinkwrap.json，然而他并不是有损的并且它能创建可重现的结果。 [注意]你的 yarn.lock 文件是自动产生的，而且应该完全被 Yarn 管理。 当你用 Yarn CLI 增加／升级／删除依赖，它将自动更新你的 yarn.lock 文件。 不要直接编辑这个文件，那样很容易弄坏某些东西。 【提交到版本控制系统 】所有 yarn.lock 文件应该被提交到版本控制系统（例如 git 或者 mercurial）。 这允许 Yarn 跨所有机器安装相同的依赖树，无论它是你同事的笔记本还是 CI 服务器。 框架和库的作者也应该把 yarn.lock 提交到版本控制系统。 别担心发布 yarn.lock 文件，因为它对库的用户不会有任何影响。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-14 16:50:29 "},"Homebrew使用教程.html":{"url":"Homebrew使用教程.html","title":"Homebrew 使用教程","keywords":"","body":"homebrew homebrew是osx下的一个包管理工具，可以很方便的管理各类包。官方给出的定义是：macOS缺失的软件包管理器 安装 执行如下命令： /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 上边的命令行时两个命令，首先下载install文件，然后用系统的ruby工具安装。 【查看版本】 brew -v Homebrew 1.4.3 Homebrew/homebrew-core (git revision dba402; last commit 2018-01-09) 常用命令 1.安装卸载软件 brew --version或者brew -v 显示brew版本信息 brew install 安装指定软件 brew unistall 卸载指定软件 brew list 显示所有的已安装的软件 brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾 brew search /text/ 使用正则表达式搜软件 2.升级软件相关 brew update 自动升级homebrew（从github下载最新版本） brew outdated 检测已经过时的软件 brew upgrade 升级所有已过时的软件，即列出的以过时软件 brew upgrade 升级指定的软件 brew pin 禁止指定软件升级 brew unpin 解锁禁止升级 brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包 3.清理相关 homebrew再升级软件时候不会清理相关的旧版本，在软件升级后我们可以使用如下命令清理 brew cleanup -n 列出需要清理的内容 brew cleanup 清理指定的软件过时包 brew cleanup 清理所有的过时软件 brew unistall 卸载指定软件 brew unistall --force 彻底卸载指定软件，包括旧版本 [注意]通过brew安装的文件会自动设置环境变量，所以不用担心命令行不能启动的问题。 比如安装好了gradle，即可运行 gradle -v Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:35:31 "},"lerna教程.html":{"url":"lerna教程.html","title":"lerna 教程","keywords":"","body":"前言 在最初开开发package的时候，还属于一种刀耕火种的阶段。没有什么自动化的工具。发布package的时候，都是手动修改版本号。如果packages数量不多还可以接受。但是当数量逐渐增多的时候，且这些packages之间还有依赖关系的时候，对开发人员来说，就很痛苦了。工作不仅繁琐，而且需要用掉不少时间。 举个例子，如果你要维护两个package。分别为module-A,module-B。 下面是这两个package的依赖关系。 module-A { \"name\": \"module-A\", \"version\": \"1.0.0\", \"author\": \"\", \"license\": \"\", \"description\": \"\", \"scripts\": { }, \"dependencies\": { \"module-B\": \"^1.0.0\" }, \"private\": true, } module-B { \"name\": \"module-B\", \"version\": \"1.0.0\", \"author\": \"\", \"license\": \"\", \"description\": \"\", \"scripts\": { }, \"dependencies\": { }, \"private\": true, } 在这样的环境下，module-A是依赖module-B的。如果module-B有修改，需要发布。那么你的工作有这些。 修改module-B版本号，发布。 修改module-A的依赖关系，修改module-A的版本号，发布。 这还仅仅只有两个package,如果依赖关系更复杂，大家可以想想发布的工作量有多大。 什么是lerna?为什么要使用lerna? lerna到底是什么呢？lerna官网上是这样描述的。 A tool for managing JavaScript projects with multiple packages. 引入lerna后，上面提到的问题不仅迎刃而解，更为开发人员提供了一种管理多packages javascript项目的方式。 自动解决packages之间的依赖关系 通过git检测文件改动，自动发布 根据git提交记录，自动生成CHANGELOG 一个基础lerna仓库结构如下： my-lerna-repo/ ┣━ packages/ ┃ ┣━ package-1/ ┃ ┃ ┣━ ... ┃ ┃ ┗━ package.json ┃ ┗━ package-2/ ┃ ┣━ ... ┃ ┗━ package.json ┣━ ... ┣━ lerna.json ┗━ package.json 使用lerna的基本工作流 准备工作 git仓库(自行安装) npm仓库注册开通(参考文章>>>npm发线上包(npm publish)) 全局安装lernanpm install lerna -g 初始化一个lerna项目 1、创建文件夹 mkdir lerna-demo && cd $_ 2、初始化lerna工程 lerna init 执行成功后，目录下将会生成这样的目录结构 lerna-demo/ ┣━ packages/ ┣━ lerna.json ┗━ package.json 创建模块 Lerna 提供了两种创建或导入模块的方式，分别是 create，import。 create 创建一个 lerna 管理的模块。基本命令格式如下： lerna create packageName [loc] [注意]packageName必须是唯一的(npm仓库中无重名已发布包) lerna create @lion/package-a 命令执行完后，lerna 会帮我们在指定位置创建模块的文件夹，同时会默认在该文件夹下执行 npm init 的命令，在终端上根据根据提示填写所有信息后会帮我们创建对应的 package.json 文件，大致的结构如下 lerna-demo/ ┣━ packages/ ┃ ┗━ package-a/ ┃ ┣━ ... ┃ ┗━ package.json ┣━ lerna.json ┗━ package.json import 导入一个已存在的模块，同时保留之前的提交记录，方便将其他正在维护的项目合并到一起。基本命令格式如下：lerna import dir dir 是本项目外的包含 npm 包的 git 仓库路径（相对于本项目根路径的相对路径） 查看模块列表 创建完毕之后，我们可以通过 list 命令来查看和确认现在管理的包是否符合我们的预期，执行如下命令： lerna list 添加依赖包 现在我们来添加依赖包，在 lerna 项目里，你可以分别给每个模块单独添加依赖包，也可以同时给部分或全部模块添加依赖包，还可以把管理的某些模块作为依赖添加给其他模块。 lerna add [@version] [--dev] [--exact] [注意]--dev 和 --exact 等同于 npm install 里的 --dev 和 --exact 当我们执行此命令后，将会执行下面那2个动作： 在每一个符合要求的模块里安装指明的依赖包，类似于在指定模块文件夹中执行 npm install 。 更新每个安装了该依赖包的模块中的 package.json 中的依赖包信息 # 在 package-a 这个模块里安装 lodash 依赖 $ lerna add lodash --scope @lion/package-a # 在 package-a 这个模块里安装 lodash 依赖，并作为 devDependencies $ lerna add lodash --scope @lion/package-a --dev # 在所有模块中安装 @lion/package-a 这个依赖除了 package-a 自己 $ lerna add @lion/package-a # 在所有模块里安装 lodash 依赖 $ lerna add lodash 安装依赖包 lerna 通过 bootstrap 命令来快速安装所有模块所需的依赖包。基本命令如下 lerna bootstrap 当执行完上面的命令后，会发生以下的行为： 在各个模块中执行 npm install 安装所有依赖 将所有相互依赖的 Lerna 模块 链接在一起 在安装好依赖的所有模块中执行 npm run prepublish 在安装好依赖的所有模块中执行 npm run prepare 清理依赖包 可以通过 clean 命令来快速删除所有模块中的 node_modules 文件夹。基本命令如下： lerna clean 版本迭代 lerna 通过 version 命令来为各个模块进行版本迭代。基本命令如下： lerna version [major | minor | patch | premajor | preminor | prepatch | prerelease] 如果不选择此次迭代类型，则会进入交互式的提示流程来确定此次迭代类型 $ lerna version 1.0.1 # 按照指定版本进行迭代 $ lerna version patch # 根据 semver 迭代版本号最后一位 $ lerna version # 进入交互流程选择迭代类型 当执行此命令时，会发生如下行为： 标记每一个从上次打过 tag 发布后产生更新的包 提示选择此次迭代的新版本号 修改 package.json 中的 version 值来反映此次更新 提交记录此次更新并打 tag 推送到远端仓库 你可以在执行此命令的时候加上 ——no-push 来阻止默认的推送行为，在你检查确认没有错误后再执行 git push 推送 –conventional-changelog $ lerna version --conventional-commits version 支持根据符合规范的提交记录在每个模块中自动创建和更新 CHANGELOG.md 文件，同时还会根据提交记录来确定此次迭代的类型。只需要在执行命令的时候带上 --conventional-changelog 参数即可 –changelog-preset $ lerna version --conventional-commits --changelog-preset angular-bitbucket changelog 默认的预设是 angular，你可以通过这个参数来选择你想要的预设创建和更新 CHANGELOG.md 上述 2 个参数也可以直接写在 lerna.json 文件中，这样每次执行 lerna version 命令的时候就会默认采用上面的 2 个参数 \"command\": { \"version\": { \"conventionalCommits\": true, \"changelogPreset\": \"angular\" } } 发版 在一切准备就绪后，我们可以通过 publish 命令实现一键发布多个模块。基本命令如下： $ lerna publish 当执行此命令时，会发生如下行为： 发布自上次发布以来更新的包(在底层执行了 lerna version，2.x 版本遗留的行为) 发布当前提交中打了 tag 的包 发布在之前的提交中更新的未经版本化的 “canary” 版本的软件包（及其依赖项） 注意： Lerna 不会发布在 package.json 中将 private 属性设置为 true 的模块，如果要发布带域的包，你还需要在 ‘package.json’ 中设置如下内容： \"publishConfig\": { \"access\": \"public\" } 由于我们之前已执行过 lerna version 命令，这里如果直接执行 lerna publish 会提示没有发现有更新的包需要更新，我们可以通过从远端的 git 仓库来发布： $ lerna publish from-git 在确认后 lerna 就会帮我们把所有更新后的模块都发布在 npm 仓库里，当然在这之前你要做好发布 npm 包的一些准备，比如在 npm 注册账号，并在本地 npm adduser 等(查看>>>npm发包) 此时我们去 npm 上就能看到新发布上去的模块了 lerna的两种模式 lerna有两种工作模式,Independent mode和Fixed/Locked mode。lerna的默认模式是Fixed/Locked mode，在这种模式下，实际上lerna是把工程当作一个整体来对待。每次发布packages，都是全量发布，无论是否修改。但是在Independent mode下，lerna会配合Git，检查文件变动，只发布有改动的package。 lerna.json { \"lerna\": \"3.5.1\", \"packages\": [\"packages/*\"], \"version\": \"independent\", Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-09 14:27:30 "},"插件库.html":{"url":"插件库.html","title":"插件库应用","keywords":"","body":"源码阅读资料 underscore源码 underscore源码中文翻译 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-06 10:35:00 "},"chart.jsangular组件封装ng6、实战配置、插件编写.html":{"url":"chart.jsangular组件封装ng6、实战配置、插件编写.html","title":"chart.js angular组件封装(ng6)、实战配置、插件编写","keywords":"","body":"前言 项目需要使用chart.js插件，由于项目是使用angular开发，那么我第一步就是先把chart.js改造成angular组件来使用。 本项目代码都可以在github上下载：项目git地址 angular改造 1、搭建angular项目步骤省略了，可以自行查询ng官方文档 2、创建一个chart-js的组件 ng g c chart-js chart-js.component.html chart-js.component.ts import { Component, OnInit, ViewChild, ElementRef, AfterViewInit, Input, OnChanges, SimpleChanges, OnDestroy } from \"@angular/core\"; import \"chart.js\"; declare var window: any; @Component({ selector: 'chart-js', templateUrl: './chart-js.component.html', styleUrls: ['./chart-js.component.css'] }) export class ChartJsComponent implements OnInit, AfterViewInit, OnChanges, OnDestroy { @ViewChild(\"canvas\") canvas: ElementRef; @Input() config; private chart; constructor() { } ngOnInit() { } // 子组件加载完成后，渲染图标 ngAfterViewInit() { this.render(); } // 渲染图表 render() { this.chart = new window.Chart( this.canvas.nativeElement.getContext(\"2d\"), this.config ); this.chart.height = \"100%\"; } // 判断Input参数config 是否变化，如果变化，触发更新绘图 ngOnChanges({ config }: SimpleChanges) { if (config && !config.isFirstChange()) { this.destroyChart(); this.render(); } } // 销毁chart ngOnDestroy() { this.destroyChart(); } // 销毁chart主体 destroyChart() { if (this.chart) { this.chart.destroy(); this.chart = undefined; } } } 好了angular组件就这样改造完成了，接下来我们看下如何调用把 // html // ts // 一份简单的配置，后续会详细解释配置的含义 this.config = { type: 'bar', data: { labels: [\"Red\", \"Blue\", \"Yellow\", \"Green\", \"Purple\", \"Orange\"], datasets: [{ label: '# of Votes', data: [12, 19, 3, 5, 2, 3], backgroundColor: [ 'rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 'rgba(75, 192, 192, 0.2)', 'rgba(153, 102, 255, 0.2)', 'rgba(255, 159, 64, 0.2)' ], borderColor: [ 'rgba(255,99,132,1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)' ], borderWidth: 1 }] }, options: { scales: { yAxes: [{ ticks: { beginAtZero:true } }] }, onHover(event, elements) { console.log(event,elements); }, } } 看下效果吧： 配置详解 具体配置可以参考下面链接，非常全面 Chart.js中文文档 配置一个复合图表 经常可以看到一个数据表中包含几种方式的展示具体看图： 既有柱状图也有折线图。像这样的该如何进行配置呢？ 只需要在dataset里面新增一种数据类型并制定相应的type即可，具体如下 datasets: [ { label: '# of Votes', data: [12, 19, 3, 5, 2, 3], backgroundColor: [ 'rgba(255, 99, 132, 0.2)', 'rgba(54, 162, 235, 0.2)', 'rgba(255, 206, 86, 0.2)', 'rgba(75, 192, 192, 0.2)', 'rgba(153, 102, 255, 0.2)', 'rgba(255, 159, 64, 0.2)' ], borderColor: [ 'rgba(255,99,132,1)', 'rgba(54, 162, 235, 1)', 'rgba(255, 206, 86, 1)', 'rgba(75, 192, 192, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)' ], borderWidth: 1 }, { type: \"line\", // 将此数据集类型变为折线图 label: \"Line Dataset\", data: [3, 5, 7, 16] } ] 查看完整配置代码 chart.js 插件编写 插件扩展分为全局插件和内联插件 【内联插件】 插件也可以直接在图表插件配置（即内联插件）中定义 var chart = new Chart(ctx, { plugins: [ { beforeInit: function(chart, options) { //.. } } ] }); 【全局插件】 插件可以在全局范围内注册，应用于所有图表（即全局插件） Chart.pluginService.register({ // plugin implementation }); 【编写一个插件】回顾下上面我们画的图表 如果这个时候产品跟我们说，想在这个图表上添加一个背景色，且背景色可以设置。 我们赶紧翻到柱状/条形图(Bar)的配置这里查看，发现并没有这个配置项，只能对各个柱状/条形图填充色。并不能对整个背景填充颜色 怎么办？编写插件吧。 查看下文档发现插件提供了一些钩子函数给我们： 那么我们开始正式编写插件 beforeDraw: function(chartInstance) { // chartInstance === 画布实例 // 首先我们去获取配置表，看是否配置了chartAreaBackground，如果没有配置则不执行 if (!chartInstance.options.chartAreaBackground) return; var ctx = chartInstance.chart.ctx; // 获取画布上下文 var chartArea = chartInstance.chartArea; // 画布区域 var left = chartArea.left; var right = chartArea.right; var yOptions = chartInstance.scales[\"y-axis-0\"]; var yAxesTop = yOptions.paddingTop; var yAxesBottom = yOptions.paddingBottom; var top = chartArea.top + yAxesTop; var bottom = chartArea.bottom - yAxesBottom; var width = right - left; // 获取到画布宽度 var height = bottom - top; // 获取画布的高度 ctx.fillStyle = chartInstance.options.chartAreaBackground; // 获取背景色 ctx.fillRect(left, top, width, height); // 举行填充 } 如果对区域的位置不清楚的可以看下面的标注： 插件编写好了。如何使用呢？插件里面通过判断chartInstance.options.chartAreaBackground 这个是否配置。那么很明显，我们对这个进行配置就可以了 options:{ chartAreaBackground:'#f5f5f5' } 再来看下效果： 灰色背景色已经出现了。说明内联插件我们已经配置成功了。 【把上面的插件改造成全局插件】 新建文件 chart-plugin.ts import * as Chart from \"chart.js\"; const drawBgColorFactory = function (Chart) { const drawBgColor = { beforeDraw: function(chartInstance) { // chartInstance === 画布实例 console.log(chartInstance); // 首先我们去获取配置表，看是否配置了chartAreaBackground，如果没有配置则不执行 if (!chartInstance.options.chartAreaBackground) return; var ctx = chartInstance.chart.ctx; // 获取画布上下文 var chartArea = chartInstance.chartArea; // 画布区域 var left = chartArea.left; var right = chartArea.right; var yOptions = chartInstance.scales[\"y-axis-0\"]; var yAxesTop = yOptions.paddingTop; var yAxesBottom = yOptions.paddingBottom; var top = chartArea.top + yAxesTop; var bottom = chartArea.bottom - yAxesBottom; var width = right - left; // 获取到画布宽度 var height = bottom - top; // 获取画布的高度 ctx.fillStyle = chartInstance.options.chartAreaBackground; // 获取背景色 ctx.fillRect(left, top, width, height); // 举行填充 } }; Chart.pluginService.register(drawBgColor); }; drawBgColorFactory(Chart); 这样我们就在全局注册成功了 小结 那么至此全局插件，局部插件我们都已经实现了，如果想要实现更加复杂的插件，则需要在项目中更加深入的去学习chart.js插件 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:42:01 "},"jquery如何编写插件.html":{"url":"jquery如何编写插件.html","title":"jquery如何编写插件","keywords":"","body":"前言 之所以要编写插件，也是想把一些把一些通用的功能抽取出来，整个团队可以直接使用，而无需更多的关心该如何实现它，大大的节约了重复开发时间。本文将详细讲解如何开发一个jquery插件。 jquery插件开发模式 jQuery插件开发方式主要有三种： 通过$.extend()来扩展jQuery 通过$.fn 向jQuery添加新的方法 通过$.widget()应用jQuery UI的部件工厂方式创建 今天主要讲解$.extend() 以及 $.fn $.extend() 该形式的方法适合在jquery身上添加一个静态方法，并不适合开发更加复杂的插件 插件定义： $.extend({ hello: function(name){ console.log('hello:',name); } }) 插件调用： $.hello('jack'); 上面代码中，通过$.extend()向jQuery添加了一个hello函数，然后通过$直接调用。到此你可以认为我们已经完成了一个简单的jQuery插件了。 这种方式无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上，还是需要使用第二种开发方式。你所见到或使用的插件也大多是通过此种方式开发。 $.fn 基本格式 $.fn.pluginName = function(){} or (function($){ $.fn.pluginName = function(){} })(jQuery) 插件使用： $('div').myPlugin(); 插件定义： $.fn.myPlugin = function() { 其中的this 就是调用插件的元素 $('div') this.css('color', 'red'); } [重要]this就是调用插件的元素，这也是种形式的强大之处，可以获取到调用元素的上下文，有了这个我们能做到的事情就很多了。 编写一个更加复杂的插件 先来看看效果： 这是一个轮播图的效果。我们开始实现吧。 html 上一步 下一步 css .promo:after, .promo:before{ content: \" \"; display: table; } .promo:after{ height: 0; line-height: 0; visibility: hidden; clear: both; } html,body{ width:100%; } .marquee { overflow: hidden; margin: 20px auto; } .marquee .marquee-wrap { width: 100%; overflow: hidden; height: 100%; position: relative; } .marquee .marquee-inner{ overflow: hidden; transition-duration: 0.3s; transform: translate3d(0px, 0px, 0px); backface-visibility: hidden; left: 0; opacity: 1; } .marquee .marquee-thumbnail{ float: left; overflow: hidden; width: 520px; display: block; visibility: visible; } .marquee .marquee-ft{ width: 100%; display: flex; justify-content: space-between; position: absolute; top:50%; left:0; } 调用插件： $(function () { $('#marquee').marquee({ imgList:[ \"https://img.alicdn.com/tps/i4/TB1f8_hbMKG3KVjSZFLSuuMvXXa.jpg_q90_.webp\", \"https://img.alicdn.com/tps/i4/TB18LGBbMaH3KVjSZFpSuvhKpXa.jpg_q90_.webp\", \"https://img.alicdn.com/simba/img/TB1gCYda25G3KVjSZPxSuvI3XXa.jpg\" ], width: '520', height: '280', interval: 5000, auto: true }); }); 定义插件： $.fn.marquee = function(params) { var _params = params || {}; // 获取传来的参数 var $marquee = this; // 获取调用元素对象 var $inner = $marquee.find('.marquee-inner'); var imgList = _params.imgList || []; // 获取传来的图片数组 var WIDTH = _params.width || 520; // 参数 var HEIGHT = _params.height || 280;// 参数 var $prev = $marquee.find(\".prev\"); // 获取上一步按钮 var $next = $marquee.find(\".next\"); // 获取下一步按钮 var target = 0; // 定义图片展示的页数 var _auto = _params.auto || false; // 是否自动轮播 var interval = _params.interval === void 0 || _params.interval{ str += ` ` }); $inner.html(str) } // 根据参数初始化DOM结构的css属性值 function initSize(){ $marquee.css({ width: WIDTH + 'px', height: HEIGHT + 'px' }); $marquee.find(\".marquee-thumbnail\").css({ width: WIDTH + 'px' }); $inner.css({ width: imgList.length * WIDTH + 'px' }); } // 图片移动功能函数 function move(){ $inner.css({ transform: `translate3d(${ -target*WIDTH }px, 0px, 0px)` }) } // 改变target值功能函数 function calculate(num){ target += num ; target = target imgList.length-1 ? 0 : target ; } // 自动轮播功能函数 function automatic(){ timer && clearTimeout(timer); timer = setTimeout(function(){ next(); automatic(); },interval); } // 下一页功能函数 function next (){ calculate(1); move(); } // 上一页功能函数 function prev (){ calculate(-1); move(); } // 停止轮播 function stop(){ timer && clearTimeout(timer); } // 为元素添加上事件 function addClickEvent(){ $prev.on(\"click\",function () { prev(); }); $next.on(\"click\",function () { next(); }); $marquee.on(\"mouseover\",function () { stop(); }); $marquee.on(\"mouseout\",function () { automatic(); }); } // 初始化函数 function render(){ createImg(); initSize(); addClickEvent(); if(_auto){ automatic(); } } render(); // 返回this对象，让链式调用继续 return $marquee; }; 如此我们就实现了一个常用的图片轮播的插件，其它小伙伴使用起来也是非常方便的。 该插件可优化的地方还是非常多的，例如可以把这些方法使用面向对象的形式编写，等等。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-12 07:53:46 "},"幻灯片插件.html":{"url":"幻灯片插件.html","title":"jquery幻灯片插件","keywords":"","body":"要求 作业要求 代码地址 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-12 07:56:28 "},"Deferred.html":{"url":"Deferred.html","title":"jquery Deferred 对象","keywords":"","body":"前言 虽然现在才学习Deferred显示的有点太晚了，但是可以让我们了解清楚，一些事物的发展。譬如Deferred 和 Promise 之间的差异。 什么是deferred对象 deferred对象就是jQuery的回调函数解决方案 deferred是如何处理回调的。 【ajax普通写法】 　　$.ajax({ 　　　　url: \"test.html\", 　　　　success: function(){ 　　　　　　alert(\"哈哈，成功了！\"); 　　　　}, 　　　　error:function(){ 　　　　　　alert(\"出错啦！\"); 　　　　} 　　}); 有了deferred对象后的写法 $.ajax(\"test.html\") 　.done(function(){ alert(\"哈哈，成功了！\"); }) 　.fail(function(){ alert(\"出错啦！\"); }); 现在是纯链式调用了。 通过上面我们大概已经对deferred有一个初步了解了。就是让回调的方式变成了现在的链式调用。 deferred在ajax中使用 【常规使用】 $.ajax(\"test.html\") 　.done(function(){ alert(\"哈哈，成功了！\"); }) 　.fail(function(){ alert(\"出错啦！\"); }); 【多个回调函数】 $.ajax(\"test.html\") 　.done(function(){ alert(\"哈哈，成功了！\");} ) 　.fail(function(){ alert(\"出错啦！\"); } ) 　.done(function(){ alert(\"第二个回调函数！\");} ); 【为多个操作指定回调函数】 这段代码的意思是，先执行两个操作$.ajax(\"test1.html\")和$.ajax(\"test2.html\")，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。 $.when($.ajax(\"test1.html\"), $.ajax(\"test2.html\")) 　　.done(function(){ alert(\"哈哈，成功了！\"); }) 　　.fail(function(){ alert(\"出错啦！\"); }); deferred在普通异步函数中的应用 现在有一个这样的函数 　　var wait = function(){ 　　　　var tasks = function(){ 　　　　　　alert(\"执行完毕！\"); 　　　　}; 　　　　setTimeout(tasks,5000); 　　}; 我现在想等wait函数执行完成后，获取回调然后再去执行一些事情，该如何处理。 【老方法】 　　var wait = function(callback){ 　　　　var tasks = function(){ callback&&callback(); 　　　　　　 alert(\"执行完毕！\"); 　　　　}; 　　　　setTimeout(tasks,5000); 　　}; 函数经过这么一改造，我们只需这样调用： wait(function(){ console.log('callback'); }); 这就是我们传统的编写回调的方式。那么现在我们有了deferred该如何做能让我们可以链式调用呢？ 【新方法】 var wait = function(){ var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function(){ console.log(\"执行完毕！\"); dtd.resolve(); // 改变Deferred对象的执行状态 }; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象 }; $.when(wait()) .done(function(){ console.log(\"哈哈，成功了！\"); }) .fail(function(){ console.log(\"出错啦！\"); }); 代码解释： dtd.resolve() 这行代码其实跟我们上面的 callback&&callback(); 这句非常相似。dtd.resolve()是告诉dtd对象，我们运行结束了。此时会把结果返回出去给done函数。 return dtd.promise() jQuery提供了deferred.promise()方法。它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done()方法和fail()方法），屏蔽与改变执行状态有关的方法（比如resolve()方法和reject()方法），从而使得执行状态不能被改变。 这里讲wait方法改造成dtd对象方法有很多种，这里只讲了一种常用的方式。 deferred对象的方法 $.Deferred() 生成一个deferred对象 deferred.done() 指定操作成功时的回调函数 deferred.fail() 指定操作失败时的回调函数 deferred.promise() 没有参数时，返回一个新的deferred对象，该对象的运行状态无法被改变；接受参数时，作用为在参数对象上部署deferred接口。 deferred.resolve() 手动改变deferred对象的运行状态为\"已完成\"，从而立即触发done()方法。 deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为\"已失败\"，从而立即触发fail()方法。 $.when() 为多个操作指定回调函数。 deferred.then()有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。$.when($.ajax( \"/main.php\" )) .then(successFunc, failureFunc ); deferred.always()这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。$.ajax( \"test.html\" ) .always( function() { alert(\"已执行！\");} ); 小结 相比通过本文，我们会对现在的ES6 Promise 对象更加了解些了。同时如果以后有机会再次使用jquery库时，我们也可以大胆的使用deferred对象，让代码更加优雅！ Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-18 10:26:43 "},"源码.html":{"url":"源码.html","title":"源码阅读","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-30 14:40:47 "},"underscore源码-内部方法.html":{"url":"underscore源码-内部方法.html","title":"underscore源码-内部方法","keywords":"","body":"内部调用方法 无new构造一个对象方式 var _ = function(obj) { // 以下均针对 OOP 形式的调用 // 如果是非 OOP 形式的调用，不会进入该函数内部 // 如果 obj 已经是 `_` 函数的实例，则直接返回 obj if (obj instanceof _) return obj; // 如果不是 `_` 函数的实例 // 则调用 new 运算符，返回实例化的对象 if (!(this instanceof _)) return new _(obj); // 将 obj 赋值给 this._wrapped 属性 this._wrapped = obj; }; 判断是不是类似数组 var property = function(key) { return function(obj) { return obj == null ? void 0 : obj[key]; }; }; var getLength = property('length'); var isArrayLike = function(collection) { // 返回参数 collection 的 length 属性值 var length = getLength(collection); return typeof length == 'number' && length >= 0 && length 修改回调函数的this指向 // underscore 内部方法 // 根据 this 指向（context 参数） // 以及 argCount 参数 // 二次操作返回一些回调、迭代方法 var optimizeCb = function(func, context, argCount) { // 如果没有指定 this 指向，则返回原函数 if (context === void 0) return func; switch (argCount == null ? 3 : argCount) { case 1: return function(value) { return func.call(context, value); }; case 2: return function(value, other) { return func.call(context, value, other); }; // 如果有指定 this，但没有传入 argCount 参数 // 则执行以下 case // _.each、_.map case 3: return function(value, index, collection) { return func.call(context, value, index, collection); }; // _.reduce、_.reduceRight case 4: return function(accumulator, value, index, collection) { return func.call(context, accumulator, value, index, collection); }; } // 其实不用上面的 switch-case 语句 // 直接执行下面的 return 函数就行了 // 不这样做的原因是 call 比 apply 快很多 // .apply 在运行前要对作为参数的数组进行一系列检验和深拷贝，.call 则没有这些步骤 // 具体可以参考： // https://segmentfault.com/q/1010000007894513 // http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.3 // http://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.4 return function() { return func.apply(context, arguments); }; }; Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:42:30 "},"underscore源码-外部方法.html":{"url":"underscore源码-外部方法.html","title":"underscore源码-外部方法","keywords":"","body":"each方法 _.each = _.forEach = function(obj, iteratee, context) { // 根据 context 确定不同的迭代函数 iteratee = optimizeCb(iteratee, context); // 如果没有this则返回原函数 var i, length; // 如果是类数组 // 默认不会传入类似 {length: 10} 这样的数据 if (isArrayLike(obj)) { // 遍历 for (i = 0, length = obj.length; i map 方法的实现 _.map = _.collect = function(obj, iteratee, context) { // 根据 context 确定不同的迭代函数 iteratee = cb(iteratee, context); // 如果传参是对象，则获取它的 keys 值数组（短路表达式） var keys = !isArrayLike(obj) && _.keys(obj), // 如果 obj 为对象，则 length 为 key.length // 如果 obj 为数组，则 length 为 obj.length length = (keys || obj).length, results = Array(length); // 创建一个有相应length的空数组包含 // 遍历 for (var index = 0; index reduce方法的实现 // Create a reducing function iterating left or right. // dir === 1 -> _.reduce // dir === -1 -> _.reduceRight function createReduce(dir) { // Optimized iterator function as using arguments.length // in the main function will deoptimize the, see #1991. function iterator(obj, iteratee, memo, keys, index, length) { for (; index >= 0 && index 0 ? 0 : length - 1; // Determine the initial value if none is provided. // 如果没有指定初始值 // 则把第一个元素指定为初始值 if (arguments.length Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 17:43:01 "},"优雅的代码.html":{"url":"优雅的代码.html","title":"写的更优雅","keywords":"","body":"如何更加优雅 组件化的粒度尽可能细，这样可复用性就大大提升 尽量抽取可配置项目到config.js|config.json文件中 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-05-31 11:39:59 "},"zc笔记.html":{"url":"zc笔记.html","title":"zc概览","keywords":"","body":"所有写JSON.parse() 都要写try catch 进行容错处理 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-29 21:29:10 "},"zc周报.html":{"url":"zc周报.html","title":"zx周报","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-10 09:37:33 "},"zc第一周周报.html":{"url":"zc第一周周报.html","title":"zc-第一周-周报","keywords":"","body":"前言 在本周接触了一个关于“前端框架演变”的话题。今天我们就来聊聊，它到底是怎么进行演变的。 前端框架演变 web1.0时代 此时前端展示数据比较简单，通常是由后台使用模板引擎直接渲染的。在这个时期都还未产生“前端工程师”，更别谈前端的发展能有多快了。这个时代作者经历的并不多，比较也已经过去了很多年了，这里就不深究。 web2.0时代 前端展示趋于复杂，所以逐渐就开始前后端分离式架构。此时有一个关键词ugc: user generate content 用户生成内容，也意味着交互越来越复杂，故而逐渐产生了“前端工程师”，专门来维护这些复杂的交互界面，后台也可以专注于本该属于他们自己的业务逻辑以及业务架构中。 第一个时期：DIV+CSS布局解放：面向 DOM 编程 在面向DOM编程过程非常直观并且易操作，有一个缺点就是大量的代码冗余，例如获取元素等，于是乎就诞生了伟大的jQuery库 jquery优势： 轻量级(采用 UglifyJS 压缩后，大小保持在30kb左右) 强大的选择器 出色的DOM操作的封装 可靠的事件处理机制 对Ajax的封装完善 不污染顶级变量(jQuery只建立一个名为jQuery的对象) 出色的浏览器兼容性 链式操作方式 丰富的插件支持 第二个时期：Ajax 动态网页：面向数据编程 Ajax直接拯救了JavaScript这么语言。 我们终于可以再提交一个表单的时候，不需要再刷新界面了。给了用户一个非常好的用户体验，最初在google的GMAIL中取得巨大的成功。逐渐全世界风靡。彼时的程序员的一个重要考核标准就是能不能熟练掌握Ajax。 第三个时期：浏览器兼容：面向浏览器编程 随着浏览器的种类繁多，以及它们都有自己的一套标准，使得研发人员在编写代码的时候要兼容多浏览器，于是乎就产生了两种编程思想 向下兼容思想(做设计时要考虑到兼容到低版本浏览器) 渐进增强思想(高版本的浏览器使用最新的技术，低版本浏览器使用老旧点的技术) 就譬如reset.css就是为了统一浏览器展示而存在的。 第四个时期：SPA 大型前端：面向模块编程 随着项目的复杂度越高，前端也开始仿制后端进行模块化编程，例如现在流行的前端三大框架Angular、React、Vue，都是MV*架构模式 逐渐的我们可以开发中用户体验更佳的web应用了，用户调整一个路由再也不需要等待后台的界面返回了，用户可以快速的切换各个界面间，而只需要付出极小的“带宽” 至于未来的前端技术还会如何发展，我们也需要尽更时代的发展了。 接下来我们通过技术层面来看看变换 从jquery操作DOM 到 框架的演变 【操作DOM】普通代码编写时，jquery直接操作DOM去做一些增删改查的工作，当项目的增大，代码也是越来越复杂，非常不好管理。于是这个时候就开始借鉴后端的模板引擎的思想，为什么要一直操作DOM去增删改查，这样显得太麻烦了，为什么不先定义好数据模型，不论什么操作，我们先更改模型里面的数据，然后在通过模板一次性去render到界面上去，这样就类似react这些框架只操作数据去改变界面了。使得代码可管理型增强了好多。 【mvc】 基于上图，于是乎就出现了一个非常知名的前端MVC分层管理框架backbone M(Model)：数据模型层V(View)：视图层，负责展示界面的层C(Controller)：控制层，主要就是操作数据来渲染视图的层 【现代框架】 框架是对一个完整代码组织方法的描述 当大家意识到，每次请求一个页面都要向后台去发送一个请求，有时候似乎是比较浪费资源的，并且一些重复的已经看过的界面任然要去向后台请求，大家开始思考组件化加上前端自定义路由的重要性，这样只需要加载一次代码，通过前端自定义路由实现界面之间的跳转，不用再向后台请求界面了，速度和体验一下子增加了不少。 正因为这些问题于是乎就诞生了现代框架：Angular Vue React 【优势劣势】 每个时期的东西都有每个时期的优势，不是说我们使用了react的就可以完全抛弃jQuery。再做技术选型时还是要综合考虑我们的项目比较适合哪种技术，而不是哪种技术好我们就使用哪种技术。 小结 通过本文我们大概能了解到前端的一个发展历史，以及前端技术的一个演变历史。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-15 23:42:13 "},"zc第二周周报.html":{"url":"zc第二周周报.html","title":"zc-第二周-周报","keywords":"","body":"前言 修养是评判一个人的标准。我们做人要有修养，那么我们做事情同样的也是要有修养。那么我们做前端开发也是必须要有修养的。这也是我们常常会忽略的地方。 举个例子: 添加a标签的时候，你是否扩大了点击区域。 多菜单进行切换的时候，是否加了延时 所有请求后台数据，是否加了结果反馈 当数据请求时间过长时，是否添加了loading 以上的这些点与你的技术好坏无关，关乎的是一种“工匠精神”。甚至乎可以说是“职业素养” 今天我们就仔细讲讲如何可以提供我们的职业素养。做到领导交给我们的事情，可以做到尽善尽美。可以让我们在同行中脱颖而出！ 尊重客观的认知规律律 认知是以经验规律对感觉信息进行组织得到的--格式塔学派 格式塔学派（德语：Gestalttheorie） ：是心理学重要流派之一，兴起于 20 世纪初的德国，又称为完形心理学；主张人脑的运作原理是整体的，『整体不同于其部件的总和』。——摘自『维基百科』 【临近性】 先看看下面的图形组合，我们会倾向于认为左边的圆点以“行”来组合，而右边的圆点以“列”来组合，而仅仅是因为距离的远近就能产生这样的感官现象——我们会将靠的近的部件自动视为一组。 【相似性】 我们再来观察下面的一组星星，我们会自动将第一行是做一组，第二行为另外一组，最后两行视作一组，我们会将相似相近的东西自动联系起来，这就是所谓的相似性原理 在实际页面上的应用： 【连续性】 又得用这张用烂了的例子，但的确很经典。两条直线之间虽然有圆形阻挡，IBM的字样虽然有很多横条割开，但并不妨碍我们判定两直线相交以及辨认出字母的内容，这是因为我们的视觉有着给对象进行分组来感知事物的倾向，更倾向于感知连续的事物或联系的形式，而不是碎片化的信息。因此即使我们看到了非连续的事物，也会自动将其看成完整化。这就是格式塔理论中的连续性原理。 【封闭性】 视觉系统自动尝试将敞开的图形关闭起来，从而将其感知为完整的物体而不是分散的碎片。 注：简单理解，当图形是一个残缺图形，但主体有一种使其闭合的倾向，即主体能自行填补缺口而把其知觉为一个整体。 我们的视觉系统强烈倾向于看到物体，以至于它能将一个空白区解析成一个物体，所以我们看到上图所呈现的是一个圆而非多条线段。 最著名的应用便是苹果公司的logo，咬掉的缺口唤起人们的好奇、疑问，给人巨大想象空间 信息架构 简而言之就是对一些信息进行排列组合，呈现给用户查阅。 有几个大原则是需要我们去遵守的： 和谐 结构清晰 间距规范 对齐 看下微信里面的一个子页面： 结构清晰，间距规范，对齐工整，这些要素全部都符合，正式因为这些细节做的足够好，微信才会是一款优秀的app 统一 字体 颜色 边距 同样在电商这样强展示的网站，同样都做到了字体统一，颜色统一，边距统一 反馈 一般都是用户在web界面上进行操作，网站给予用户的反馈。 Hover Active Loading 结果提示 就不一一举例子了，可以去各大电商网站去看，基本上各类操作的都会给用户反馈的。 易用 关于易用性交互则是一个需要把用户习惯研究到极致，才能做得非常好的一部分。下面举几个常见例子 一. menu意图判断从动态图片中可以看到，当我们鼠标快速的从下面的导航栏滑动到导航面板中，是没有对导航进行切换的。这个就是所谓易用性处理了。 大家都知道正常hover效果你滑到下面就会切换到其它导航的，但是这里对用户意图进行了判断。 二. a标签扩大点击区域 从动图可以看到，当鼠标没有放在文字上面的时候同样式有点击的效果，这样就把a链接的点击区域阔达了，方便用户点击。 等等的易用性操作还是有非常多的，这个需要网站研发人员的心细观察分析，想做一款好的产品绝非一蹴而就的。 小结 今天学习的这些东西虽然说都是偏设计的，但是这与前端研发人员是息息相关的，所有这些优化操作都是需要代码去实现的，当你上一个环节没有做的很好的时候，作为一个团队，我们是有责任去提醒或一起探讨这些问题。尽力做好每一个产品。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-20 07:32:20 "},"zc图片知多少.html":{"url":"zc图片知多少.html","title":"zc-第三周-周报","keywords":"","body":"前言 作为前端工程师，我们对于图片的了解是否还是停留在，反正这样就可以展示这张图片了，但其实图片对于前端展示是一个很重的话题，例如一个界面图片多了，展示非常慢，这个时候前端有什么策略可以较快界面展示吗？有，例如压缩图片，图片懒加载等策略都可以加速这个界面的展示。这只是冰山一角，所以本文将努力的详细介绍关于图片的知识。 图片分类 图片种类有非常多种，今天这篇文章只介绍前端工作中经常接触到的类型。 图形分为位图和矢量图。 位图是基于颜色的描述，是由像素点组成的图像； 而矢量图是基于数学矢量的描述，是由几何图元组成的图像，与分辨率无关。 矢量图 svg 位图 有损位图：jpg、webp、png8、gif 无损位图：png24、png32 svg SVG是XML语言的一种形式，有点类似XHTML，它可以用来绘制矢量图形，可以通过定义必要的线和形状来创建一个图形，也可以修改已有的位图，或者将这两种方式结合起来创建图形，一种开放标准的矢量图形语言，可任意放大图形显示，边缘异常清晰，文字在SVG图像中保留可编辑和可搜寻的状态，没有字体的限制，生成的文件很小，下载很快，十分适合用于设计高分辨率的Web图形页面。 　　 以上代码就描述了一个svg图形，直接放入HTML就可以运行 svg 学习教程 jpg 最常用的图像文件格式，由一个软件开发联合会组织制定，是一种有损压缩格式，能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。 尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。但是JPEG压缩技术十分先进，它用有损压缩方式去除冗余的图像数据，在获得极高的压缩率的同时能展现十分丰富生动的图像 优点： 摄影作品或写实作品支持高级压缩。 利用可变的压缩比可以控制文件大小。 JPEG 广泛支持 Internet 标准。 缺点： 有损耗压缩会使原始图片数据质量下降。 当您编辑和重新保存 JPEG 文件时，JPEG 会混合原始图片数据的质量下降。这种下降是累积性的。 JPEG 不适用于所含颜色很少、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片。 webp WebP (发音\"weppy\")，是一种同时提供了有损压缩与无损压缩的图片文件格式，派生自图像编码格式VP8 。 WebP是Google新推出的影像技术，它可让网页图档有效进行压缩，同时又不影响图片格式兼容与实际清晰度，进而让整体网页下载速度加快。 由于目前互联网上传输的数据有65%都是图片，WebP就是出于减少数据量、加速网络传输的目的而开发的。为了改善JPEG的图片压缩技术，他们使用了一种基于VP8编码(已在2010五月开源)的图片压缩器，利用预测编码技术，同时还采用了一种基于RIFF的非常轻量级的容器。这种容器只会给每张图片增加20字节，但能让图片作者保存他们想要存储的元数据。 与JPEG相同，WebP是一种有损压缩利用预测编码技术。但谷歌表示，这种格式的主要优势在于高效率。他们发现，“在质量相同的情况下，WebP格式图像的体积要比JPEG格式图像小40%。 目前, Google放出了WebP文件解码器(libvpx)和命令行工具(webpconv)，用于JPEG等格式图片与WebP格式之间的转换，不过系统支持暂时仅限Linux。 看一下png图片与webp图片的对比： 现在淘宝，jd，等大型电商网站都在使用webp格式图片。 [注意]webp的兼容性非常差，目前只有chrome的支持比较好，如果需要使用，请先查阅can i use 网站 png 便携式网络图形（外语简称PNG、外语全称：Portable Network Graphics），是网上接受的最新图像文件格式。PNG能够提供长度比GIF小30%的无损压缩图像文件。 png通常用在颜色复杂并且要求特别精细或者有透明需求的图片上，如复杂的logo、图标等。由于无损还可以当做“原图”来存档使用。 【png8】 png-8采用无损压缩(小于256色时)，是基于8位索引色的位图格式。png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。这也是png-8没办法完全替代gif的重要原因。如果没有动画需求推荐使用png-8来替代gif。 优点： 现有工具压缩算法好 支持alpha通道 ie6也支持alpha通道 缺点： 只支持256色 【png24/png32】png24/32采用无损压缩，是基于直接色的位图格式。png24/32的图片质量堪比bmp，但是却有bmp不具备的尺寸优势。当然相比于jpg，gif，png8，尺寸上还是要大。正是因为其高品质，无损压缩，非常适合用于源文件或需要二次编辑的图片格式的保存。 png24/32与jpg一样能表达丰富的图片细节，但并不能替代jpg。图片存储为png24/32比存储为jpg，文件大小至少是jpg的5倍，但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用jpg。 什么是png24/png32？png24就是24位png——8位_3通道（RGB红绿蓝）。png32就是32位png——8位_4通道（RGBA红绿蓝透明） png24支持：rbg(xxx,xxx,xxx); png32支持：rgba(xxx,xxx,xxx,x); 多了一个alpha通道设置 优点： 颜色丰富 支持alpha通道 无损压缩 缺点： 图片太大。 ie6不支持alpha通道(现在已经完全不用开了ie6了) 使用建议尺寸小的，色彩不丰富的和背景透明的切成gif或者png8的半透明的切成png32 gif 采用LZW压缩算法进行编码，是一种无损的基于索引色的图片格式。由于采用了无损压缩(小于256色)，相比古老的bmp格式，尺寸较小，而且支持透明和动画。缺点是由于gif只存储8位索引（也就是最多能表达2^8=256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。色彩简单的logo、icon、线框图适合采用gif格式。 优点 优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。 可插入多帧,从而实现动画效果。 缺点 由于采用了8位压缩,最多只能处理256种颜色（2的8次方）,故不宜应用于真彩图像。 图片优略势对比 格式 优点 缺点 适用场景 jpg 色彩丰富时压缩率高、边缘平滑 有损、不可重复压缩、不支持透明通道 照片 webp 类似 jpg、压缩率更⾼(但质量不好)，支持动画、透明 编码时间⻓ 8 倍、浏览器兼容性不好 照片 png32 无损、支持透明通道、颜色丰富、色彩有限时压缩率高、可以多次压缩 不支持动画、色彩丰富时压缩率低 平面设计图 png8 色彩低于256种无损、色彩少时压缩率高、支持透明 色彩对于256种则有损 logo、icon、透明图 gif 色彩低于256种无损、色彩少时压缩率高、支持动画 色彩对于256种则有损 动画 svg 无损、可缩放、可交互 只适合描述“图形” 图标、图表 网页中如何引用图片 1、引入：HTML 2、加载： 加载过程1：浏览器 (HTTP)-> 应用服务器 (服务器本地读取)-> 返回图片缺点：访问量大的时候，应用服务器是没有办法负荷的。 3、渲染：两大原则：1）不能改变图片的长宽比(不让图片扭曲展示)2）不展示低分辨率的图片(不展示模糊的图片) 由于图片文件大，但又是web网页中不可或缺的一种元素，在图片展示优化上也是任重而道远，下面介绍几种常用图片优化方案。 优化图片加载 【CDN】 CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。 CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。 这样就大大较少应用服务器的负荷了，这也是目前比较主流的方式。 【浏览器的缓存策略】这个步骤不需要去设置，这是浏览器对于图片的缓存策略，这里展示出来加深理解 【懒加载】 原理：主要原理是将非首屏的图片src设为一个默认值，然后监听窗口滚动，当图片出现在视窗中时再给他赋予真实的图片地址，这样可以保证首屏的加载速度然后按需加载图片。 lazyLoad 插件地址 【雪碧图】 原理：将网站要使用的小的icon放到一张png图片中，然后通过background-position定位展示相应位置的icon。这样做的好处是只需要发起一次http请求。 【base64】 图片的 base64 编码就是可以将一副图片数据编码成一串字符串，使用该字符串代替图像地址; 优点： 减少http请求 适合小的icon图片 缺点： 明显会增大HTML体积，如果图片过大的话明显影响网页的打开速度，尤其在spa项目中影响首屏加载速度。 IE 8 以下不支持 data url 常用图片压缩工具 tinypng网站压缩 pngquant本地压缩工具，支持Linux、Windows、macOS pngquant for mac 小结 通过本文的学习，现在是不是对png、jpg、gif、webp都有一定的了解了，之后在与设计沟通中可以利用以上知识给出合理意见。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-26 06:50:49 "},"zc作业.html":{"url":"zc作业.html","title":"zx作业","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-10 09:31:07 "},"zcCore.html":{"url":"zcCore.html","title":"zx-core","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-10 09:32:11 "},"zc前端修养.html":{"url":"zc前端修养.html","title":"1、前端的自我修养","keywords":"","body":"前言 修养是评判一个人的标准。我们做人要有修养，那么我们做事情同样的也是要有修养。那么我们做前端开发也是必须要有修养的。这也是我们常常会忽略的地方。 举个例子: 添加a标签的时候，你是否扩大了点击区域。 多菜单进行切换的时候，是否加了延时 所有请求后台数据，是否加了结果反馈 当数据请求时间过长时，是否添加了loading 以上的这些点与你的技术好坏无关，关乎的是一种“工匠精神”。甚至乎可以说是“职业素养” 今天我们就仔细讲讲如何可以提供我们的职业素养。做到领导交给我们的事情，可以做到尽善尽美。可以让我们在同行中脱颖而出！ 尊重客观的认知规律律 认知是以经验规律对感觉信息进行组织得到的--格式塔学派 格式塔学派（德语：Gestalttheorie） ：是心理学重要流派之一，兴起于 20 世纪初的德国，又称为完形心理学；主张人脑的运作原理是整体的，『整体不同于其部件的总和』。——摘自『维基百科』 【临近性】 先看看下面的图形组合，我们会倾向于认为左边的圆点以“行”来组合，而右边的圆点以“列”来组合，而仅仅是因为距离的远近就能产生这样的感官现象——我们会将靠的近的部件自动视为一组。 【相似性】 我们再来观察下面的一组星星，我们会自动将第一行是做一组，第二行为另外一组，最后两行视作一组，我们会将相似相近的东西自动联系起来，这就是所谓的相似性原理 在实际页面上的应用： 【连续性】 又得用这张用烂了的例子，但的确很经典。两条直线之间虽然有圆形阻挡，IBM的字样虽然有很多横条割开，但并不妨碍我们判定两直线相交以及辨认出字母的内容，这是因为我们的视觉有着给对象进行分组来感知事物的倾向，更倾向于感知连续的事物或联系的形式，而不是碎片化的信息。因此即使我们看到了非连续的事物，也会自动将其看成完整化。这就是格式塔理论中的连续性原理。 【封闭性】 视觉系统自动尝试将敞开的图形关闭起来，从而将其感知为完整的物体而不是分散的碎片。 注：简单理解，当图形是一个残缺图形，但主体有一种使其闭合的倾向，即主体能自行填补缺口而把其知觉为一个整体。 我们的视觉系统强烈倾向于看到物体，以至于它能将一个空白区解析成一个物体，所以我们看到上图所呈现的是一个圆而非多条线段。 最著名的应用便是苹果公司的logo，咬掉的缺口唤起人们的好奇、疑问，给人巨大想象空间 信息架构 简而言之就是对一些信息进行排列组合，呈现给用户查阅。 有几个大原则是需要我们去遵守的： 和谐 结构清晰 间距规范 对齐 看下微信里面的一个子页面： 结构清晰，间距规范，对齐工整，这些要素全部都符合，正式因为这些细节做的足够好，微信才会是一款优秀的app 统一 字体 颜色 边距 同样在电商这样强展示的网站，同样都做到了字体统一，颜色统一，边距统一 反馈 一般都是用户在web界面上进行操作，网站给予用户的反馈。 Hover Active Loading 结果提示 就不一一举例子了，可以去各大电商网站去看，基本上各类操作的都会给用户反馈的。 易用 关于易用性交互则是一个需要把用户习惯研究到极致，才能做得非常好的一部分。下面举几个常见例子 一. menu意图判断从动态图片中可以看到，当我们鼠标快速的从下面的导航栏滑动到导航面板中，是没有对导航进行切换的。这个就是所谓易用性处理了。 大家都知道正常hover效果你滑到下面就会切换到其它导航的，但是这里对用户意图进行了判断。 二. a标签扩大点击区域 从动图可以看到，当鼠标没有放在文字上面的时候同样式有点击的效果，这样就把a链接的点击区域阔达了，方便用户点击。 等等的易用性操作还是有非常多的，这个需要网站研发人员的心细观察分析，想做一款好的产品绝非一蹴而就的。 小结 今天学习的这些东西虽然说都是偏设计的，但是这与前端研发人员是息息相关的，所有这些优化操作都是需要代码去实现的，当你上一个环节没有做的很好的时候，作为一个团队，我们是有责任去提醒或一起探讨这些问题。尽力做好每一个产品。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-17 21:03:39 "},"zc前端框架.html":{"url":"zc前端框架.html","title":"2、前端框架","keywords":"","body":"前端框架演变 web1.0时代 前端展示数据比较简单，通常是由后台使用模板引擎直接渲染的。 web2.0时代 前端展示趋于复杂，所以逐渐就开始前后端分离式架构。ugc: user generate content 用户生成内容，也意味着交互越来越复杂 1、DIV+CSS布局解放：面向 DOM 编程 在面向DOM编程过程非常直观并且易操作，有一个缺点就是大量的代码冗余，例如获取元素等，于是乎就诞生了伟大的jQuery库 jquery优势： 轻量级(采用 UglifyJS 压缩后，大小保持在30kb左右) 强大的选择器 出色的DOM操作的封装 可靠的事件处理机制 对Ajax的封装完善 不污染顶级变量(jQuery只建立一个名为jQuery的对象) 出色的浏览器兼容性 链式操作方式 丰富的插件支持 2、Ajax 动态网页：面向数据编程 实现网页局部刷新的伟大发明 3、浏览器兼容：面向浏览器编程 随着浏览器的种类繁多，以及它们都有自己的一套标准，使得研发人员在编写代码的时候要兼容多浏览器，于是乎就产生了两种编程思想 向下兼容思想(做设计时要考虑到兼容到低版本浏览器) 渐进增强思想(高版本的浏览器使用最新的技术，低版本浏览器使用老旧点的技术) 就譬如reset.css就是为了统一浏览器展示而存在的。 4、SPA 大型前端：面向模块编程 随着项目的复杂度越高，前端也开始仿制后端进行模块化编程，例如现在流行的前端三大框架Angular、React、Vue，都是MV*架构模式 jquery 操作 DOM -> 框架的演变 【操作DOM】普通代码编写时，jquery直接操作DOM去做一些增删改查的工作，当项目的增大，代码也是越来越复杂，非常不好管理。于是这个时候就开始借鉴后端的模板引擎的思想，为什么要一直操作DOM去增删改查，这样显得太麻烦了，为什么不先定义好数据模型，不论什么操作，我们先更改模型里面的数据，然后在通过模板一次性去render到界面上去，这样就类似react这些框架只操作数据去改变界面了。使得代码可管理型增强了好多。 【mvc】 基于上图，于是乎就出现了一个非常知名的前端MVC分层管理框架backbone M(Model)：数据模型层V(View)：视图层，负责展示界面的层C(Controller)：控制层，主要就是操作数据来渲染视图的层 【现代框架】 框架是对一个完整代码组织方法的描述 当大家意识到，每次请求一个页面都要向后台去发送一个请求，有时候似乎是比较浪费资源的，并且一些重复的已经看过的界面任然要去向后台请求，大家开始思考组件化加上前端自定义路由的重要性，这样只需要加载一次代码，通过前端自定义路由实现界面之间的跳转，不用再向后台请求界面了，速度和体验一下子增加了不少。 正因为这些问题于是乎就诞生了现代框架：Angular Vue React 【优势劣势】 每个时期的东西都有每个时期的优势，不是说我们使用了react的就可以完全抛弃jQuery。再做技术选型时还是要综合考虑我们的项目比较适合哪种技术，而不是哪种技术好我们就使用哪种技术。 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-14 07:28:47 "},"zc前端规范.html":{"url":"zc前端规范.html","title":"3、前端规范","keywords":"","body":"规范 为什么要规范 跟性能无关 - 效率有关跟功能无关 - 减少团队 gap跟结果无关 - 保留最佳实践 易读 我们写出来的代码要去执行，但是更重要是要被维护，例如该什么时候空格，这个对于保持易读性来说非常重要 css 规范 css 将属性分3类：布局类，内容类，修饰类 js 规范 变量: 小驼峰(myName)、区分单复数(names 与 name 的区别) 对象: 大驼峰(Person)、单数 常量: 大写 函数: 小驼峰、语义化 布尔值: 小驼峰(is,has,can) 私有属性: 小驼峰 常用规范 中文英文或中文数字之间是要有空格的 命名要非常注意，这个可以直接看出编程修养的 规范管理 stylelint ESLint editorconfig（编辑器支持的，统一团队配置） Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-20 07:55:00 "},"IDEA.html":{"url":"IDEA.html","title":"IDEA","keywords":"","body":"Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-15 23:53:28 "},"IDEA快捷键.html":{"url":"IDEA快捷键.html","title":"IDEA快捷键","keywords":"","body":"前言 题主使用IDEA主要是前端开发，所以不会涉及关于java sdk maven 等相关知识及快捷键 本文主要列举些项目常用的快捷键 常用快捷键 Ctrl 在当前文件进行文本查找：Ctrl + F 严格匹配：Match Case 正则匹配：Regex 在当前文件进行文本替换：Ctrl + R 撤销 ：Ctrl + Z 剪切光标所在行 或 剪切选择内容 ：Ctrl + X 复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面：Ctrl + D 关闭当前卡片：Ctrl + W 显示最近打开的文件记录列表：Ctrl + E 打开新建文件窗口：Ctrl + N 相当于Ctrl + 单击 进入该方法：Ctrl + B 前往当前光标所在的方法的父类的方法 / 接口定义：Ctrl + U 版本控制提交项目：Ctrl + K 版本控制更新项目：Ctrl + T 展开代码：Ctrl + + 折叠代码：Ctrl + - 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号：Ctrl + / 编辑窗口切换：Ctrl + Tab 光标切换到行尾：Ctrl + 右方向 光标切换到行首：Ctrl + 左方向 Shift 取消缩进：Shift + Tab 开始新一行：Shift + Enter 关闭当前文件：Shift + 单击 + 文件名 Ctrl + Alt 格式化代码，可以对当前文件和整个包目录使用：Ctrl + Alt + L 对选中的代码弹出环绕选项弹出层：Ctrl + Alt + T 光标所在行上空出一行，光标定位到新行：Ctrl + Alt + Enter 退回到上一个操作的地方：Ctrl + Alt + 左方向键 前进到下一个操作的地方：Ctrl + Alt + 右方向键 Ctrl + Shift 根据输入内容查找整个项目 或 指定目录内文件：Ctrl + Shift + F 根据输入内容替换对应内容：Ctrl + Shift + R 取消撤销：Ctrl + Shift + Z 对选中的代码进行大 / 小写轮流转换：Ctrl + Shift + U 复制当前文件磁盘路径到剪贴板：Ctrl + Shift + C 弹出缓存的最近拷贝的内容管理器弹出层：Ctrl + Shift + V 展开所有代码：Ctrl + Shift + + 折叠所有代码：Ctrl + Shift + - 选择该行：Ctrl + Shift + 左方向键|右方向键 光标放在方法名上，调整方法排序：Ctrl + Shift + 前方向键|后方向键 Alt + Shift 移动光标所在行向上移动：Alt + Shift + 前方向键 移动光标所在行向下移动：Alt + Shift + 后方向键 Ctrl + Shift + Alt 无格式黏贴：Ctrl + Shift + Alt + V 参考资料 快捷键 Copyright © frankshi.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-16 18:30:06 "}}